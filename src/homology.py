#! /usr/bin/env python
#
"""Generic classes for homological algebra.
"""
__docformat__ = 'reStructuredText'


import types

from rational import Rational


class VectorSpace(object):
    """Represent the vector space generated by the given `base` vectors.

    After construction, you can retrieve the base vectors set and the
    dimension from instance attributes `base` and `dimension`.
    
    The `base` elements are assumed to be *linearly independent*, so
    the `dimension` of the generated vector space equals the number of
    elements in the base set.
    """
    def __init__(self, base, typecast=Rational):
        """Constructor, taking explicit base and coefficient numeric type.

        First argument `base` is a sequence of base vectors; no
        requirement is placed on the type of base vectors.  The `base`
        object should support:
          - the `len` operator;
          - the `index` operator (with the same semantics of the `list` one)

        Optional second argument `typecast` is a factory function for
        the coefficients in the coordinate vectors.  The function
        `typecast` should accept a single integer argument and return
        an instance of a type that supports addition (Python operators
        `__add__` and `__iadd__`).
        """
        self.base = base
        self.dimension = len(base)
        self._typecast = typecast

    def __iter__(self):
        """Iterate over basis vectors."""
        return iter(self.base)
        
    def __repr__(self):
        return "VectorSpace(%s)" % self.base
    def __str__(self):
        return "<Vector space with base %s>" % self.base
    
    def coordinates(self, element):
        """Return the coordinate vector of `element`.

        Argument `element` represents a linear combination as a list
        of pairs `(vector, coefficient)`, where `vector` is an item in
        the `base` (specified when constructing this object).
        """
        coordinates = [ self._typecast(0)
                        for i in xrange(self.dimension) ]
        for (vector, coefficient) in iter(element):
            coordinates[self.base.index(vector)] += coefficient
        return coordinates

    
class ChainComplex(object):
    """Represents a (finite-length) chain (homology) complex.

    A `ChainComplex` `C` of length `l` comprises vector spaces `C[i]`
    and differentials `C.differential[i]`; each `C[i]` represents the
    part of the graded vector space `C` having degree `i`.  The map
    `C.differential[i]` sends (linear combinations of) elements in
    vector space `C[i]` to linear combinations of vectors in `C[i-1]`;
    the `coordinates` method of `C[i-1]` will be used to obtain a
    numerical representation of the differentiated element.
    
    A `ChainComplex` instance must be initialized by assigning
    `VectorSpace` instances into each `C[i]` (for 0 <= `i` <
    `len(C)`), and appropriate maps into `C.differential[i]` (for 1 <=
    `i` < `len(C)`)::

      >>> # chain homology of a segment
      >>> C = ChainComplex(2)
      >>> C[1] = VectorSpace(['a'])
      >>> C[0] = VectorSpace(['b0', 'b1'])
      >>> C.differential[1] = lambda _: [('b0',1), ('b1', -1)]

    Indices of the slices `C[i]` run from 0 to `len(C)-1` (inclusive).
    The Python `len` operator returns the total length of the
    complex::
      
      >>> len(C)
      2

    At present, the only supported operation on chain complexes is
    computing the rank of homology groups::

      >>> C.compute_homology_ranks()
      [1, 0]
    """
    
    def __init__(self, length, modules=None, differentials=None):
        """Create a chain complex of specified length."""
        assert length > 0, \
                   "ChainComplex.__init__:"\
                   " argument `length` must be a positive integer," \
                   " but got `%s`." % length
        #: Total length of the complex.
        self.length = length
        #: Boundary operators; `differentials[i]` sends elements in
        #  `C[i]` to elements in `C[i+1]`.
        self.differential = [None]
        if differentials:
            assert len(differentials) == length-1, \
                   "ChainComplex.__init__:" \
                   " supplied `differentials` argument does not match" \
                   " supplied `length` argument."
            self.differential.extend(differentials)
        else:
            self.differential.extend([None] * length)
        #: The vector spaces supporting the differential complex.
        if modules:
            assert len(modules) == length, \
                   "ChainComplex.__init__:" \
                   " supplied `modules` argument does not match" \
                   " supplied `length` argument."
            self.module = modules
        else:
            self.module = [None] * length

    def __repr__(self):
        return "ChainComplex(%d, modules=%s, differentials=%s)" \
               % (self.length, self.module, self.differential)
    def __str__(self):
        return repr(self)

    ## list-like interface: support C[i] and len(C) syntax
    def __len__(self):
        return self.length
    def __getitem__(self, i):
        """Return the `i`-th pair (module, boundary operator)."""
        return (self.module[i], self.differential[i])
    def __setitem__(self, i, val):
        """Set the `i`-th support module and, optionally, boundary operator.

        ::
          C[i] = (module, differential)  # set `i`-th module and boundary op.
          C[i] = module                  # only set module
        """
        if (isinstance(val, tuple)):
            assert len(val) == 2, \
                   "ChainComplex.__setitem__:" \
                   " Need a 2-tuple (module, differential), but got `%s`" % val
            (self.module[i], self.differential[i]) = val
        else:
            self.module[i] = val

    def compute_homology_ranks(self):
        """Compute and return (list of) homology group ranks.

        Returns a list of integers: item at index `n` is the rank of
        the `n`-th homology group of this chain complex.  Since the
        chain complex has finite length, homology group indices can
        only run from 0 to the length of the complex (all other groups
        being, trivially, null).

        Examples::
        
          >>> # chain homology of a point
          >>> C_point = ChainComplex(1)
          >>> C_point[0] = VectorSpace(['a'])
          >>> C_point.compute_homology_ranks()
          [1]
          
          >>> # chain homology of a segment
          >>> C_segment = ChainComplex(2)
          >>> C_segment[1] = VectorSpace(['a'])
          >>> C_segment[0] = VectorSpace(['b0', 'b1'])
          >>> C_segment.differential[1] = lambda _: [('b0',1), ('b1', -1)]
          >>> C_segment.compute_homology_ranks()
          [1, 0]
          
          >>> # chain homology of a circle
          >>> C_circle = ChainComplex(2)
          >>> C_circle[1] = VectorSpace(['a'])
          >>> C_circle[0] = VectorSpace(['b'])
          >>> C_circle.differential[1] = lambda _: []
          >>> C_circle.compute_homology_ranks()
          [1, 1]
          
        """
        ## pass 1: compute boundary operators in matrix form
        ## 
        # FIXME: since we're only interested in computing the
        # rank, should we instanciate the matrix as row-major or
        # column-major, depending on which dimension is lesser?
        # (For doing Gaussian elimination on a smaller set.)

        #: Matrix form of boundary operators; the `i`-th differential
        #: `D[i]` is `dim C[i-1]` rows (range) by `dim C[i]` columns
        #: (domain), stored in column-major format: that is, if `A =
        #: D[i]` then `A` has entries `A[j][k]` with `j` varying from 0
        #: to `self.module[i].dimension` (domain) and `k` varying in the
        #: range `0..self.module[i-1].dimension` (codomain, row).
        D = [ [ self.module[i-1].coordinates(self.differential[i](b))
                for b in self.module[i].base ]
              for i in xrange(1, self.length)
              ]

        # check that the differentials form a complex
        if __debug__:
            for i in xrange(1, self.length - 1):
                assert is_null_matrix(matrix_product(D[i-1], D[i]))
        
        ## pass 2: compute rank and nullity of boundary operators
        ##
        ## We reduce (destructively) every boundary operator matrix to
        ## column Echelon form by Gaussian elimination, computing the
        ## rank in the process.
        ##
        #: ranks of `D[n]` matrices, for 0 <= n < len(self); the differential
        #: `D[0]` is the null map.
        ranks = [ 0 ]
        for A in D:
            ranks.append(rank_of_matrix(A))

        ## pass 3: compute homology group ranks from rank and nullity
        ##         of boundary operators.
        ##
        ## By the rank-nullity theorem, if A:V-->W is a linear map,
        ## then null(A) =  dim(V) - rk(A), hence:
        ##   dim(Z_i) = null(D_i) = dim(C_i) - rk(D_i)
        ##   dim(B_i) = rk(D_{i+1})
        ## Therefore:
        ##   h_i = dim(H_i) = dim(Z_i / B_i) = dim(Z_i) - dim(B_i)
        ##       = dim(C_i) - rk(D_i) - rk(D_{i+1})
        ##
        ranks.append(0) # augment complex with the null map.
        return [ (self.module[i].dimension - ranks[i] - ranks[i+1])
                 for i in xrange(self.length) ]
    

def rank_of_matrix(A):
    """Destructively compute rank of matrix `A`.
    The rank is computed by performing Gaussian elimination on the
    matrix `A`, which is therefore altered irreversibly.

    Matrix `A` is represented as a list of vectors; each vector is
    represented by a Python list of numbers::
    
      >>> rank_of_matrix([[1,0,0], [0,0,1]])
      2

    Since rank by columns equals rank by rows, it does not matter
    whether the vectors actually represent matrix rows or matrix
    columns::

      >>> rank_of_matrix([[1,0], [0,0], [0,1]]) \
          == rank_of_matrix([[1,0,0], [0,0,1]])
      True

    An empty list represents a 0x0 matrix::

      >>> rank_of_matrix([])
      0

    Examples::

      >>> rank_of_matrix([[0,0,0,0]])
      0

      >>> rank_of_matrix([[0,0,0,0], [0,0,0,0]])
      0

      >>> rank_of_matrix([[1,0,0]])
      1

    These matrices always have rank 2 for N>1::
    
      >>> def m(N): return [ [ float(N*n+k) for k in xrange(1,N+1) ] \
                             for n in xrange(0, N) ]
      >>> [ rank_of_matrix(m(N)) for N in xrange(10) ]
      [0, 1, 2, 2, 2, 2, 2, 2, 2, 2]
      
    Vandermonde matrices always have maximal rank::
    
      >>> def v(N): return [ [ float(k**n) for k in xrange(1,N+1) ] \
                             for n in xrange(0, N) ]
      >>> [ rank_of_matrix(v(N)) for N in xrange(10) ]
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      
    """
    sup_i = len(A)
    if sup_i == 0:
        # null matrix
        return 0
    sup_j = len(A[0])
    i = 0
    j = 0
    
    rank = 0  #: computed rank of matrix `A`
    while (i < sup_i) and (j < sup_j):
        ## pass 1 : Choose pivot as the first `i` such that `A[i][j]`
        ## is non-zero.
        ##
        ## XXX: Since we are using rational exact arithmentic, we might
        ## choose the element `A[ii][j] = Rational(p,q)` such that:
        ##   1) `abs(p) + abs(q) > 0`;
        ##   2) `abs(p) + abs(q)` is smallest among those satisfying 1).
        ## This *might* help reduce rationals growth.
        if A[i][j] == 0:
            for ii in xrange(i+1, sup_i):
                if A[ii][j] != 0:
                    # swap current `i` and `ii`
                    A[ii], A[i] = A[i], A[ii]
                    break
        if A[i][j] == 0:
            # A[* >= i][j] is always zero, try with next `j`
            j += 1
            continue # next iteration of the 'while' loop

        ## pass 2: Collect quotients `q[ii] = A[ii][j] / A[i][j]` for
        ## `ii != i`; each row/column with index `ii != i` will be
        ## subtracted a multiple of `A[i]` by `q[ii]`.
        ##
        ## Usually implementations store the quotients `q[ii]` into
        ## `A[ii][j]` (which will be then zeroed by the Gaussian
        ## elimination in pass 3), but Python has list comprehensions,
        ## which are apparently both cleaner and faster.
        ##
        pivot = A[i][j]  # micro-optimization: avoid lookup
        q = [ (A[ii][j] / pivot) for ii in xrange(i+1, sup_i) ]

        ## pass 3: Elimination step: set `A[ii] = A[ii] - A[i]*q[ii]`
        ## for `ii != i`.
        ##
        ## Since we are only interested in the rank of `A`, we only
        ## perform the elimination step above on `A[ii][jj]` for `ii >
        ## i` and `jj > j`, that is, the part of `A` that would be
        ## examined by subsequent iterations of steps 1&2.  Matrix `A`
        ## will not be in proper Echelon form, but we get the rank
        ## count right nonetheless.
        ##
        for jj in xrange(j+1, sup_j):
            for ii in xrange(i+1, sup_i):
                A[ii][jj] -= A[i][jj] * q[ii - i - 1]
        j += 1
        i += 1
        rank += 1
##         if __debug__:
##             print "DEBUG: At i=%d, j=%d:" % (i,j)
##             for a in A:
##                 print "DEBUG: %s" %a
    return rank


def is_null_matrix(A, cast=Rational):
    """Return `True` if all entries of `A` are zero."""
    for vector in A:
        for entry in vector:
            if entry != cast(0):
                return False
    return True


def matrix_product(A, B):
    """Return the matrix product of `A` and `B`."""
    assert len(A) == len(B[0]), \
           "homology.matrix_product:"\
           " multiplying (%d x %d)-matrix A with (%d x %d)-matrix B."\
           % (len(A[0]), len(A), len(B[0]), len(B))
    if len(A) > 0:
        # result[i][j] = A[k][j] * B[i][k]
        return [ [ sum([ A[k][j]*B[i][k] for k in xrange(len(A)) ], Rational(0))
                   for j in xrange(len(A[0])) ]
                 for i in xrange(len(B)) ]
    else:
        # return null matrix
        return [ [] for i in xrange(len(B)) ]
        


## main: run tests

if "__main__" == __name__:
    import doctest
    doctest.testmod(name="homology",
                    optionflags=doctest.NORMALIZE_WHITESPACE)
