#! /usr/bin/env python
#
"""Classes for computing graph homology.
"""
__docformat__ = 'reStructuredText'


from homology import *
from rg import ConnectedGraphsIterator
from valences import vertex_valences_for_given_g_and_n


def FatgraphComplex(g, n):
    """Return the fatgraph complex for given genus `g` and number of
    boundary components `n`.

    This is a factory method returning a `homology.ChainComplex`
    instance, populated with the correct vector spaces and
    differentials to compute the graph homology of the space
    `M_{g,n}`.
    """
    ## Minimum number of edges is attained when there's only one
    ## vertex; so, by Euler's formula `V - E + n = 2 - 2*g`, we get:
    ## `E = 2*g + n - 1`.
    min_edges = 2*g + n - 1
    ## Maximum number of edges is reached in graphs with all vertices
    ## tri-valent, so, combining Euler's formula with `3*V = 2*E`, we
    ## get: `E = 6*g + 3*n - 6`.  Since the differential is given by
    ## contraction of edges, we get a total length for the fatgraph
    ## complex of: `4*g +2*n - 5`.
    length = 4*g + 2*n - 4  #: total length of the fatgraph complex

    #: list of primitive graphs, graded by number of edges
    generators = [ [] for dummy in xrange(length) ]

    #: list of alias dictionaries, graded by number of edges
    aliases = [ {} for dummy in xrange(length) ]

    # gather graphs
    for val in vertex_valences_for_given_g_and_n(g, n):
        grade = sum(val)/2 - min_edges
        for graph in ConnectedGraphsIterator(val):
            if isinstance(graph, tuple):
                # add alias to dictionary
                aliases[grade][graph[0]] = graph[1]
            else:
                # primitive graph, add if correct `g` and `n`
                if (graph.genus() == g) and \
                       (graph.num_boundary_components() == n):
                    generators[grade].append(graph)

    # build chain complex
    C = ChainComplex(length)
    for i in xrange(length):
        # set support module and differential
        C[i] = (FatgraphComplexSlice(generators[i], aliases[i]),
                graph_homology_differential)
    return C


def sign1(l):
    if l % 2 == 0:
        return +1
    else:
        return -1
    
def graph_homology_differential(graph):
    """The graph homology differential (the same for every grade).

    Return a linear combination (with alternating signs) of
    contractions of all non-loop edges of the given graph.
    """
    result = []
    for l in xrange(graph.num_edges()):
        if not graph.is_loop(l):
            g = graph.contract(l)
            if not g.has_orientation_reversing_automorphism():
                result.append((g, sign1(l)))
    return result
        

class FatgraphComplexSlice(VectorSpace):
    """Return vector space generated by a given set of fatgraphs.

    This is different from the base `VectorSpace` class in that the
    `coordinates` method will detect different presentations of the
    same fatgraph.
    """
    def __init__(self, graphs, aliases=None):
        """Constructor, taking generating graphs and optional aliases dict."""
        if aliases is None:
            self.aliases = {}
        else:
            self.aliases = aliases
        VectorSpace.__init__(self,
                             [ g for g in graphs
                               if not g.has_orientation_reversing_automorphism()
                               ])

    def coordinates(self, combo):
        """Return coordinate vector of linear combination `combo`."""
        coordinates = [0] * self.dimension

        # canonicalize graphs
        for (i, (g, coeff)) in enumerate(combo):
            if g not in self.base:
                canonical = None
                if g.edge_seq in self.aliases:
                    # replace g with canonical
                    canonical = self.aliases[g.edge_seq]
                else:
                    # try to determine which graph of base `g` is
                    # isomorphic to.
                    for gg in self.base:
                        if g == gg:
                            canonical = gg
                            break
                if canonical:
                    combo[i][0] = canonical
                else:
                    raise ValueError, \
                          "Cannot find canonical representative for graph %s" \
                          % repr(g)

        # call method from superclass
        return VectorSpace.coordinates(self, combo)
                        
        


## main: run tests

if "__main__" == __name__:
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
