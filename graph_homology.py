#! /usr/bin/env python
#
"""Classes for computing graph homology.
"""
__docformat__ = 'reStructuredText'


from homology import *
from rg import ConnectedGraphsIterator
from valences import vertex_valences_for_given_g_and_n


def FatgraphComplex(g, n):
    """Return the fatgraph complex for given genus `g` and number of
    boundary components `n`.

    This is a factory method returning a `homology.ChainComplex`
    instance, populated with the correct vector spaces and
    differentials to compute the graph homology of the space
    `M_{g,n}`.
    """
    ## Minimum number of edges is attained when there's only one
    ## vertex; so, by Euler's formula `V - E + n = 2 - 2*g`, we get:
    ## `E = 2*g + n - 1`.
    min_edges = 2*g + n - 1
    ## Maximum number of edges is reached in graphs with all vertices
    ## tri-valent, so, combining Euler's formula with `3*V = 2*E`, we
    ## get: `E = 6*g + 3*n - 6`.  These are also graphs corresponding
    ## to top-dimensional cells.
    top_dimension = 6*g + 3*n - 6

    #: list of primitive graphs, graded by number of edges
    generators = [ [] for dummy in xrange(top_dimension) ]

    # gather graphs
    for val in vertex_valences_for_given_g_and_n(g, n):
        grade = sum(val)/2 - 1
        for graph in ConnectedGraphsIterator(val):
            # add if correct `g` and `n`
            if (graph.genus() == g) and \
                   (graph.num_boundary_components() == n):
                generators[grade].append(graph)

    # build chain complex
    C = ChainComplex(top_dimension)
    for i in xrange(top_dimension):
        # set support module and differential
        C[i] = (FatgraphComplexSlice(generators[i]),
                graph_homology_differential)
    return C


def sign1(l):
    if l % 2 == 0:
        return +1
    else:
        return -1
    
def graph_homology_differential(graph):
    """The graph homology differential (the same for every grade).

    Return a linear combination (with alternating signs) of
    contractions of all non-loop edges of the given graph.
    """
    result = []
    for l in xrange(graph.num_edges):
        if not graph.is_loop(l):
            dg = graph.contract(l)
            if dg.is_oriented():
                result.append((dg, sign1(l)))
    return result
        

class FatgraphComplexSlice(VectorSpace):
    """Return vector space generated by a given set of fatgraphs.

    This is different from the base `VectorSpace` class in that the
    `coordinates` method will detect different presentations of the
    same fatgraph.
    """
    def __init__(self, graphs):
        """Constructor, taking generating graphs."""
        base = []
        self.base_aliases = {}
        for graph in graphs:
            if graph.is_oriented():
                base.append(graph)
                for edge_seq in graph.edge_seq_aliases:
                    self.base_aliases[edge_seq] = graph
            # non-orientable graphs are silently discarded
        VectorSpace.__init__(self, base)

    def coordinates(self, combo):
        """Return coordinate vector of linear combination `combo`."""
        coordinates = [0] * self.dimension

        # canonicalize graphs
        for monomial in combo:
            graph = monomial[0]
            if graph not in self.base:
                canonical = None
                if graph.edge_seq in self.base_aliases:
                    # replace graph with canonical
                    canonical = self.base_aliases[graph.edge_seq]
                else:
                    # try to determine which element in base `graph`
                    # is isomorphic to.
                    for gg in self.base:
                        if graph == gg:
                            canonical = gg
                            break
                if canonical:
                    # by modifying `monomial`, the object in the
                    # `combo` list is modified, because `monomial` is
                    # a reference.
                    monomial[0] = canonical
                    monomial[1] *= graph.projection(canonical)
                else:
                    raise ValueError, \
                          "Cannot find canonical representative for graph %s" \
                          % repr(graph)

        # call method from superclass
        return VectorSpace.coordinates(self, combo)
                        
        


## main: run tests

if "__main__" == __name__:
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
