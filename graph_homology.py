#! /usr/bin/env python
#
"""Classes for computing graph homology.
"""
__docformat__ = 'reStructuredText'


## logging subsystem

import logging


## application-local imports

from homology import *
from rg import MgnGraphsIterator, Graph, Vertex
from valences import vertex_valences_for_given_g_and_n


def FatgraphComplex(g, n):
    """Return the fatgraph complex for given genus `g` and number of
    boundary components `n`.

    This is a factory method returning a `homology.ChainComplex`
    instance, populated with the correct vector spaces and
    differentials to compute the graph homology of the space
    `M_{g,n}`.
    """
    ## Minimum number of edges is attained when there's only one
    ## vertex; so, by Euler's formula `V - E + n = 2 - 2*g`, we get:
    ## `E = 2*g + n - 1`.
    min_edges = 2*g + n - 1
    logging.info("Minimum number of edges: %d", min_edges)
    
    ## Maximum number of edges is reached in graphs with all vertices
    ## tri-valent, so, combining Euler's formula with `3*V = 2*E`, we
    ## get: `E = 6*g + 3*n - 6`.  These are also graphs corresponding
    ## to top-dimensional cells.
    top_dimension = 6*g + 3*n - 6
    logging.info("Maximum number of edges: %d", top_dimension)

    #: list of primitive graphs, graded by number of edges
    generators = [ [] for dummy in xrange(top_dimension) ]

    # gather graphs
    _grade = None
    for graph in MgnGraphsIterator(g,n):
        if not graph.is_oriented():
            continue
        grade = graph.num_edges - 1
        generators[grade].append(graph)

        # since `MgnGraphsIterator` returns graphs in blocks with
        # equal number of edges, we can use that for logging purposes
        # and provide a simple-minded progress report
        if grade != _grade:
            logging.info("Now generating %d-edge graphs ...", grade)
            _grade = grade
        
    # build chain complex
    C = ChainComplex(top_dimension)
    for i in xrange(top_dimension):
        # set support module and differential
        C[i] = (FatgraphComplexSlice(generators[i]),
                graph_homology_differential)
        logging.info("Initialized grade %d chain module (with dimension %d)",
                     i, len(generators[i]))
    return C


def sign_exp(m):
    if (m % 2) == 0:
        return +1
    else:
        return -1
    
def graph_homology_differential(graph):
    """The graph homology differential (the same for every grade).

    Return a linear combination (with alternating signs) of
    contractions of all non-loop edges of the given graph.
    """
    result = []
    for l in xrange(graph.num_edges):
        if not graph.is_loop(l):
            dg = graph.contract(l)
            assert dg.numbering is not None, \
                   "graph_homology_differential: "\
                   " contraction of graph `%s` by edge %d yields"\
                   " un-numbered graph `%s`."\
                   % (graph, l, dg)
            if dg.is_oriented():
                result.append((dg, sign_exp(graph.edge_numbering[l])))
    return result
        

class FatgraphComplexSlice(VectorSpace):
    """Return vector space generated by a given set of fatgraphs.

    This is different from the base `VectorSpace` class in that the
    `coordinates` method will detect different presentations of the
    same fatgraph.
    """
    
    if __debug__:
        def __init__(self, base):
            for (i, graph) in enumerate(base):
                assert graph.numbering is not None, \
                       "FatgraphComplexSlice.__init__:"\
                       " initialized with non-numbered graph `%s`" \
                       " (at position %d)" \
                       % (graph, i)
            VectorSpace.__init__(self, base)
                
    def coordinates(self, combo):
        """Return coordinate vector of linear combination `combo`."""
        # canonicalize graphs
        for x in xrange(len(combo)):
            graph = combo[x][0]

            # try to determine which element in base `graph`
            # is isomorphic to.
            try:
                canonical = self.base[self.base.index(graph)]
                assert canonical == graph and graph == canonical
            except ValueError:
                raise ValueError, \
                      "Cannot find canonical representative for graph `%s`." \
                      % (repr(graph),)

            # alter the `combo` list in-place
            combo[x] = (canonical, combo[x][1] * graph.projection(canonical))

        # call method from superclass
        return VectorSpace.coordinates(self, combo)
        


## main: run tests

if "__main__" == __name__:
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
