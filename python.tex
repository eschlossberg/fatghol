\chapter{Python language syntax}
\label{chap:python}

\lstset{numbers=none}%

This chapter features a short introduction to the syntax of the
programming language Python, and an explanation of the commonly-used
constructs and idioms that may appear obscure.  This is by no means a
complete overview of the syntax, nor a formal definition of Python;
the \href{http://docs.python.org/3.1/}{official Python documentation}
\cite{python:docs, python:reference} should be consulted for this
purpose.

According to the
\href{http://en.wikipedia.org/wiki/Python_(programming_language)}
{Wikipedia article on Python} \cite{wikipedia:python}, ``Python is a
general-purpose high-level programming language. Its design philosophy
emphasizes code readability. Python claims to `[combine] remarkable
power with very clear syntax'. It has a relatively uncluttered visual
layout, uses English keywords frequently where other languages use
punctuation, and has notably fewer syntactic constructions than other
popular structured languages''.


\section{Basics of Python language syntax}
\label{sec:syntax}

Python is an \emph{imperative} programming language, meaning that
every Python program is a sequence of statements to be executed by the
computer.  Each statement must fit into a \emph{logical line}; a
logical line is the shortest sequence of consecutive display lines
such that all parentheses are balanced.  In other words, a statement
ends at the first newline character such that for every occurrence of
`"("', `"["', or `"{"' there is a matching occurence of the
corresponding closing symbol.
\begin{lstlisting}
# single-line statement
print (21*2)

# the following statement is automatically continued
# until the end-of-line following the last closing parenthesis
u = (1 + 4*x[2] 
       + 2*y[1 + n[42]]
       + z)
\end{lstlisting}
As one can see from the example above, the Python interpreter ignores
any character following `"#"' until the end of the line.  This
syntax is used to add explicative comments to the Python source code.

The Python interpreter completely ignores comments and blank lines
while reading a source file; that is, a Python program will have
\emph{exactly} the same behavior if all the comments and blank lines
are removed.

\subsection{Variables}
\label{sec:variables}

A variable name is \emph{bound} by assigning a value to it: e.g.,
"a=42".  Variables in Python are \emph{untyped}, that is, any
variable can hold an object of any type: "a=42" and "a=list()"
are both valid assignments. Variables in Python are also
\emph{mutable}, meaning that a single variable may be assigned a
different value several times over, within the same block of code.
For instance:
\begin{lstlisting}
a = 42 # an integer value

a = "a character string"

a = 3.1415926 # a floating-point number
\end{lstlisting}

Multiple variables can be assigned at once, if the right-hand side is
a list or tuple (see Section~\ref{sec:lists} and~\ref{sec:tuples}). For
example, the following code:
\begin{codexmp}
  a, b, c = [1, 2, 3]
\end{codexmp}
would set the variable "a" to the value "1", "b" to "2" and "c" to
"3".

If the number of variables being assigned is different from the number
of elements contained in the list or tuple, then a run-time error
occurs.


\subsection{Program blocks}
\label{sec:blocks}

A distinctive feature of Python is its use of whitespace to delimit
program blocks:\footnote{Note: the use of the word ``block'' here is
  not consistent with the meaning it is given in the Python Language
  Reference \cite{python:reference}.}  Python mandates that statements
belonging in the same sequence are aligned with the same amount of
whitespace from column 0 (the leftmost one on the display).  The
indentation must increase in the block after a flow-control statement
or function definition.\footnote{Python syntax also mandates that a
  colon \q{:} is the last non-whitespace character before a new block
  begins, so an effective rule of thumb is: if a line ends with a
  colon, the following one must increase indentation.}  A block ends
upon encountering a statement with a lesser indentation level (i.e.,
beginning closer to column 0).

For example, consider the following simple code:
\begin{lstlisting}
for x in range(10):
    # compute the square of x
    y = x*x
    # print it
    print(y)
# the following statement dedents, thus ending
# the body block of the "for" loop.
print("All done.")
\end{lstlisting}
The assignment to variable "y" and the "print" statement belong in the
same code block (the body of the "for" cycle), therefore both are
indented w.r.t. the enclosing "for" and begin in column 4.  The "for"
and the last "print" statement belong in the same sequence and
therefore start at column 0.


\section{Control flow constructs}
\label{sec:control-flow}

Python supports the usual control flow constructs
"if"/"else", "for", "while".

The "if"/"else" statements are used to select which of two
blocks of code will be executed.  The "else" part is optional and
can be omitted.  Cascaded "if"/"else" occurrences (to
select the execution of a particular block of instructions) are best
written using the "elif" keyword as a shorthand for 
`"else: if:"'. 

The "while" statement repeatedly executes the ensuing code block;
the expression specified after the "while" keyword is evaluated
at the beginning of each execution cycle, if the result is boolean
"False", then execution of the code block is aborted and the program
flows continues after the block following the "while" statement.
Therefore, if an expression evaluates to false at the first entrance
in the "while" block, the block is never executed.

The "for" statement repeatedly executes the ensuing code block,
each time binding the specified variables to a new value of the
sequence following the "in" keyword.
\begin{lstlisting}
for x in range(10):
  print(x)
\end{lstlisting}
The "range" function is provided as a convenience to specify
numerical integer sequences; by Python convention, the range is always
half-open: "range(10)" is the sequence of natural numbers $\{0,
1, \ldots, 9\}$.  More formally, we have:
\begin{align*}
  \text{\ttfamily range($n$,$m$)} &:= \{ x \in \setN : n \leq x < m \},
  \\
  \text{\ttfamily range($n$)} &:= \text{\ttfamily range(0,$n$)}
\end{align*}

A `"for"' loop can bind several variable at once, using the same syntax
and convention for multiple-variable assignements: each of the
iteration items must be a list or tuple, and the number of elements in
the list/tuple must match the number of variables being assigned.

The "enumerate" function iterates over the items in a container (see
below), returning ---for each item in the container--- a pair (Python
"tuple") formed by the item itself and the iteration index (starting
at 0).  The index comes first in the pair.  This is used in
conjunction with `"for"' loops:
\begin{lstlisting}
for index, item in enumerate(container):
  # "index" takes up values 0, 1, ...
  # "item" takes up values of objects stored in "container"
  print("Object "+item+" is at position "+index)
\end{lstlisting}
Assuming "container" is a list comprising the items "'a'", "'b'",
"'c'", the "print" statement in the `"for"' loop above would be
executed first with "index" bound to 0 and "item" bound to "'a'", then
"index" bound to 1 and "item" bound to "'b'", and finally with "index"
bound to "2" and "item" bound to "'c'".



\section{Functions}
\label{sec:functions}

A Python function is a block of code dependent on a specified list of
named parameters.  A function is invoked by giving actual values to
the parameters; upon termination, functions return a value to their
caller.  The list of formal parameters of a function is called the
function's signature.

Python functions are defined using the "def" keyword; it must be
followed by the function name and a parenthesized list of parameters:
\begin{lstlisting}
def binomial(n, k):
  return factorial(n) / (factorial(k) * factorial(n-k))
\end{lstlisting}
A function is invoked by giving actual values to the parameters:
\begin{lstlisting}
x = binomial(4, 2)
print(x) # outputs `6'
\end{lstlisting}

Some of the parameters in a function can be given a default value, as
in the following example:
\begin{lstlisting}
def binomial(n, k=1):
  return factorial(n) / (factorial(k) * factorial(n-k))
\end{lstlisting}
Parameters with default values can be omitted from function
invocation; they will be given the default value declared in the
function definition:
\begin{lstlisting}
x = binomial(4) # == binomial(4, 1)
print(x) # outputs `4'
\end{lstlisting}

\subsection{Keyword arguments}
\label{sec:kwargs}

A function can be called also by explicitly naming the formal
parameters: e.g., as in "binomial(n=4,k=2)".  When all formal
parameters are named in the function invocation, their order does not
matter: i.e., "binomial(k=2,n=4)" and "binomial(n=4,k=2)" yield the
same result.  The names of the parameters must match those used in the
function definition.

It is possible for a function to accept \emph{keyword arguments},
i.e., formal parameters that have not been specified in the function
definition.  If the function signature ends with the special notation
"**kwargs", then during each execution of the function body, the
variable "kwargs" will be bound to a Python dictionary object (see
Section~\ref{sec:dicts}) mapping each parameter name to the actual value
used in function invocation.  For example, assume "f" is a function
defined this way:
\begin{codexmp}
  def f(x, **kwargs):
    print('x='+x)
    for k, v in kwargs:
      print(k+' is '+v)
\end{codexmp}
Then, calling "f(x=0,y=1,z=2)" would produce the three lines of
output `"x=0"', `"y is 1"', and `"z is 2"'.

\subsection{Dynamic list of arguments}
\label{sec:fn-special-syntax}

Python has a special syntax allowing function calls when the list of
arguments is only known at program run time. (This is especially
useful in conjunction with functions with a variable signature, which
are however not mentioned here as they have not been used in the main
code.)

When "x" is a "list" or "tuple" object (see Section~\ref{sec:lists} and
Section~\ref{sec:tuples}), the syntax "f(*x)" invokes function "f"
taking all its arguments from the list "x".  The number of items in
"x" must match the number of formal arguments required by "f".  For
example, if "x" is the list "[4, 2]", then "binomial(*x)" yields the
same effect as writing "binomial(4,2)".

\subsection{Documentation string}
\label{sec:docstring}

Immediately following the ``"def"'' clause in a function definition,
there can be a string for program documentation purposes. The
``docstring'' can be accessed at program run time and can also be
inspected from the Python interactive prompt.  The ``docstring'' can
span several lines, if triple quotes are used to delimit it.

The contents of the ``docstring'' are free-form, but it is good
practice to use it to describe the function purposes, its return value
(if any), its effects, and the type and meaning of the arguments.

\subsection{Doctests}
\label{sec:doctests}

Docstrings can contain the so-called ``doctests'', which are a text
recording of a function invocation and the expected return values.
The Python "doctest" module will parse the function  invocations
(lines prefixed with `">>>"') and compare their return value with the
one recorded in the doctest string; if the values don't match, an
error is signaled. 

\section{Objects and classes}
\label{sec:objects}

Every datum that Python handles is an \emph{object}.  Strictly
speaking, an object is an aggregate data structure, consisting of data
fields (called ``instance variables'' or ``attributes'') and functions
(called ``methods'').  For the limited purposes of this exposition, it
suffices to say that an object is a group of variables and functions.

If $x$ is an object and $v$ is a variable name, then $x$"."$v$ is
the Python syntax used to refer to the instance variable $v$ within
$x$. Variables belonging in different object instances are independent
and can store different values.

If $x$ is an object and $f$ is a function name, then
$x$"."$f$"("$\ldots$")" is said to ``invoke method $f$ on object $x$''
and is an alternate syntax for the function call $f$"("$x$","$\ldots$")".

\subsection{Classes}
\label{sec:classes}

The type of an object determines what instance variables and methods
it has initially.  The type of an object is called its ``class'';
equivalently, one says that object $x$ is an \emph{instance} of class
$X$.  Classes are defined with the "class" statement:
\begin{lstlisting}
class Complex(object):
  def __init__(self, real, imag):
    self.real = real
    self.imag = imag
  def norm(self):
    return math.sqrt(self.real**2 + self.imag**2)
\end{lstlisting}
The above code defines a class "Complex" with two instance variables
"real" and "imag", and two instance methods "__init__" and
"norm".  Within the class definition, the keyword "self" denotes
the actual object on which the method is invoked: namely, if $x$ and
$y$ are both instances of class "Complex", then $x$".norm()" and
$y$".norm()" both execute the same code, with the variable "self"
bound to $x$ in the first case and to $y$ in the second. 

An instance of a class is created by invoking the class name as a
function, e.g.:
\begin{lstlisting}
x = Complex(1.0, 1.0)
\end{lstlisting}
The "__init__" method is executed when creating an instance of a
class, with the "self" parameter bound to the newly-created object.
The number of parameters following the class name in instance creation
must match those defined in the "__init__" method.

\subsection{Inheritance}
\label{sec:inheritance}

A class can \emph{inherit} its methods from other classes (called the
\emph{superclasses}): assume $x$ is an instance of class $X$, and $Y$ is a
superclass of $X$ defining a method $f$, then $x$"."$f$"()" invokes the
method $f$ as defined in $Y$ with "self" bound to $x$ (unless $X$
also defines a method named $f$, which would be invoked instead).

The ``inherits from'' relation is a partial order on the set of all
classes; on the transitive closure of a class $X$ this restricts to a
tree structure, with $X$ at the root: each time a method $f$ is
invoked on an instance of $X$, a depth-first search is done on classes
in the inheritance tree to find the definition of method $f$.

For example, consider the following code:
\begin{lstlisting}
class Complex1(Complex):
  def unit_vector(self):
    return Complex1(self.real/self.norm(), 
                    self.imag/self.norm())

x = Complex1(2, 2)  # `x` is $2 + 2\I$
y = x.unit_vector() # `y` is $1/\sqrt{2} + 1/\sqrt{2}\I$
\end{lstlisting}
A class "Complex1" is defined, which inherits from class
"Complex"; object of class "Complex1" shall have a method
"unit_vector" defined in "Complex1", and  methods "norm" and
"__init__" defined in "Complex" (by inheritance).  Indeed, the
definition of "unit_vector" invokes "self.norm()".

\subsection{Special methods}
\label{sec:special-methods}

Python defines some special method names; these methods, when defined,
are invoked with Python's natural operator syntax: e.g., if $x$
defines a method "__add__", then $x + y$ results in the method call
$x$".__add__("$y$")".  The full list of special methods and their
meaning is only available in the Python Language Reference
\cite{python:reference}; the ones used in the listings of
Chapter~\ref{chap:algorithm} are:
\begin{basedescript}{
    \desclabelwidth{4em}
    \desclabelstyle{\nextlinelabel}
  }
\item[{\ttfamily \_\_eq\_\_}] Used for testing object equality; if $x$ implements
  "__eq__", then $x$"=="$y$ actually runs $x$".__eq__("$y$")".
\item[{\ttfamily \_\_getitem\_\_}] If $x$ has a method "__getitem__", then the
  look-up expression $x$"["$k$"]" is translated to the method call
  $x$".__getitem__("$k$")".
\item[{\ttfamily \_\_init\_\_}] Instance initialization, see Section~\ref{sec:classes}.
\item[{\ttfamily \_\_len\_\_}] Returns the length (number of elements) in a
  container.
\item[{\ttfamily \_\_ne\_\_}] The opposite of "__eq__" (which see); if
  $x$ implements "__ne__", then $x$"!="$y$ actually runs
  $x$".__ne__("$y$")"
\item[{\ttfamily \_\_new\_\_}] Instances of Python built-in objects
  (and subclasses thereof) are initialized in the "__new__" method
  before "__init__" is called.\footnote{There is actually much more to
  {\ttfamily \_\_new\_\_} than what is apparent from this description, but it
  suffices for the limited purposes here.}
\item[{\ttfamily \_\_repr\_\_}] Machine-readable printable representation of an
  object; returns a string, which should be a valid Python expression
  that yields a copy of the object when evaluated; called by
  "repr("$x$")".
\item[{\ttfamily \_\_str\_\_}] Human-readable printable representation of an
  object; returns a string describing the instance; called by
  "str("$x$")".
\end{basedescript}


\section{Containers}
\label{sec:containers}

In addition to the basic types (integers, floating-point numbers,
character strings), the Python language provides support for other
common data structures: lists, tuples ($t$-uples), dictionaries, and
sets.  These are collectively called \emph{container} types, as their
purpose is to store a collection of other objects.
There are two main operations supported by Python on standard
containers: \emph{iteration} and \emph{look-up}.

Iteration over a container is supported through the ``"for"'' loop
syntax:
\begin{lstlisting}
for item in container:
  # do something with item
  print(item)
\end{lstlisting}
The block of code following a ``"for ... in ...:"'' line will be
executed once for each item stored in the container; at each
iteration, the variable folliwing the `"for"' keyword will be bound to
a different object in the container.  Containers are said to be
\emph{ordered} or \emph{unordered}, depending whether iteration
returns the objects in the order they were added to the container
(lists, tuples) or not (dictionaries, sets).

Look-up returns the item stored at a particular position in the
container (in lists and tuples) or the one associated with a certain
\emph{key} (in dictionaries); sets do not support item look-up.  
Look-up is expressed by suffixing a container name with the index or key
within square brackets: if "L" is container name, and "p" is a
position, then L"["p"]" evaluates to the object stored in "L" at
position "p".

\subsection{Sets}
\label{sec:sets}

Python sets are an unordered collections of Python objects.  Sets are
\emph{mutable}: functions are available, to add and remove member objects to
a set, and to implement the most common set-theoretic operations.
Sets are defined by enclosing the list of member objects in braces
`\{' and `\}'; if an object is repeated several times in the list,
it will be stored only once in the "set" container:
\begin{lstlisting}
# define a set; duplicates will be removed
s1 = { 0, 1, "two", 1, 0 }

# same effect as the definition above
s2 = { 0, 1, "two" }
\end{lstlisting}
Python also allows defining sets with a syntax more similar to the
common mathematical writing:
\begin{lstlisting}
# define the set of the square numbers less than 100
s = { n*n for n in range(10) }

# same as above
s = set(n*n for n in range(10))
\end{lstlisting}
The general syntax of these expression (called ``set comprehensions''
in Python parlance) is:
\begin{lstlisting}
{ $f$ for $x$ in $X$ if $p$ }
\end{lstlisting}
where:
\begin{itemize}
\item[$x$] is any valid variable name;
\item[$X$] is any object that allows iteration (e.g., another
  set, a list, etc.);
\item[$f$] is any Python expression (i.e., a computation "x*x+1") 
  which can include $x$ as a free variable;
\item[$p$] is a Python expression that evaluates to a Boolean truth
  value ("True"/"False") and can include $x$ as a free variable.
\end{itemize}
The above Python set comprehension translates to the current
mathematics notation:
\begin{equation*}
  \{ f(x) : x \in X \text{ such that } p(x) \text{ is true} \}
\end{equation*}
The "if"-clause with the boolean expression can be omitted, in which
case it is assumed to be "True" for all $x \in X$.

Sets do not allow look-up of elements, but allow (unordered) iteration
over the set contents in a "for" loop:
\begin{lstlisting}
# define a set; duplicates will be removed
s = { 0, 1, "two", 1, 0 }

# iterate over the set contents: prints 0, 1, "two" 
# in some runtime-dependent order.
for item in s:
  print(item)
\end{lstlisting}

An \emph{immutable} variant "frozenset" is also provided;
"frozenset" instances share all properties of "set", but cannot be
modified once created: i.e., elements cannot be added or deleted from
a "frozenset".

                                                               
\subsection{Lists}
\label{sec:lists}

Python \emph{lists} store a sequence of values, and allow retrieving
each one by index-based look up.  Lists are like the ``arrays'' of
other programming languages, except that Python does not require all
values in a list to be of the same type.

List indices start at 0; negative indices denote elements from the end
of the list, so "l[-1]" is the last value in the list.  List
literals are delimited by a matching pair "[" and "]", and the
items within it must be separated by commas. For instance:
\begin{lstlisting}
# assign a list to the variable "l"
l = [1, 2, "three", 4.0]

# print the 3rd element -- indices start at 0
print l[2]
\end{lstlisting}
Lists can also be defined using a notation akin to the one used for
defining sets --- it is called \emph{list comprehensions}:
\begin{lstlisting}
# make a list of the first 10 square numbers
l1 = [ n*n for n in range(10) ]

# same as above, using a function-like constructor
l2 = list(n*n for n in range(10))
\end{lstlisting}

Lists are mutable objects: one can alter the values stored, append new
items or insert them in specified places, and delete portions of an
existing list.
\begin{lstlisting}
# alter a stored value, in-place
l[0] = "zero"

# append one item to a list
l.append(5)

# append another list
l.extend(["six", 7])

# insert a new value "1.5" between elements at position 0 and 1
l.insert(1, 1.5)

# delete the first 3 elements
del l[0:2]
\end{lstlisting}
It is possible to extract (and delete) \emph{slices} of a list, that is,
all items in a list associated with a range of consecutive indices.
The syntax is an extension of the index-based lookup: a slice is
denoted by the starting and ending index, separated by a colon
character `":"' and enclosed by square brackets: the slice spans the
half-open interval $[\text{start index}, \text{end index})$.
\begin{lstlisting}
# create a list
l1 = [0, 1, 2, 3, 4, 5, 6]

# extract the first three elements
l2 = l1[0:3]
print l2

# now remove the slice "l2" from "l1"
del l1[0:3]
print l1
\end{lstlisting}


\subsection{Tuples}
\label{sec:tuples}

Python \emph{tuples} are exactly like lists: they allow an array of
different objects to be stored; tuples allow index-based lookup and
slicing. But tuples are \emph{immutable}, so items cannot be
appended, inserted or deleted from a tuple.

Tuples can also be constructed using the comprehension syntax, but
only using the function-like syntax:
\begin{lstlisting}
# define a tuple of even numbers < 10
t = tuple(n for n in range(10) if (n % 2 == 0))
\end{lstlisting}


\subsection{Dictionaries}
\label{sec:dicts}

Python dictionaries implement a general (finite) mapping: they
associate an object with an (arbitrary) value.  Elements in the
mapping domain are called dictionary \emph{keys}; objects in the
codomain are called dictionary \emph{values}.  Python objects used as
keys must be immutable; this is one reason for having distinct mutable
and immutable versions of standard containers.

The Python syntax for working with dictionaries is akin to the syntax used
for manipulating lists, the only difference being that dictionaries
are constructed by enclosing key":"value pairs in braces:
\begin{lstlisting}
# define a dictionary
f = { "zero":0, "one":1, "two":2, "three":3 }
\end{lstlisting}
A dictionary can also be defined using the comprehension syntax,
akin to sets, but the defining expression must have the form
$k$":"$v$ where $v$ is the value to be associated to key $k$:
\begin{lstlisting}
# map each integer < 10 to its square
f = { n:(n*n) for n in range(10) }

# same as above, with a function-like constructor
f = dict(n:(n*n) for n in range(10))
\end{lstlisting}

Dictionaries support look-up using a syntax akin to the one used for
lists, but the look-up key can be any valid Python object:
\begin{lstlisting}
# lookup an element by key
print (f["one"])
\end{lstlisting}
Looking up a key which is not in the dictionary domain raises an
exception of type "KeyError".

Dictionaries are \emph{mutable} objects, new mappings can be added or
old ones can be replaced:
\begin{lstlisting}
# add a new mapping: "four" $\mapsto$ 4
f["four"] = 4

# ...change it... 
f["four"] = 4.0

# ...and delete it!
del f["four"]
\end{lstlisting}

Dictionary objects support iteration over keys, values, and over (key,
value) pairs:
\begin{lstlisting}
# iterate over dictionary keys
for k in f.iterkeys(): 
    print("dictionary key: ", k)

# iterate over dictionary values
for v in f.itervalues(): 
    print("dictionary value: ", v)

# iterate over (key, value) pairs
for (k, v) in f.iteritems(): 
    print("key ", k, "has value", v)
\end{lstlisting}
Using the comprehension syntax and iteration, it is easy to invert a
mapping:
\begin{lstlisting}
# define `g` as the inverse of `f`
g = { v:k for (k, v) in f.iteritems() }
\end{lstlisting}


\section[Exception handling]{Exception handling: \q{try}/\q{except}/\q{finally} statements}
\label{sec:try-except-finally}

Exceptions are a language runtime construct to abort current function
execution, usually to signal an error.  If a block of Python code
cannot perform its function, it would \emph{raise} an exception:
current execution is aborted and control is returned to the calling
function.  This is searched for an \emph{exception handler}; if none
is found, the process continues recursively, inspecting the calling
function's caller for an exception handler.  If no exception handler
could be found across the whole call stack, the Python program aborts
execution.

The "try"/"except"/"finally" statements
are used to define exception handlers for a block of code.  The code
block following the "try" statement is executed; if it
raises an exception, then each "except" clauses immediately
following is inspected: if the type of the exception being raised
matches the type specified in the "except" clause, then the
code block following "except" is executed. The code block
following an "except" statement can raise a new exception
(or re-raise the one it caught); if no exception is raised, execution
continues with the statement that follows the
"try"/"except".  The code block following
"finally" is \emph{always} excuted before control leaves the
"try"/"except" clauses (in either way, that is,
after a "try"/"except" block completed with no
errors, or before returning control to the caller function because
another exception has been raised).

In the following example, the "a[42]" value lookup may
raise an exception of type "KeyError"; if this happens,
code in the "except" block will assign a default value to
"b".
\begin{lstlisting}
try:
    b = a[42]
except KeyError:
    # `a` has no value in the "42" position; 
    # assign a default value to `b`
    b = 0

# execution continues here
print(b)
\end{lstlisting}
                     

\subsection{The {\l pass} statement}
\label{sec:pass}

Python syntax does not allow to specify an empty block of code. There
is thus a special "pass" statement that performs no
computational operation, and is used to define ``no-op'' blocks.

The main use of "pass" is in combination with an
"except" statement, to ignore a particular error condition:
\begin{lstlisting}
try:
  print (a[42])
except KeyError:
  pass # ignore error if `a` has no item "42"
\end{lstlisting}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 

% LocalWords:  boolean
