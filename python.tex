\chapter{Python language syntax}
\label{chap:python}

\lstset{numbers=none}%

This chapter features a short introduction to the syntax of the
programming language Python, and an explanation of the commonly-used
constructs and idioms that may appear obscure.  This is by no means a
complete overview of the syntax, nor a formal definition of Python;
the \href{http://docs.python.org/3.1/}{official Python documentation}
\cite{python:docs, python:reference} should be consulted for this
purpose.

According to the
\href{http://en.wikipedia.org/wiki/Python_(programming_language)}
{Wikipedia article on Python} \cite{wikipedia:python}, ``Python is a
general-purpose high-level programming language. Its design philosophy
emphasizes code readability. Python claims to `[combine] remarkable
power with very clear syntax'. It has a relatively uncluttered visual
layout, uses English keywords frequently where other languages use
punctuation, and has notably fewer syntactic constructions than other
popular structured languages''.


\section{Basics of Python language syntax}
\label{sec:syntax}

Python is an \emph{imperative} programming language, meaning that
every Python program is a sequence of statements to be executed by the
computer.  Each statement must fit into a \emph{logical line}; a
logical line is the sortest sequence of consecutive display lines such
that all parentheses are balanced.  In other words, a statement ends
at the first newline character such that for every occurrence of
`"("', `"["', or `"{"' there is a matching occurence of
  the corresponding closing symbol.
\begin{lstlisting}
# single-line statement
print (21*2)

# the following statement is automatically continued
# until the newline following the last closing parenthesis
u = (1 + 4*x[2] 
       + 2*y[1 + n[42]]
       + z)
\end{lstlisting}
As one can see from the example above, the Python interpreter ignores
any character following `"#"' until the end of the line.  This
syntax is used to add explicative comments to the Python source code.
The Python interpreter completely ignores comments and blank lines
while reading a source file; that is, a Python program will have
\emph{exactly} the same behavior if all the comments and blank lines
are removed.

\subsection{Variables}
\label{sec:variables}

A variable name is \emph{bound} by assigning a value to it: e.g.,
"a=42".  Variables in Python are \emph{untyped}, that is, any
variable can hold an object of any type: "a=42" and "a=list()"
are both valid assignments. Variables in Python are also
\emph{mutable}, meaning that a single variable may be assigned a
different value several times over, within the same block of code.
For instance:
\begin{lstlisting}
a = 42 # an integer value
print(a)

a = "a character string"
print(a)

a = 3.1415926 # a floating-point number
print(a)
\end{lstlisting}


\subsection{Program blocks}
\label{sec:blocks}

A distinctive feature of Python is its use of whitespace to delimit
program blocks:\footnote{Note: the use of the word ``block'' here is
  not consistent with the meaning it is given in the Python Language
  Reference \cite{python:reference}.}  
Python mandates that statements belonging in the same sequence are
aligned with the same amount of whitespace from column 0 (the leftmost
one on the display).  The indentation must increase in the block after
a flow-control or function definition.\footnote{Python syntax also
  mandates that a colon \l{:} is the last non-whitespace character
  before a new block begins, so an effective rule of thumb is: if a
  line ends with a colon, the following one must increase
  indentation.}  A block ends upon encountering a statement with a
lesser indentation level (i.e., beginning closer to column 0).

For example, consider the following simple code:
\begin{lstlisting}
for x in range(10):
    # compute the square of x
    y = x*x
    # print it
    print y
# the following statement dedents, thus ending
# the body block of the "for" loop.
print "All done."
\end{lstlisting}
The assignment to variable "y" and the "print"
statement belong in the same code block (they body of the
"for" cycle), therefore both begin in column 2.  The
"for" and the last "print" statement belong in
the same sequence and therefore start at column 0. 


\section{Functions}
\label{sec:functions}

A Python function is a block of code dependent on a specified list of
named parameters.  A function is invoked by giving actual values to
the parameters; upon termination, functions return a value to their
caller. 

Python functions are defined using the "def" keyword; it must be
followed by the function name and a parenthesized list of parameters:
\begin{lstlisting}
def binomial(n, k):
  return factorial(n) / (factorial(k) * factorial(n-k))
\end{lstlisting}
A function is invoked by giving actual values to the parameters:
\begin{lstlisting}
x = binomial(4, 2)
print(x) # outputs `6'
\end{lstlisting}

Some of the parameters in a function can be given a default value, as
in the following example:
\begin{lstlisting}
def binomial(n, k=1):
  return factorial(n) / (factorial(k) * factorial(n-k))
\end{lstlisting}
Parameters with default values can be omitted from function
invocation; they will be given the default value declared in the
function definition:
\begin{lstlisting}
x = binomial(4) # == binomial(4, 1)
print(x) # outputs `4'
\end{lstlisting}


\section{Objects and classes}
\label{sec:objects}

Every datum that Python handles is an \emph{object}.  Strictly
speaking, an object is an aggregate data structure, consisting of data
fields (called ``instance variables'') and functions (called
``methods''); for the limited purposes of this exposition, it suffices
to say that an object is a group of variables and functions.

If $x$ is an object and $v$ is a variable name, then "$x$.$v$" is
the Python syntax used to refer to the instance variable $v$ within
$x$. Variables belonging in different object instances are independent
and can store different values.

If $x$ is an object and $f$ is a function name, then
"$x$.$f$($...$)" is said to ``invoke method $f$ on object $x$''
and is an alternate syntax for the function call \l{$f$($x$, $...$)}.

\subsection{Classes}
\label{sec:classes}

The type of an object determines what instance variables and methods
it has initially.  The type of an object is called its ``class'';
equivalently, one says that object $x$ is an \emph{instance} of class
$X$.  Classes are defined with the "class" statement:
\begin{lstlisting}
class Complex(object):
  def __init__(self, real, imag):
    self.real = real
    self.imag = imag
  def norm(self):
    return math.sqrt(self.real**2 + self.imag**2)
\end{lstlisting}
The above code defines a class "Complex" with two instance variables
"real" and "imag", and two instance methods "__init__" and
"norm".  Within the class definition, the keyword "self" denotes
the actual object on which the method is invoked: namely, if $x$ and
$y$ are both instances of class "Complex", then "$x$.norm()" and
"$y$.norm()" both execute the same code, with the variable "self"
bound to $x$ in the first case and to $y$ in the second. 

An instance of a class is created by invoking the class name as a
function, e.g.:
\begin{lstlisting}
x = Complex(1.0, 1.0)
\end{lstlisting}
The "__init__" method is executed when creating an instance of a
class, with the "self" parameter bound to the newly-created object.
The number of parameters following the class name in instance creation
must match those defined in the "__init__" method.

\subsection{Inheritance}
\label{sec:inheritance}

A class can \emph{inherit} its methods from other classes (named the
\emph{superclasses}): assume $x$ is an instance of class $X$, and $Y$ is a
superclass of $X$ defining a method $f$ then "$x$.$f$()" invokes the
method $f$ as defined in $Y$ (with "self" bound to $x$), unless $X$
also defines a method named $f$ (which would be invoked instead).

The ``inherits from'' relation is a partial order on the set of all
classes; on the transitive closure of a class $X$ this restricts to a
tree structure, with $X$ at the root: each time a method $f$ is
invoked on an instance of $X$, a depth-first search is done on classes
in the inheritance tree to find the definition of method $f$.

For example, consider the following code:
\begin{lstlisting}
class ComplexV(Complex):
  def unit_vector(self):
    return ComplexV(self.real/self.norm(), self.imag/self.norm())

x = ComplexV(2, 2)  # `x` is $2 + 2\I$
y = x.unit_vector() # `y` is $1/\sqrt{2} + 1/\sqrt{2}\I$
\end{lstlisting}
A class "ComplexV" is defined, which inherits from class
"Complex"; object of class "ComplexV" shall have a method
"unit_vector" defined in "ComplexV", and  methods "norm" and
"__init__" defined in "Complex" (by inheritance).  Indeed, the
definition of "unit_vector" invokes "self.norm()".

\subsection{Special methods}
\label{sec:special-methods}

Python defines some special method names; these methods, when defined,
are invoked with Python's natural operator syntax: e.g., if $x$
defines a method "__add__", then $x + y$ results in the method call
"$x$.__add__($y$)".  The full list of special methods and their
meaning is only available in the Python Language Reference
\cite{python:reference}; the ones used in the listings of
\csref{chap:algorithm} are:
\begin{itemize}
\item[{\ttfamily \_\_eq\_\_}] Used for testing object equality; if $x$ implements
  "__eq__", then \l{$x$ == $y$} actually runs "$x$.__eq__($y$)".
\item[{\ttfamily \_\_getitem\_\_}] If $x$ has a method "__getitem__", then the
  look-up expression \l{$x$[$k$]} is translated to the method call
  "$x$.__getitem__($k$)".
\item[{\ttfamily \_\_init\_\_}] Instance initialization, see \csref{sec:classes}.
\item[{\ttfamily \_\_len\_\_}] Returns the length (number of elements) in a
  container.
\item[{\ttfamily \_\_ne\_\_}] The opposite of "__eq__" (which see); if $x$
  implements "__ne__", then \l{$x$ != $y$} actually runs
  "$x$.__ne__($y$)"
\item[{\ttfamily \_\_repr\_\_}] Machine-readable printable representation of an
  object; returns a string, which should be a valid Python expression
  that yields a copy of the object when evaluated; called by
  "repr($x$)".
\item[{\ttfamily \_\_str\_\_}] Human-readable printable representation of an
  object; returns a string describing the instance; called by
  "str($x$)".
\end{itemize}


\section{Control flow constructs}
\label{sec:control-flow}

Python supports the usual control flow constructs
"if"/"else", "for", "while".

The "if"/"else" statements are used to select which of two
blocks of code will be executed.  The "else" part is optional and
can be omitted.  Cascaded "if"/"else" occurrences (to
select the execution of a particular block of instructions) are best
written using the "elif" keyword as a shorthand for 
`\verb"else: if:"'. 

The "while" statement repeatedly executes the ensuing code block;
the expression specified after the "while" keyword is evaluated
at the beginning of each execution cycle, if the result is boolean
false, then execution of the code block is aborted and the program
flows continues after the block following the "while" statement.
Therefore, if an expression evaluates to false at the first entrance
in the "while" block, the block is never executed.

The "for" statement repeatedly executes the ensuing code block,
each time binding the specified variables to a new value of the
sequence following the "in" keyword.
\begin{lstlisting}
for x in range(10):
  print(x)
\end{lstlisting}
The "range" function is provided as a convenience to specify
numerical integer sequences; by Python convention, the range is always
half-open: "range(10)" is the sequence of natural numbers $\{0,
1, \ldots, 9\}$.  More formally, we have:
\begin{align*}
  \text{\ttfamily range($n$,$m$)} &:= \{ x \in \setN : n \leq x < m \},
  \\
  \text{\ttfamily range($n$)} &:= \text{\ttfamily range(0,$n$)}
\end{align*}



\section{Containers}
\label{sec:containers}

In addition to the basic types (integers, floating-point numbers,
character strings), the Python language provides support for other
common data structures: lists, tuples ($t$-uples), dictionaries, and
sets.  These are collectively called \emph{container} types, as their
purpose is to store a collection of other objects.
There are two main operations supported by Python on standard
containers: \emph{iteration} and \emph{look-up}.

Iteration over a container is supported through the "for" loop
syntax:
\begin{lstlisting}
for item in container:
  # do something with item
  print(item)
\end{lstlisting}
The block of code following a \l{for ... in ...:} line will be
executed once for each item stored in the container; at each
iteration, the "for" variable will be bound to a different object in
the container.  Containers are said to be \emph{ordered} or
\emph{unordered}, depending whether iteration returns the objects in
the order they were added to the container (lists, tuples) or not
(dictionaries, sets).

Look-up returns the item stored at a particular position in the
container (in lists and tuples) or the one associated with a certain
\emph{key} (in dictionaries); sets do not support item look-up.  
Look-up is expressed by suffixing a container name with the index or key
within square brackets: if "L" is container name, and "p" is a
position, then \l{L[p]} represents the object stored in "L" at
position "p".

\subsection{Sets}
\label{sec:sets}

Python sets are an unordered collection of Python objects.  Sets are
\emph{mutable}: functions are available, to add and remove member objects to
a set, and to implement the most common set-theoretic operations.
Sets are defined by enclosing the list of member objects in braces
`\{' and `\}'; if an object is repeated several times in the list,
it will be stored only once in the "set" container:
\begin{lstlisting}
# define a set; duplicates will be removed
s1 = { 0, 1, "two", 1, 0 }

# same effect as the definition above
s2 = { 0, 1, "two" }
\end{lstlisting}
Python also allows defining sets with a syntax more similar to the
common mathematical writing:
\begin{lstlisting}
# define the set of the square numbers less than 100
s = { n*n for n in range(10) }

# same as above
s = set(n*n for n in range(10))
\end{lstlisting}
The general syntax of these expression (called ``set comprehensions''
in Python parlance) is:
\begin{lstlisting}
{ $f$ for $x$ in $X$ if $p$ }
\end{lstlisting}
where:
\begin{itemize}
\item[$x$] is any valid variable name;
\item[$X$] is any object that allows iteration (e.g., another
  set, a list, etc.);
\item[$f$] is any Python expression (i.e., a computation \l{n*n+1}) 
  that is only function of $x$;
\item[$p$] is a Python expression that evaluates to a
  Boolean truth value ("True"/"False") and only depends on $x$.
\end{itemize}
The above Python set comprehension translates to the current
mathematics notation:
\begin{equation*}
  \{ f(x) : x \in X \text{ such that } p(x) \text{ is true} \}
\end{equation*}
The "if"-clause with the boolean expression can be omitted, in which
case it is assumed to be "True" for all $x \in X$.

Sets do not allow look-up of elements, but allow iteration over the set
contents in a "for" loop:
\begin{lstlisting}
# define a set; duplicates will be removed
s = { 0, 1, "two", 1, 0 }

# iterate over the set contents
for item in s:
  print(item)
\end{lstlisting}

An \emph{immutable} variant "frozenset" is also provided;
"frozenset" instances cannot be modified once created.

                                                               
\subsection{Lists}
\label{sec:lists}

Python \emph{lists} store a sequence of values, and allow retrieving
each one by index-based look up.  Lists are like the ``arrays'' of
other programming languages, except that Python does not require all
values in a list to be of the same type.

List indices start at 0; negative indices denote elements from the end
of the list, so \l{l[-1]} is the last value in the list.  List
literals are delimited by a matching pair \l{[} and \l{]}, and the
items within must be separated by commas. For instance:
\begin{lstlisting}
# assign a list to the variable "l"
l = [1, 2, "three", 4.0]

# print the 3rd element -- indices start at 0
print l[2]
\end{lstlisting}
Lists can also be defined using a notation akin to the one used for
defining sets --- it is called \emph{list comprehensions}:
\begin{lstlisting}
# make a list of the first 10 square numbers
l1 = [ n*n for n in range(10) ]

# same as above, using a function-like constructor
l2 = list(n*n for n in range(10))
\end{lstlisting}

Lists are mutable objects: one can alter the values stored, append new
items or insert them in specified places, and delete portions of an
existing list.
\begin{lstlisting}
# alter a stored value, in-place
l[0] = "zero"

# append one item to a list
l.append(5)

# append another list
l.extend(["six", 7])

# insert a new value "1.5" between elements at position 1 and 2
l.insert(1, 1.5)

# delete the first 3 elements
del l[0:2]
\end{lstlisting}
It is possible to extract (and delete) \emph{slices} of a list, that is,
all items in a list associated with a range of consecutive indices.
The syntax is an extension of the index-based lookup: a slice is
denoted by the starting and ending index, separated by a colon
character \l{:} and enclosed by square brackets: the slice spans the
half-open interval $[\text{start index}, \text{end index})$.
\begin{lstlisting}
# create a list
l1 = [0, 1, 2, 3, 4, 5, 6]

# extract the first three elements
l2 = l1[0:3]
print l2

# now remove the slice "l2" from "l1"
del l1[0:3]
print l1
\end{lstlisting}


\subsection{Tuples}
\label{sec:tuples}

Python \emph{tuples} are exactly like lists: they allow an array of
different objects to be stored; tuples allow index-based lookup and
slicing. But, tuples are \emph{immutable}, so items cannot be
appended, inserted or deleted from a tuple.

Tuples can also be constructed using the comprehension syntax, but
only using the function-like syntax:
\begin{lstlisting}
# define a tuple of even numbers < 10
t = tuple(n for n in range(10) if (n % 2 == 0))
\end{lstlisting}


\subsection{Dictionaries}
\label{sec:dicts}

Python dictionaries implement a general (finite) mapping: they
associate an object with an (arbitrary) value.  Elements in the
mapping domain are called dictionary \emph{keys}; objects in the
codomain are called dictionary \emph{values}.  Python objects used as
keys must be immutable; this is one reason for having distinct mutable
and immutable versions of standard containers.

Python syntax for working with dictionaries is akin to the syntax used
for manipulating lists, the only difference being that dictionaries
are constructed by enclosing \l{key:value} pairs in braces:
\begin{lstlisting}
# define a dictionary
f = { "zero":0, "one":1, "two":2, "three":3 }
\end{lstlisting}
A dictionary can also be defined using the comprehension syntax,
akin to sets, but the defining expression must have the form
\l{$k$:$v$} where $v$ is the value to be associated to key $k$:
\begin{lstlisting}
# map each integer < 10 to its square
f = { n:(n*n) for n in range(10) }

# same as above, with a function-like constructor
f = dict(n:(n*n) for n in range(10))
\end{lstlisting}

Dictionaries support look-up using a syntax akin to the one used for
lists, but the look-up key can be any valid Python object:
\begin{lstlisting}
# lookup an element by key
print (f["one"])
\end{lstlisting}
Looking up a key which is not in the dictionary domain raises an
exception of type "KeyError".

Dictionaries are \emph{mutable} objects, new mappings can be added or
old ones can be replaced:
\begin{lstlisting}
# add a new mapping: "four" $\mapsto$ 4
f["four"] = 4

# ...change it... 
f["four"] = 4.0

# ...and delete it!
del f["four"]
\end{lstlisting}

Dictionary objects support iteration over keys, values, and over (key,
value) pairs:
\begin{lstlisting}
# iterate over dictionary keys
for k in f.iterkeys(): 
    print("dictionary key: ", k)

# iterate over dictionary values
for v in f.itervalues(): 
    print("dictionary value: ", v)

# iterate over (key, value) pairs
for (k, v) in f.iteritems(): 
    print("key ", k, "has value", v)
\end{lstlisting}
Using the comprehension syntax and iteration, it is easy to invert a
mapping:
\begin{lstlisting}
# define `g` as the inverse of `f`
g = { v:k for (k, v) in f.iteritems() }
\end{lstlisting}


\section[Exception handling]{Exception handling: \l{try}/\l{except}/\l{finally} statements}
\label{sec:try-except-finally}

Exceptions are a language runtime construct to abort current function
execution, usually to signal an error.  If a block of Python code
cannot perform its function, it would \emph{raise} and exception:
current execution is aborted and control is returned to the calling
function.  This is searched for an \emph{exception handler}; if none
is found, the process continues recursively, inspecting the calling
function's caller for an exception handler.  If no exception handler
could be found across the whole call stack, the Python program aborts
execution.

The "try"/"except"/"finally" statements
are used to define exception handlers for a block of code.  The code
block following the "try" statement is executed; if it
raises an exception, then each "except" clauses immediately
following is inspected: if the type of the exception being raised
matches the type specified in the "except" clause, then the
code block following "except" is executed. The code block
following an "except" statement can raise a new exception
(or re-raise the one it caught); if no exception is raised, execution
continues with the statement that follows the
"try"/"except".  The code block following
"finally" is \emph{always} excuted before control leaves the
"try"/"except" clauses (in either way, that is,
after a "try"/"except" block completed with no
errors, or before returning control to the caller function because
another exception has been raised).

In the following example, the "a[42]" value lookup may
raise an exception of type "KeyError"; if this happens,
code in the "except" block will assign a default value to
"b".
\begin{lstlisting}
try:
    b = a[42]
except KeyError:
    # `a` has no value in the "42" position; 
    # assign a default value to `b`
    b = 0

# execution continues here
print (b)
\end{lstlisting}
                     

\subsection{The {\l pass} statement}
\label{sec:pass}

Python syntax does not allow to specify an empty block of code. There
is thus a special "pass" statement that performs no
computational operation, and is used to define ``no-op'' blocks.

The main use of "pass" is in combination with an
"except" statement, to ignore a particular error condition:
\begin{lstlisting}
try:
  print (a[42])
except KeyError:
  pass # ignore error if `a` has no item "42"
\end{lstlisting}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 

% LocalWords:  boolean
