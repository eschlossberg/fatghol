#! /usr/bin/env python
#
"""Generic classes for homological algebra.
"""
__docformat__ = 'reStructuredText'


import types

# import the NZMATH `Rational` class
import sys; sys.path.append('./NZMATH-0.7.0')
from nzmath.rational import Rational


class LinearSpan(object):
    """Represent the vector space generated by the given `base` vectors.
    """
    def __init__(self, base, num_type=Rational):
        """Constructor, taking explicit base and coefficient numeric type.

        First argument `base` is a sequence of base vectors; no
        requirement is placed on the type of base vectors.  The `base`
        object should support:
          - the `len` operator;
          - the `index` operator with the same semantics of the `list` one.

        Optional second argument `num_type` is a factory function for
        the coefficients in the coordinate vectors.  The function
        `num_type` should accept a single integer argument and return
        an instance of a type that supports addition (Python operators
        `__add__` and `__iadd__`).
        """
        self.base = base
        self.dimension = len(base)
        self._num_type = num_type
        
    def coordinates(self, element):
        """Return the coordinate vector of `element`.

        Argument `element` represents a linear combination as a list
        of pairs `(vector, coefficient)`, where `vector` is an item in
        the `base` (specified when constructing this object).
        """
        coordinates = [ self._num_type(0)
                        for i in xrange(self.dimension) ]
        for (vector, coefficient) in iter(element):
            coordinates[base.index(vector)] += coefficient
        return coordinates

    
class ChainComplex(object):
    """Represents a chain (homology) complex.

    `ChainComplex` objects support a list-like `C[i]` accessors; each
    `C[i]` represents the part of the graded vector space `C` having
    degree `i`.

    Any `ChainComplex` instance must actually be initialized by
    assigning `ChainComplexSlice` instances into each `C[i]`::

      >>> C = ChainComplex(2)
      >>> C[0] = LinearSpan('e0')
      >>> C[1] = LinearSpan(['e1', 'e2'])

    Indices of the slices `C[i]` run from 0 to `len(C)-1` (inclusive).
    The Python `len` operator returns the total length of the
    complex::
      
      >>> len(C)
      2

        The differential of `element` is an element of (another)
        `ChainComplexSlice`, whose `coordinates` method will be used
        to obtain a numerical representation of the differentiated
        element.
    """
    
    def __init__(self, length, modules=None, differentials=None):
        """Create a chain complex of specified length."""
        assert length > 0, \
                   "ChainComplex.__init__:"\
                   " argument `length` must be a positive integer," \
                   " but got `%s`." % length
        #: Total length of the complex.
        self.length = length
        #: Boundary operators; `differentials[i]` sends elements in
        #  `C[i]` to elements in `C[i+1]`.
        if differentials:
            assert len(differentials) == length, \
                   "ChainComplex.__init__:" \
                   " supplied `differentials` argument does not match" \
                   " supplied `length` argument."
            self.differential = differentials
        else:
            self.differential = [None] * length
        #: The vector spaces supporting the differential complex.
        if modules:
            assert len(modules) == length, \
                   "ChainComplex.__init__:" \
                   " supplied `modules` argument does not match" \
                   " supplied `length` argument."
            self.support = modules
        else:
            self.support = [None] * length

    ## list-like interface: support C[i] and len(C) syntax
    def __len__(self):
        return self.length
    def __getitem__(self, i):
        """Return the `i`-th pair (module, boundary operator)."""
        return (self.support[i], self.differential[i])
    def __setitem__(self, i, val):
        """Set the `i`-th support module and, optionally, boundary operator.

        ::
          C[i] = (module, differential)  # set `i`-th module and boundary op.
          C[i] = module                  # only set module
        """
        if (type(val) is types.TupleType):
            assert len(val) == 2, \
                   "ChainComplex.__setitem__:" \
                   " Need a 2-tuple (module, differential), but got `%s`" % val
            (self.support[i], self.differential[i]) = val
        else:
            self.support[i] = val

    def homology(self):
        """Compute and return homology (as a `Homology` class instance)."""
        Ds = []
        for i in xrange(self.length):
            # matrix representation of the `i`-th differential is
            # `dim C[i+1]` rows (range) by `dim C[i]` columns (domain)
            
            # FIXME: since we're only interested in computing the
            # rank, should we instanciate the matrix as row-major or
            # column-major, depending on which dimension is lesser?
            # (For doing Gaussian elimination on a smaller set.)
            D = Matrix(self.support[i+1].dimension,
                       self.support[i].dimension)
            for (j, b) in enumerate(self.support[i].base):
                D.setColumn(j, self.support[i+1]
                                 .coordinates(self.differential[i](b)))
            Ds.append(D)
        return Homology(Ds)


class Homology(object):
    """Compute the rational homology of a chain complex.

    At present, only the rank of the homology groups is computed.
    """

    def __init__(self, D):
        """Constructor, taking list of matrix representations of the
        boundary operators.

        The computation proceeds by Gaussian elimination on the `D`
        matrices, and operates directly on the passed object, which is
        thus altered.  So, be sure to make a copy of `D` if it is used
        somewhere else.
        """
        length = len(Ds)
        self.rank = [None] * length

        # compute ranks by Gaussian elimination
        rk = [None] * length    #: rank of `D[i]`
        null = [None] * length  #: nullity of `D[i]`
        for n in xrange(length):
            A = D[n]


class ColumnMajorMatrix(object):
    """Naive column-major matrix.

    Indices are 0-based.
    """

    def __init__(self, rows, columns, initializer=None):
        """Construct a sparse `rows` x `columns` matrix.

        Entries are initialized with the `initializer` value (by
        default: `None`).
        """
        self.rows = rows
        self.columns = columns
        self._entries = [
            [ initializer for index in xrange(rows) ]
            for index in xrange(columns)
            ]

    def __getitem__(self, it):
        """
        A[i,j] => matrix entry at row `i` and column `j`.
        A[i]   => `i`-th matrix column.
        """
        if isinstance(it, tuple):
            # A[i,j]
            (i, j) = it
            return self._entries[j][i]
        else:
            # column A[i]
            return self._entries[it]
    
    def __setitem__(self, it, val):
        """
        A[i,j] = a  # set matrix entry i,j to `a`
        A[i] = col  # set i-th matrix column to `col`
        """
        if isinstance(it, tuple):
            # A[i,j]
            (i, j) = it
            self._entries[j][i] = val
        else:
            # column A[i]
            self._entries[it] = val

    def __repr__(self):
        return "Matrix(columns=%s)" % repr(self._entries)
    def __str__(self):
        return repr(self)
    
    def toEchelonForm(self):
        """Replace self with Column-echelon form.

        Examples::
           >>> # a dense matrix
           >>> A = ColumnMajorMatrix(3,3)
           >>> for (j, col) in enumerate([[1.,4.,7.],[2.,5.,8.],[3.,6.,9.]]):
           ...   for (i, num) in enumerate(col):
           ...     A[i,j] = num
           >>> A.toEchelonForm()
           >>> A
           Matrix(columns=[[1.0, 2.0, 3.0], [0.0, 1.0, 1.6000000000000001], [0.0, 0.0, 1.0]])

           >>> # a sparse matrix
           >>> B = ColumnMajorMatrix(3,3, initializer=0.0)
           >>> B[1,1] = 5.0
           >>> B.toEchelonForm()
           >>> B
           Matrix(columns=[[0.0, 1.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])

           >>> # a rectangular matrix
           >>> C = ColumnMajorMatrix(4,3, initializer=0.0)
           >>> C[1,1] = 4.0
           >>> C[1,2] = 3.0
           >>> C[2,1] = 2.0
           >>> C[2,2] = 1.0
           >>> C.toEchelonForm()
           >>> C
           Matrix(columns=[[0.0, 1.0, 0.5, 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 0.0]])
           """
        sup_i = self.rows
        sup_j = self.columns
        i = 0  #: row index
        j = 0  #: column index
        self.rank = 0
        while (i < sup_i) and (j < sup_j):
          # Find pivot in row i, starting at column j:
          pivot_column = j
          for jj in xrange(j+1, sup_j):
            if abs(self[i,jj]) > abs(self[i,pivot_column]):
              pivot_column = jj
          if self[i, pivot_column] != 0:
            self.rank += 1
            # swap columns `j` and `pivot_column`
            self[pivot_column], self[j] = self[j], self[pivot_column]
            # divide each entry in column `j` by `self[i,j]`
            lead = self[i, j]
            for ii in xrange(sup_i):
                self[ii, j] /= lead
            # A[*,u] -= A[*,j] * A[i,u]
            for u in xrange(j+1, sup_j):
              for ii in xrange(sup_i):
                  self[ii, u] -= self[ii, j] * self[i, u]
                               # Now self[i,u] will be 0, since:
                               # self[i,u] - self[i,j] * self[i,u]
                               # = self[i,u] - 1 * self[i,u]
                               # = 0.
            j += 1
          i += 1
        
        
## main: run tests

if "__main__" == __name__:
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
