
\chapter[An algorithm for graph homology]
  {An algorithm for computing graph homology}
\label{chap:algorithm}

This chapter presents an algorithm to compute homology of the fatgraph
complex $\R_{g,n}$.  By Theorem~\ref{thm:fatgraph-homology}, this is
tantamount to the (co)homology with rational coefficients of the
moduli spaces $\M_{g,n}$. An effective computer implementation of the
algorithm is presented, which is capable of computing the Betti
numbers\footnote{Explicit generators of the homology modules could be
  computed with a little variant in the last step of the algorithm;
  however, this is not interesting in connection with the homology of
  $\M_{g,n}$, since expression of a fatgraph homology class in terms
  of the ``natural'' algebro-geometric classes has proved to be a
  difficult problem \cite{mondello:2004,
    igusa:combinatorial-miller-morita-mumford-classes-and-witten-cycles,
    igusa:graph-cohomology-and-kontsevich-cycles}, and to-date lacks a
  general solution.} of $\M_{g,n}$ for $(2g+n) < 6$ on standard
desktop-class hardware.  The size of the fatgraph complex increases
factorially with $2g+n$, so a parallel algorithm is needed to compute
the Betti numbers of $\M_{g,n}$ for $(2g+n) \geq 6$; this will be the
subject of a later chapter.

The Python programming language is used in this chapter to articulate
the algorithm.  Python is claimed to be ``executable pseudo-code'',
combining a readable and ``natural'' syntax (that makes it well suited
to teaching programming to novices \cite{georgatos:python}) with the
power of a general-purpose language that is presently in daily use for
several real-world applications (see, e.g., \cite{python:success}).
Therefore, the code listed in this chapter can be copied to a Python
file and actually executed.  For the reader's convenience,
Appendix~\ref{chap:python} recaps the Python syntax and briefly explains the
constructs and idioms used in programming this algorithm.

The purpose of this chapter is thus threefold:
\begin{itemize}
\item Elucidate the algorithm,
\item Provide an actual implementation, and
\item Prove its correctness.
\end{itemize}
This yields an example of \emph{literate programming} \cite{knuth:lp},
the computer source code and the text explaining it are entwined
together into a single text, which can be read as a proof of the
algorithm's correctness.

\section[Overview]{Overview of the algorithm}
\label{sec:overview}

Theorem~\ref{thm:fatgraph-homology} provides an effective way to compute the
(co)homology of $\M_{g,n}$.  The Betti numbers of $\M_{g,n}$ can be
computed from the knowledge of the dimension of chain spaces $W_p$of
the fatgraph complex, and the ranks of the boundary operators $D_p$;
this can effectively be accomplished in the following stages:
\begin{enumerate}[I.]
\item Compute the basis set of $W_*$; by definition, the basis set is
  the set of \emph{orientable} fatgraphs indexing
  the cells of $\Mcomb_{g,n}$.
\item Work out the differential $D: W_* \to W_*$ in an
  effectively computable way, i.e., as matrix operators $D_p$ mapping
  coordinates in the fatgraph basis of $W_p$ into coordinates
  w.r.t. the fatgraph basis of $W_{p-1}$.
\item Compute the ranks of the matrices $D_p$.
\end{enumerate}

Stage~I needs just the pair $g,n$ as input; its output is the set of
orientable numbered fatgraphs belonging in $\R_{g,n}$: i.e., Stage~I
is an algorithm to enumerate the fatgraph of given genus and number of
boundary cycles. By definition, numbered fatgraphs are decorated
abstract fatgraphs, and the decoration is a simple combinatorial
datum: therefore, the problem can be reduced to enumerating abstract
fatgraphs.  With a recursive algorithm, one can construct
\emph{trivalent} $\M_{g,n}$-fatgraphs from trivalent graphs in
$\M_{g-1,n}$ and $\M_{g',n'} \times \M_{g'',n''}$ with $g'+g''=g$ and
$n'+n''=n$.  All other graphs in $\M_{g,n}$ are gotten by contraction
of regular edges.

The differential $D$ has a simple geometrical definition: $D(G)$ is a
sum of graphs $G'$ gotten by contracting a non-loop edge of $G$. A
naive implementation of Stage~II would just compare each contraction
of a graph with $k$ edges with any graph with $k-1$ edges, and score a
$\pm 1$ (depending on the orientation) in the corresponding entry of
the matrix $D_k$.  However, this algorithm has quadratic complexity,
and the large number of graphs involved makes it very inefficient
already for $\M_{0,5}$.  The simple observation that contraction of
edges is defined on the topological fatgraph underlying a numbered
fatgraph allows us to apply the naive algorithm to topological
fatgraphs, which cuts complexity down by a factor~$(n!)^2$.  The
resulting matrix is then extended to numbered fatgraphs by the action
of graph automorphism groups on the numberings of boundary cycles.
This is the variant detailed in Section~\ref{sec:boundary-ops}.

Stage~III is the simplest: by elementary linear algebra, the Betti
numbers can be computed from the rank of matrices $D_k$ and the
dimension of their domain space.  The computational problem of
determining the rank of a matrix has been extensively studied, and
several implementations of linear algebra algorithms are already
available in the form of function libraries, ready for use. It should
be noted, however, that this is the step that consumes more computer
time (except for the very simple cases $2g+n<5$).


\section[Generation of fatgraphs]{Generation of all Fatgraphs in $\R_{g,n}$}
\label{sec:generation}

Exposition of the Stage~I code will proceed in a \emph{top-down}
fashion: we shall work our way from the topmost function, which
returns the collection of all fatgraphs in $\R_{g,n}$, down to the
computer representation of a fatgraph.  This way, requirements that
functions and objects must satisfy become evident during the analysis,
and implementation details are introduced only when needed.

Computations in this first stage output the set of orientable
fatgraphs $\R_{g,n}$ from the input pair $g, n$, with $2g +n - 2 > 0$.
The numbering will be added in Stage~II of the algorithm, so just the
set of undecorated fatgraphs is output here.

Let "MgnGraphs" be the function which, given the two integers $g$,
$n$ as input, and returns the collection of $\R_{g,n}$ graphs.  Let us
further stipulate that the output result will be represented as a
Python "list": the $0$-th item in this list is the list of graphs
with the maximal number $m$ of edges; the $k$-th item in the list is
the list of graphs having $m - k$ edges.  There are algorithmic
advantages in this subdivision, which are explained below.

The Python implementation of the "MgnGraphs" function is as follows:
\begin{lstlisting}
def MgnGraphs(g,n):
  """
  Return all connected fatgraphs having prescribed
  genus `g` and number of boundary cycles `n`.
  """
  # "graphs" is the function output; start with an empty list
  graphs = [ ]

  # maximum number of edges
  m = 4*g + 2*n - 5
\end{lstlisting}
Graphs with the maximal number of edges are trivalent graphs; they are
computed by a separate function "MgnTrivalentGraphs", described in
Section~\ref{sec:stage1-trivalent}.
\begin{lstlisting}
  # first item `graphs[0]` contains all 3-valent graphs
  graphs.append(list(MgnTrivalentGraphs(g,n)))
\end{lstlisting}
We can then proceed to generating all graphs in $\R_{g,n}$ by
contraction of regular edges: by contracting one edge in
trivalent graphs we get the list "graphs[1]" of all graphs with
$m-1$ edges; contracting one edge in $G \in $"graphs[1]", we
get $F \in $"graphs[2]" with $m-2$ edges; and so on:
\begin{lstlisting}
  for k in range(1,m):                         |\n{mgngraphs:1}|
    graphs.append([]) # "graph[k]" starts as empty list |\n{mgngraphs:2}|
    for G in graphs[k-1]:                      |\n{mgngraphs:3}|
      for e in G.edge_orbits():                |\n{mgngraphs:4}|
        if not e.is_loop():                    |\n{mgngraphs:5}|
          F = G.contract(e)                    |\n{mgngraphs:6}|
          if F not in graphs[k]:               |\n{mgngraphs:7}|
            graphs[k].append(F)                |\n{mgngraphs:8}|
\end{lstlisting}
A line-by-line explanation follows.

On line~\nr{mgngraphs:1}, the "range(1,m)" function sequentially
generates all integers in the half-open range $[1, m)$; therefore, the
"for"-loop body in lines \nr{mgngraphs:2}--\nr{mgngraphs:8} is
executed $m-1$ times, with $k$ orderly taking the values $1$, ...,
$m-1$.  Note that, by Python syntax, the loop body is indented w.r.t
the loop head line.

In the subsequent line, "graph[k]" is initialized to an empty list: at
the start of the loop body, the "graphs" list only has items
"graphs[0]" through "graphs[k-1]".

Line~\nr{mgngraphs:3} introduces a new loop: code in lines
\nr{mgngraphs:4}--\nr{mgngraphs:8} will be executed once for each
fatgraph "G" in "graphs[k-1]".

Line~\nr{mgngraphs:4} starts the core of the function: contract edges
of the fatgraph "G" to generate new fatgraphs with $m-k$ edges.
However, we need not contract every edge of a fatgraph: if $a \in
\Aut(G)$ is an automorphism and $x \in E(G)$ is an edge, then the
contracted graphs $G' = G/x$ and $G'' = G/a(x)$ are isomorphic.
Hence, we can restrict the computation to consider only one edge per
orbit of the action induced by $\Aut(G)$ on the set $E(G)$. This is
what the method call "G.edge_orbits()" provides: for each graph "G",
it partitions the set of edges of "G" into orbits and returns one
representative edge "e" for each one.

Line~\nr{mgngraphs:5} skips non-regular edges: the following code is
executed if and only if "e" is not a loop.

Line~\nr{mgngraphs:6} computes the fatgraph "F" obtained by
contracting the current edge "e" in "G": the "Fatgraph.contract(G,e)"
invocation returns a \emph{new} fatgraph instance obtained by applying
topological contraction.

Lines~\nr{mgngraphs:7}--\nr{mgngraphs:8} add "F" to "graphs[k]"
\emph{only if it is not already there}.  This is actually very concise
syntax for the most computationally expensive part of the "MgnGraphs"
function: Python performs a comparison between "F" and each element in
"graphs[k]"; each comparison invokes the "Fatgraph.__eq__" method,
which in turn invokes "Fatgraph.isomorphism".

If $N_k = \text{\l{len(graph[k])}}$ is the number of elements in
"graph[k]" and $T_\text{iso}$ is the average time needed to
determine if two graphs are isomorphic, then evaluating the expression
``"F in graphs[k]"'' takes $O(N_k \cdot T_\text{iso})$ time: thus, the
subdivision of "graphs" into lists, each one holding graphs with a
specific number of edges, reduces the number of fatgraph comparisons
done in the innermost loop of "MgnGraphs".  (Although graphs with a
different number of edges are readily seen not to be isomorphic, the
isomorphism test is performed in the innermost loop, so it is executed
nonetheless a considerable number of times, and each saving, albeit
small, can result in a substantial shortening of the total running
time.)

Finally, the function "MgnGraphs" exits and returns the list "graphs"
to the caller:
\begin{lstlisting}
  # the list "graphs" is the final output of this function
  return graphs
\end{lstlisting}

Note that the top-level function "MgnGraphs" is quite independent of
the actual Python implementation of the "Fatgraph" type of objects:
all is needed here, is that a "Fatgraph" instance has methods for
enumerating edges, contracting an edge, and testing two graphs for
isomorphism.

\begin{lemma}
  If "MgnTrivalentGraphs(g,n)" returns the complete list of
  \emph{trivalent} fatgraphs in $\R_{g,n}$, then the function
  "MgnGraphs" defined above returns the complete set of fatgraphs
  $\R_{g,n}$.
\end{lemma}
\begin{proof}
  By the above dissection of the algorithm, all we need to prove is
  that any fatgraph in $\R_{g,n}$ can be obtained by a chain of edge
  contractions from a trivalent fatgraph.  This follows immediately
  from the fact that any fatgraph vertex $V$ of valence $v \geq 3$ can
  be expanded (in several ways) into vertices $V_1$, $V_2$ of valences
  $v_1$, $v_2$ such that $v = (v_1 -1) + (v_2 -1)$, plus a connecting
  edge.
\end{proof}


\section{Generation of Trivalent Fatgraphs}
\label{sec:trivalent}

The generation of trivalent graphs can be tackled by an inductive
procedure: given a trivalent graph, a new edge is added, which joins
the midpoints of two existing edges.  
In order to determine which graphs should be input to the ``edge
addition'' procedure, one can instead follow the reverse route, and
ascertain how a trivalent graph is transformed by \emph{deletion} of
an edge.

Throughout this section, $V$ and $E$ stand for the number of vertices
(resp.~edges) of a graph; it will be clear from the context, which
exact graph they are invariants of.

\subsection{Removal of edges}
\label{sec:removal}

Let $G \in \R_{g,n}$ be a \emph{connected} trivalent graph. Each edge
$x \in E(G)$ falls into one of the following categories:
\begin{enumerate}[\slshape A)]
\item $x$ is a loop: both endpoints of $x$ are
  attached to a single vertex $v$; another edge $x'$ joins $v$ with a
  distinct vertex $v'$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ and separates two distinct boundary cycles $\beta, \beta'
  \in B(G)$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ but belongs to only one boundary cycle $\beta \in B(G)$,
  within which it occurs twice, once for each orientation.
\end{enumerate}
Deletion of edge $x$ requires different adjustments in order to get a
trivalent graph again in each of the three cases above; it also yields
a different result in each case.
\begin{figure}
  \centering
  % rubber: make removal.eps from removal.fig
  % rubber: make removal.pdf from removal.fig
  \includegraphics{removal}
  \caption{Graphical illustration of fatgraph edge removal.  Top row: a regular edge is removed from an $\R_{0,4}$ graph; its endpoints are further removed; the remaining edges are joined and the resulting graph is a trivalent fatgraph in $\R_{0,3}$.  Bottom row: a loop is removed from a trivalent $\R_{0,4}$ graph; the stem together with its endpoints has to be removed as well; the remaining edges are joined, and we end up with a trivalent fatgraph in $\R_{0,3}$.}
  \label{fig:removal}
\end{figure}

Case {\slshape A)}: If $x$ is a loop attached to $v$, then, after deletion
of $x$, one needs to also delete the loose edge $x'$ and the
vertex $v'$ (that is, join the two other edges attached to $v'$; see
Figure~\ref{fig:removal}, bottom row).  The resulting fatgraph $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$, $x'$ have been deleted and two other
  edges merged into one;
\item one boundary cycle less: the boundary cycle totally bounded by
  $x$ has been removed.
\end{itemize}
Therefore:
\begin{align*}
  2 - 2g' &= \chi(G') = V' - E' + n' 
  \\
  &= (V-2) -(E-3) + (n-1)
  \\
  &= V - E + n = \chi(G) = 2 - 2g,
\end{align*}
hence $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:A}\tag{A}
\end{equation}

In case {\slshape B)}, $x$ joins distinct vertices $v$,
$v'$ and separates distinct boundary cycles (see Figure~\ref{fig:removal},
top row).  Delete $x$ and merge the two edges attached to each of
the two vertices $v$ and $v'$; in the process, the two boundary cycles
$\beta, \beta'$ also merge into one. The resulting fatgraph $G'$ is
connected. Indeed, given any two vertices $u, u' \in V(G')$, there is
a path $(x_1, \ldots, x_k)$ connecting $u$ with $u'$ in $G$; if this
path passes through $x$, one can replace the occurrence of $x$ with
the perimeter ---excluding $x$--- of one of the two boundary cycles
$\beta, \beta'$ to get a path joining $v$ and $v'$ which avoids $x$,
and thus projects to a path in $G'$.  Again we see that $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle less: the boundary cycles $\beta$, $\beta'$
  have been merged into one.
\end{itemize}
Therefore $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:B}\tag{B}
\end{equation}

In case {\slshape C)}, $x$ joins distinct vertices $v$,
$v'$ but belongs into \emph{one} boundary cycle $\beta \in B(G)$ only.
Delete edge $x$ and the two vertices $v$, $v'$, joining the attached
edges two by two as in case {\slshape B)}.  We distinguish two
cases, depending whether the resulting fatgraph is connected.
\begin{enumerate}
\item[\slshape C')] If the resulting fatgraph $G'$ is connected, then
  $\beta \in B(G)$ has been split into two distinct boundary cycles
  $\beta', \beta'' \in B(G')$.  Indeed, write the boundary cycle
  $\beta$ as an ordered sequence of oriented edges: $y_0 \to y_1 \to
  \ldots \to y_l \to y_0$; assume the $y_*$ appear in this sequence in the
  exact order they are encountered when walking along $\beta$ in the
  sense given by the fatgraph orientation. The oriented edges $y_j$
  are pairwise distinct: if $y_i$ and $y_k$ share the same supporting
  edge, then $y_i$ and $y_k$ have opposite orientations. By the
  initial assumption of case~{\slshape C)}, edge $x$
  must appear \emph{twice} in the list: if $\bar x$ and $\underline x$
  denote the two orientations of $x$, then $y_i = \bar x$ and $y_k =
  \underline x$.  Deleting $x$ from $\beta$ is (from a homotopy point
  of view) the same as replacing $y_i = \bar x$ with $\bar x \to
  \underline x$, and $y_k = \underline x$ with $\underline x \to \bar
  x$ when walking a boundary cycle. Then we see that $\beta$ splits
  into two disjoint cycles:
\begin{align*}
  \beta' &= y_0 \to y_1 \to \cdots \to y_{i-1} \to \bar{x} \to
  \underline{x} \to y_{k+1} \to \cdots \to y_l \to y_0,
  \\
  \beta'' &= y_{i+1} \to \cdots \to y_{k-1} \to \underline{x} \to
  \bar{x} \to y_{i+1}.
\end{align*}
In this case, $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle \emph{more}: the boundary cycle $\beta$ has
  been split in the pair $\beta'$, $\beta''$.
\end{itemize}
Therefore $g'=g-1$ and $n'=n+1$, so:
\begin{equation}
G' \in \R_{g-1,n+1}.
\label{eq:C'}\tag{C'}
\end{equation}

\item[\slshape C'')] $G'$ is a disconnected union of fatgraphs $G'_1$ and
  $G'_2$; for this statement to hold unconditionally, we temporarily allow a
  single circle into the set of connected fatgraphs (consider it a fatgraph
  with one closed edge and no vertices) as the one and only element of
  $\R_{0,2}$.  As will be shown in Lemma~\ref{lemma:no-c2}, this is
  irrelevant for the algorithm.  Now:
  \begin{equation*} V'_1 + V'_2 = V -2, 
    \qquad E'_1 + E'_2 = E - 3,
    \qquad n'_1 + n'_2 = n + 1,
  \end{equation*} hence:
\begin{align*} 
  (2- 2g'_1) + (2-2g'_2) &= (V-2) - (E-3) + (n+1) 
  \\ 
  &= (V-E+n) + 2 = 4 - 2g
\end{align*} 
So that $g'_1 + g'_2 = g + 2$, $n'_1 + n'_2 = n+1$ and
\begin{equation} 
  G'= G'_1 \otimes G'_2 \in \R_{g'_1, n'_1} \otimes \R_{g'_2, n'_2}.
  \label{eq:C''}\tag{C''}
\end{equation}
\end{enumerate}

\subsection{Inverse construction}
\label{sec:addition}

If $x \in E(G)$ is an edge of fatgraph $G$, denote $\bar{x}$ and
$\underline{x}$ the two opposite orientations of $x$.

In the following, let $\R'_{g,n}$ be the set of fatgraphs with a
selected oriented edge:
\begin{equation*}
  \R'_{g,n} := \{ (G,\bar x) : G \in \R_{g,n}, \bar{x} \in L(G)\}.
\end{equation*}
Similarly, let $\R''_{g,n}$ be the set of fatgraphs with two
chosen oriented edges:
\begin{equation*}
  \R''_{g,n} := \{ (G, \bar x, \bar y) : G \in \R_{g,n}, 
                   \bar{x}, \bar{y} \in L(G) \}.
\end{equation*}
The following abbreviations come in handy: let $\R = \cup \R_{g,n}$,
$\R' = \cup \R'_{g,n}$, and $\R'' = \cup \R''_{g,n}$.

Define the attachment of a new edge to a fatgraph in the following
way.  Given a fatgraph $G$ and an \emph{oriented} edge $\bar{x}$, we
can create a new trivalent vertex $v$ in the midpoint of $x$, and
attach a new edge to it, in such a way that the two halves of $x$
appear, in the cyclic order at $v$, in the same order induced by the
by the orientation of $\bar{x}$.  Figure~\ref{fig:adding} depicts the process.
\begin{figure}
  \centering
  % rubber: make adding.eps from adding.fig
  % rubber: make adding.pdf from adding.fig
  \includegraphics{adding}
  \caption{When adding a new vertex in the middle of an edge $x$, the cyclic order depends on the oriented edge: the two orientations $\bar{x}$ and $\underline{x}$ get two inequivalent cyclic orders.}
  \label{fig:adding}
\end{figure}

We can now define maps that invert the constructions {\slshape A)}, {\slshape B)},
{\slshape C')} and {\slshape C'')} defined in the previous section.
\begin{figure}
  \centering
  % rubber: make pqr.eps from pqr.fig
  % rubber: make pqr.pdf from pqr.fig
  \includegraphics{pqr}
  \caption{Graphical illustration of maps $p$, $q$, $r_{g,n}$.  Top left: $p(G,\bar{x})$ attaches a ``slipknot'' to edge $\bar{x}$.  Top right: $r_{2,5}(G_1, \bar{x}, G_2, \bar{y})$ joins fatgraphs $G_1$ and $G_2$ with a new edge. Bottom: $q(G,\bar{x}, \bar{y})$ (left) and $p(G, \underline{x}, \bar{y})$ (right); it is shown how changing the orientation of an edge can lead to different results.}
  \label{fig:pqr}
\end{figure}

Let $p_{g,n} : \R'_{g,n-1} \to \R_{g,n}$ be the map that creates a
fatgraph $p(G,\bar{x})$ from a pair $(G, \bar{x})$ by attaching the
loose end of a ``slip knot''\footnote{A single 3-valent vertex with
  one loop attached and a regular edge with one loose end.} to the
midpoint of $x$.The map $p: \R' \to \R$, $p|_{\R'_{g,n}} := p_{g,n}$
is ostensibly inverse to {\slshape A)}.

To invert {\slshape B)} and {\slshape C')}, define a map $q : \R'' \to \R$ that
operates as follows:
\begin{itemize}
\item Given $(G, \bar{x}, \bar{y})$ with $\bar{x} \not= \bar{y}$, $q$
  attaches a new edge to the midpoints of $x$ and $y$; again the
  cyclic order on the new midpoint vertices is chosen such that the
  two halves of $x$ and $y$ appear in the order induced by the
  orientations $\bar x$, $\bar y$.
\item When $\bar{x} = \bar{y}$, let us further stipulate that the
  construction of $q(G, \bar{x}, \bar{x})$ happens in two steps:
  \begin{enumerate}
  \item a new trivalent vertex is created in the midpoint of $x \in
    E(G)$ and a new edge $\xi$ is attached to it,
  \item create a new trivalent vertex in the middle of the one of the
    two halves which comes first in the ordering induced by the
    orientation $\bar{x}$; attach the loose end of the new edge $\xi$
    to this new vertex.
  \end{enumerate}
  It is clear that the above steps give an unambiguous definition of
  $q$ in all cases where $\bar{x}$ and $\bar{y}$ are orientations of
  the same edge of $G$, that is, $(G, \bar{x}, \bar{x})$, $(G,
  \bar{x}, \underline{x})$, $(G, \underline{x}, \bar{x})$, and $(G,
  \underline{x}, \underline{x})$.
\end{itemize}
Ostensibly, $q$ inverts the edge removal in cases {\slshape B)} and
{\slshape C')}: the former applies when a graph $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g,n+1}$, the latter when $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g+1,n-1}$.

Finally, to invert {\slshape C'')}, let us define
\begin{equation*}
r_{g,n}: \bigoplus_{\substack{g'_1+g'_2=g+2 \\ n'_1+n'_2=n}} 
\R'_{g'_1, n'_1} \times \R'_{g'_2, n'_2} \to \R.
\end{equation*}
From $(G', \bar{x}', G'',
\bar{x}'')$, construct a new fatgraph by bridging $G'$ and $G''$ with
a new edge, whose endpoints are in the midpoints of $x'$ and $x''$;
again, stipulate that the cyclic order on the new vertices is chosen
such that the two halves of $x'$, $x''$ appear in the order induced by
the orientations $\bar{x}'$, $\bar{x}''$.

Summing up, any fatgraph $G \in \R_{g,n}$ belongs to the image of one
of the above maps $p$, $q$, and $r$. There is considerable
overlap among the different image sets: indeed, one can prove that
$r$ is superfluous.
\begin{lemma}\label{lemma:no-c2}
  Any fatgraph obtained by inverting construction {\slshape C'')} lies in
  the image of maps $p$ and $q$.
\end{lemma}
\begin{proof}
  Assume, on the contrary, that $G$ lies in the image of $r$ only.
  Then, deletion of any edge $x$ from $G$ yields a disconnected graph
  $G' \otimes G''$.  Both subgraphs $G'$ and $G''$ enjoy the same
  property, namely, that deletion of any edge disconnects: otherwise,
  if the removal of $y \in E(G')$ does not disconnect $G'$, then
  neither does it disconnect $G = r_{g,n}(G', G'')$, contrary to the
  assumption. As long as $G'$ or $G''$ has more than 3 edges, we can
  delete another edge; by recursively repeating the process, we end up
  with a fatgraph $G^*$ with $\leq 3$ edges, which is again
  disconnected by removal of any edge.  Since $G^*$ is trivalent, $3
  \cdot E^* = 2 \cdot V^*$, therefore $G^*$ must have exactly 3 edges
  and 2 vertices. But all such fatgraphs belong in $\R_{0,3}$ or
  $\R_{1,1}$, and it is readily checked that there is no way to add an
  edge such that the required property holds, that any deletion
  disconnects.
\end{proof}

\subsection{The \protect\Verb`MgnTrivalentGraphs` algorithm}
\label{sec:MgnTrivalentGraphs}

The stage is now set for implementing the recursive generation of
trivalent graphs.
\begin{lstlisting}
def MgnTrivalentGraphs(g, n):
  """
  Return a list of all connected trivalent fatgraphs with
  prescribed genus `g` and number of boundary cycles `n`.
  """
\end{lstlisting}

A function call "MgnTrivalentGraphs(g,n)" recursively calls
"MgnTrivalentGraphs" to enumerate trivalent graphs of $\R_{g,n-1}$
and $\R_{g-1,n+1}$; it is cleaner to program the function as to call itself
unconditionally, and to catch the induction base cases at the very
start.  In particular, "MgnTrivalentGraphs" must:
\begin{itemize}
\item return the empty set when called with an invalid "(g,n)" pair;
\item provide the full set of fatgraphs $\R_{0,3}$ and $\R_{1,1}$ as
  induction base.
\end{itemize}
This is indeed realized in the following lines (the fatgraph
representation as a Python ``"Fatgraph"'' object is discussed in
Section~\ref{sec:stage1-fatgraphs}):
\begin{lstlisting}
  # avoid infinite recursion in later statements
  if n==0 or (g,n)<(0,3):
    return [ ] # return empty list

  # $M_{0,3}$ --- induction base
  if (g,n) == (0,3):
    return [ 
        Fatgraph([Vertex([1, 2, 1]), Vertex([2, 0, 0])]),
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 0, 1])]) 
      ]

  # $M_{1,1}$ --- induction base
  elif (g,n) == (1,1):
    return [ 
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]) 
      ]
\end{lstlisting}

The general case is quite straightforward, if we assume to have
working implementations of the maps $p$ and $q$ defined in the
previous section (a description of the implementation of these maps
falls within the scope of Section~\ref{sec:stage1-fatgraphs}).  The basic
idea is: apply maps $p$, $q$ to every fatgraph in $\R_{g,n-1}$, and
$q$ to every fatgraph in $\R_{g-1,n+1}$; discard all graphs that do
not belong to $\R_{g,n}$ and take only one graph per isomorphism class
into the result set.

Implementation of the general case starts with creating an empty list
for accumulating the results.  An helper function
"add_if_admissible" is defined, to store only fatgraphs belonging in
$\R_{g,n}$ into "result", and only one fatgraph per isomorphism
class (the ``"G not in result"'' clause):
\begin{lstlisting}
  # general case
  else:
    result = [ ] # start with empty list

    def add_if_admissible(G):
      if (G.genus, G.num_boundary_cycles) == (g,n) \
          and (G not in result):
        result.append(G)
      
\end{lstlisting}

To invert construction {\slshape A)}, apply map $p$ to all fatgraphs $G \in
\R_{g,n-1}$; if $a \in \Aut(G)$, then $p(a(G), a(x)) = p(G, x)$,
therefore we may limit ourselves to one pair $(G,x)$ per orbit of the
automorphism group, saving a few computational cycles:
\begin{lstlisting}
    # case A: hang a circle to all edges of graphs in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for x in G.edge_orbits():
        add_if_admissible (G.hangcircle(x,0))
        add_if_admissible (G.hangcircle(x,1))

\end{lstlisting}
The ``"Fatgraph.hangcircle"'' function implements the behavior of the
$p$ map: the expression ``"G.hangcircle(x,0)"'' returns a copy of
"G", with a ``slipknot'' attached to edge "x".  The additional
parameter ("0" or "1") determines which orientation of "x"
should be considered, therefore expressions like ``"x,0"'' and
``"x,1"'' should really be read as $\bar{x}$ or $\underline{x}$. A
complete explanation and implementation details are given in
Section~\ref{sec:stage1-fatgraphs}.

Similarly, function ``"Fatgraph.bridge"'' implements $q$;
the algorithm used is independent of $g$ and $n$, thus a single
function can serve the whole fatgraph domain $\R = \cup
\R_{g,n}$. Since $q$ is a function of $(G, \bar{x}, \bar{y})$, which
is by construction invariant under $\Aut(G)$, we can again restrict
to considering only one $(G, \bar{x}, \bar{y})$ per $\Aut(G)$-orbit;
this is computed by the "G.edge_pair_orbits" function:
\begin{lstlisting}
    # case B: bridge all edges of a single graph in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

    # case C': bridge all edges of a single graph in $M_{g-1,n+1}$
    for G in MgnTrivalentGraphs(g-1,n+1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

\end{lstlisting}

Finally, the list of fatgraphs (one fatgraph per isomorphism class) is
returned to the caller:
\begin{lstlisting}
    return result
\end{lstlisting}
\FIXME{Serve qui un'analisi della complessit\`a dell'algoritmo?  In
  realt\`a non si pu\`o concludere molto, perch\'e dipende in modo
  essenziale dal numero totale dei grafi e dal numero dei duplicati:
  nessuno di questi \'e noto in anticipo.}


\section{Computer representation of Fatgraphs}
\label{sec:fatgraph-representation}

The core of the computation lies in the representation of a fatgraph
as an object in the programming language Python: according to the
analysis of the graph generation algorithms in
Sections~\ref{sec:generation} and~\ref{sec:trivalent}, a
``"Fatgraph"'' class is needed, together with functions to contract an
edge ("Fatgraph.contract"), compute orbits of edges under the action
of fatgraph automorphisms ("Fatgraph.edge_orbits" and
"Fatgraph.edge_pair_orbits"), implement maps $p$ and $q$
("Fatgraph.hangcircle" and "Fatgraph.bridge"), and, last but not
least, check two graphs for isomorphism.\FIXME{Rimuovere i nomi delle
  funzioni da questo paragrafo introduttivo?}

Although the combinatorial definition of a fatgraph
(cf.~Section~\ref{sec:fatgraphs}) might suggest a computer representation as
a triple of permutations ---as used, e.g., in \cite[Section
2.4]{arXiv:0902.1025}---, the functions that are needed by the above
generation algorithms are rather topological in nature and thus
suggest an approach more directly related to the concrete realization
of a fatgraph.

\subsection{Vertices}
\label{sec:vertices}

Let $G$ be a fatgraph; assuming $G$ has $E = l+1$ edges, arbitrarily
assign to each edge an integer in the range $[0, E)$, that is, pick a
bijective map $e: E(G) \to \{0, \dots, l\}$.  Each vertex $v \in V(G)$
is thus decorated with a cyclic sequence of edge labels.  Conversely,
given just the set of such decorations, one can reconstruct the
fatgraph $G$: indeed, given cyclic sequences $v_0 = (e_0^0,
e^0_1, \ldots, e^0_{i_0})$, \ldots, $v_k = (e^k_0, \ldots,
e^k_{i_k})$, such that $\{e^0_0, \ldots, e^0_{i_0}, e^1_0, \ldots,
e^{k-1}_{i_{k-1}}, e^k_0, \ldots, e^k_{i_k}\} = \{0, \ldots, l\}$,
we can set
\begin{equation*}
  X := \{ (e, v) : e \in v, v\in \{v_0, \ldots, v_k\} \},
\end{equation*}
and define maps $\sigma_0, \sigma_1, \sigma_2: X \to X$ as follows:
$\sigma_0$ sends $(e, v)$ to $(e', v)$ where $e'$ is the successor of
$e$ in the cyclic order at $v$; $\sigma_1$ maps $(e, v)$ to the unique
other pair $(e', v') \in X$ such that $e = e'$; finally, $\sigma_2$ is
determined by the constraint $\sigma_0\sigma_1\sigma_2 = \id_X$.  Then
$G = (X, \sigma_0, \sigma_1, \sigma_2)$ is a fatgraph; by applying the
procedure described at the beginning of this paragraph, we recover
$v_0$, \ldots, $v_k$ up to a permutation of the edge labels.
\begin{figure}
  \centering
  % rubber: make vertex.pdf from vertex.fig
  % rubber: make vertex.eps from vertex.fig
  \includegraphics{vertex}
  \caption{Representation of vertices as (cyclic) lists of edge
    labels.  (Edge labels are depicted as numbers on a yellow square
    background, sitting over the edge they label.)  Representation of
    a vertex as a list is implicitly ciliated: we use the convention
    that the edge closest to the vertical ``upwards'' line is the
    ciliated one.}
  \label{fig:vertex}
\end{figure}

Therefore, we can represent a fatgraph vertex by the cyclically
ordered list of its edge labels.  Figure~\ref{fig:vertex} gives an
illustration. 

The "CyclicList" base class provides all the functionality needed by
such a "Vertex" class: if "v" is a "Vertex" instance, then the
Python expression "v[i]" returns the edge label stored at
position "i", furthermore, "v[i]==v[i+L]" when "L=len(v)".
The length "len(v)" of a "Vertex" instance is the number of edges attached
to the vertex.  

Thus, in the definition of the "Vertex" class we only override the
initialization method to record some additional information:
\begin{lstlisting}
class Vertex(CyclicList):
  """
  A (representation of a) vertex of a ribbon graph.
  """
  def __init__(self, seq):
    # initialize base class
    CyclicList.__init__(self, seq)
    # store number of loops (top. invariant) for later reference
    self.num_loops = len(self) - len(set(self))

\end{lstlisting}
During a "Vertex" object creation, the number of loops attached to
this vertex is computed and stored in the "num_loops" attribute: the
number of loops is a vertex invariant and will be used in the
computation of fatgraph isomorphisms.  The number of loops is computed
as the difference between "len(self)", the number of attached edges,
and "len(set(self))", the number of (unique) labels of attached
edges.\footnote{Python's expression \l{set(self)} builds a \l{set}
  object from the list of integers \l{self}, i.e., it removes multiple
  occurrences of the same number from the list.  Therefore
  \l{len(set(self))} is the number of elements in \l{set(self)}, that
  is, the number of unique edge colorings at the vertex represented by
  \l{self}.}

\begin{definition}
  A fatgraph vertex together with a choice of an attached edge is
  called a \emph{ciliated} vertex.  The chosen edge is called the
  \emph{cilium}.
\end{definition}
Note that "Vertex" objects actually represent \emph{ciliated} vertices.
Since we need to implement the cyclic behavior of fatgraph vertices,
two "Vertex" instances must be declared equal if one is equal (as a
sequence) to the other rotated by a certain amount.  This behavior is
again implemented in the "CyclicList" class: comparing two
"CyclicSequence" instances has linear complexity in the length of
the sequence, as all the rotations have to be tried out in the worst
case.\FIXME{Inserire qui il codice relativo e il commento?}

The following definition will often be referred to, in the remainder
of this section:
\begin{definition}
  If $v$ is a ciliated vertex and $e$ is a half-edge attached to it, define
  the \emph{attachment index} of $e$ at $v$ as the index of edge $e$ relative
  to the cilium at $v$: if $\alpha$ is the attachment index of $e$ at
  $v$, then $\sigma_1^\alpha$ takes the cilium at $v$ onto $e$.
\end{definition}
The attachement index is unambiguously defined for all edges which are
not loops; therefore, in the following we shall slightly abuse the
definition and speak of the attachment index of an edge at a vertex.


\subsection{Edges}
\label{sec:edges}

An edge is represented by its two endpoints; each endpoint has the
form "(v, a)", where "v" is the index of the endpoint vertex
(within the fatgraph), and "a" is the index at which this edge
appears within vertex "v" (the attachment index).
\begin{lstlisting}
class Edge(object):
  """An edge of a fatgraph."""

  def __init__(self, va1, va2):
    if va1[0] < va2[0]:
      self.endpoints = (va1, va2)
    else:
      self.endpoints = (va2, va1)

\end{lstlisting}
Note that the "Edge.__init__" constructor requires the two
endpoints, that is, it should be invoked like: 
"e = Edge((0,1),(1,3))", passing the endpoints already as a Python tuple 
"(v,a)".  Also, "Edge" objects guarantee that endpoints are stored in
increasing vertex index order (line~63): therefore, if "e" is an "Edge"
object, then "e.endpoints[0] < e.endpoints[1]".

"Edge" objects bear no reference to a particular "Fatgraph" instance,
to allow sharing the same edge instance among "Fatgraph" instances that are
created by contraction or other geometrical operations.  In
particular, this implies that the numerical labels assigned to
edges must be recorded in the object representing the fatgraph, and
not in the "Edge" instance.

A few convenience methods are defined on "Edge" objects, to make for
clearer code.

The "Edge.is_loop" function returns "True" if applied to an
"Edge" object that represents a loop:
\begin{lstlisting}
  def is_loop(self):
    """
    Return `True` if this `Edge` instance 
    represents a looping edge.
    """
    return self.endpoints[0][0] == self.endpoints[1][0]
    
\end{lstlisting}

The "Edge.meets" function takes an "Edge" and a vertex index "v"
as input, and returns "True" if "v" is one of the endpoints:
\begin{lstlisting}
  def meets(self, v):
    """
    Return `True` if vertex `v` is one of the endpoints.
    """
    return (v==self.endpoints[0][0] or v==self.endpoints[1][0])

\end{lstlisting}

The "Edge.other_end" method takes as input an "Edge" instance, a
vertex index "v", and an attachment index "a" --- together, they
form an endpoint "(v, a)"; the function returns the other endpoint
of the given "Edge".  For instance, if "e=Edge((0,1),(1,3))"
then "Edge.other_end(e,0,1)" returns "(1,3)" and
"Edge.other_end(e,1,3)" returns "(0,1)"
\begin{lstlisting}
  def other_end(self, v, a):
    """Return the endpoint opposed to `(v, a)`."""
    if self.endpoints[0] == (v, a):
      return self.endpoints[1]
    else:
      return self.endpoints[0]

\end{lstlisting}


\subsection{Boundary Cycles}
\label{sec:boundary-cycles}

Boundary cycles are represented as cyclic sequences of ``corners'': a
corner consists of a vertex "v" and two consecutive indices "i", "j"
(in the cyclic order at "v") --- see Figure~\ref{fig:corners}. 
Although the two corners "(v, i, j)" and "(v, j, i)" are equal, the
Python code described in this section always creates triplets such that
either "j==i+1" or "i" and "j" are the ending and starting indices.
\begin{figure}
  \centering
  % rubber: make corners.pdf from corners.fig
  % rubber: make corners.eps from corners.fig
  \includegraphics{corners}
  \caption{Representation of fatgraph boundary cycles. \emph{Left:}
    corners around a vertex $a$. Note that the indices in the triple
    are attachment indices, i.e., displacement relative from the
    ciliated edge (the vertical one in this picture), thus they bear
    no relation to the labels on the edges (numbers on the light
    yellow background). \emph{Right:} How the boundary cycles are
    represented with corners: each boundary component is identified
    with the set of triples it encloses. Therefore the boundary cycles
    for the graph on the right are represented by the sets $\{(a,0,1),
    (b,2,0)\}$, $\{(a,1,2), (b,1,2)\}$, and $\{(a,2,0), (b,0,1)\}$}
  \label{fig:corners}
\end{figure}
It is easy to convince oneself that this is equivalent to the boundary
cycle definition in Section~\ref{sec:fatgraphs}.  Indeed, if $(X, \sigma_0,
\sigma_1, \sigma_2)$ is a fatgraph, then the boundary cycles are
defined as the orbits of $\sigma_2$ on the set of oriented edges
$X$. We could substitute an \emph{(edge, endpoint vertex)} pair for an
oriented edge, however, this is ill-defined for looping edges; to
distinguish the two endpoints of a loop we need to consider the
attachment index together with the endpoint vertex; but then, the
\emph{(endpoint vertex, attachment index)} pair suffices to completely
determine an oriented edge (given the ambient fatgraph).  The
additional successor index is added in the corner triple "(v,i,j)"
so that the action of $\sigma_2$ can be computed from corner data
alone, without any reference to the ambient fatgraph or the concerned
vertex (for computation efficiency reasons).

In particular, this representation based on ``corners'' allows one to
distinguish the boundary cycles made that comprises the same set of
edges: for instance, the boundary cycles of the fatgraph depicted in
Figure~\ref{fig:012012} are represented by the set of corners $\{(0, 2, 3),
(0, 4, 5), (0, 0, 1)\}$ and $\{(0, 1, 2), (0, 3, 4), (0, 5, 0)\}$.
\begin{figure}
  \centering
  % rubber: make 012012.eps from 012012.fig
  % rubber: make 012012.pdf from 012012.fig
  \includegraphics{012012}
  \caption{A ``pathologic'' fatgraph, whose two boundary cycles are
    comprised of exactly the same edges. They give rise to quite
    distinct sets of corners, though: $\{(0, 2, 3), (0, 4, 5), (0, 0,
    1)\}$ versus $\{(0, 1, 2), (0, 3, 4), (0, 5, 0)\}$.}
  \label{fig:012012}
\end{figure}

Two boundary cycles are equal if they comprise the same corners.
Thus, there is no reason to record the order in which the edges are
encountered when walking along a boundary cycles: the "BoundaryCycle"
objects can be just an alias for Python's built-in "frozenset"
class.\footnote{Class \l{frozenset} is the immutable variant of a
  \l{set}: \l{frozenset} objects cannot be modified after creation, on
  the other hand they can be used as keys in \l{dict} objects.  This
  is a feature that will be needed when defining a numbering on a
  fatgraph: the additional structure will be just a dictionary
  associating \l{BoundaryCycles} with an integer.}
\begin{lstlisting}
class BoundaryCycle(frozenset):
  """A boundary cycle of a Fatgraph."""

  # no change to the `frozenset` code
  pass 

\end{lstlisting}
A "BoundaryCycle" instance can thus be constructed by passing a
sequence of corners, represented as Python tuples "(v,i,j)", as in:
"BoundaryCycle([(1,1,2), (2,1,2)])".  Note that the vertex "v" is
referenced in each triplet by its index in the list of the ambient
fatgraph vertices.


\subsection{Fatgraphs}
\label{sec:fatgraphs}

The stage is now set for the introduction of a computable
representation of fatgraphs.  The class "Fatgraph" constructor takes a
list of "Vertex" objects; a typical line of code creating a "Fatgraph"
instance would be:
\begin{codexmp}
  g1 = Fatgraph( [ Vertex([2,0,1]), 
                   Vertex([2,1,0]) ] )
\end{codexmp}
Figure~\ref{fig:ctor} shows how a fatgraph is constructed out of the
data above.
\begin{figure}
  \centering
  % rubber: make ctor.eps from ctor.fig
  % rubber: make ctor.pdf from ctor.fig
  \includegraphics{ctor}
  \caption{Construction of a fatgraph out of a set of
    \l{Vertex} instances: half-edges tagged with the same
    (numeric) label are joined together to form an edge.}
  \label{fig:ctor}
\end{figure}

The "Fatgraph.__init__" constructor takes a list of vertices as the
only required parameter and computes data structures describing
the fatgraph.  In particular, for each fatgraph, we need to store:
\begin{itemize}
\item The list of vertices (as "Vertex" objects, therefore ciliated).
\item The adjacency list: for each edge, record the vertices it is
  attached to (this information is embedded in "Edge" objects).
\end{itemize}
Once these two are known, information about a vertex or an edge can be
retrieved just by a lookup in the list of vertices or the list of
edges.  Thus, the code within the "Fatgraph" class will always
identify a vertex with its index in the "self.vertices" list (e.g.,
this is the numeric tag used to identify a vertex in the triplets
representing boundary cycles ``corners''). Similarly, edges are
identified with their numeric label, which is also used as index in
the "self.edges" list.

The adjacency list can be computed from the complete list of "Vertex" objects:
therefore, the constructor of "Fatgraph" objects can take just the
list of vertices as the only needed parameter.  Any other
fatgraph-related data can be derived from the above two.  However, in
different parts of the code, the construction of a fatgraph can take
different routes, as there is different data to start with.
Thus, we allow supplying some of the internal data by means of an
additional "kwargs" argument for efficiency reasons (e.g., when a data
structure is already known to the caller, as is the case in the
"Fatgraph.contract" method).\footnote{This is a
  work-around for Python's lack of multiple constructors: The
  \l{kwargs} parameter is a way to assemble a \l{Fatgraph} object out of
  already-computed data, see, for instance, the \l{contract}
  method.}
\begin{lstlisting}
class Fatgraph(object):
  """A representation of a fatgraph."""

  def __init__(self, vertices, **kwargs):
    """
    Construct a `Fatgraph` instance, 
    taking list of vertices.
    """
\end{lstlisting}
The "self.vertices" instance attribute is initialized with the
"vertices" constructor argument:
\begin{lstlisting}
    # list of vertices
    self.vertices = vertices

\end{lstlisting}
The number of vertices is also recorded (in the "num_vertices"
attribute of each instance), for speed and clarity of coding:
\begin{lstlisting}
    # Number of vertices  
    self.num_vertices = len(vertices)

\end{lstlisting}

\subsubsection{Adjacency list.}
The total number of edges (stored in "num_edges") can be computed by
summing the valences of vertices.  It is needed to size the adjacency
list, so must be computed early:
\begin{lstlisting}
    # Number of edge colors
    self.num_edges = sum(len(v) for v in self.vertices) / 2)

\end{lstlisting}
The adjacency list (recorded in the attribute "self.edges") is computed
from the list of vertices as follows.  Note that the "edges" parameter
may be passed via the "kwargs" mechanism, in which case the
computation is skipped and the passed list is used as adjacency list.
\begin{lstlisting}
    if 'edges' in kwargs:
      self.edges = kwargs.get('edges')
    else:
      endpoints = [ [] for x in range(self.num_edges) ]
      for vertex_index in range(self.num_vertices):
        for (edge_index_in_vertex, edge) \
            in enumerate(self.vertices[vertex_index]):
          endpoints[edge].append( (vertex_index, edge_index_in_vertex) )
      # now wrap endpoints into "Edge" objects
      self.edges = [ Edge(*e) for e in endpoints ]

\end{lstlisting}
The code above walks the list of vertices (line~107), and then
iterates over the (half-)edges attached to each vertex (line~108):
each endpoint is recorded in the form of a 2-uple \emph{(index of
  endpoint vertex, attachment index)}. A list is used to temporarily
hold the endpoints (line~106); endpoints of the same edge shall be
kept together, at the same position in the list (line~110). Finally,
the list of endpoints is used to construct a list of "Edge" objects
(line~112).\footnote{The Python syntax \l{Edge(*e)} allows calling a
  function with a list of arguments only known at runtime; it is
  briefly explained in Section~\ref{sec:fn-special-syntax}.}

The algorithm to compute boundary cycles is complex enough to warrant
its own method "Fatgraph.compute_boundary_cycles()":
\begin{lstlisting}
    self.boundary_cycles = self.compute_boundary_cycles()
    self.num_boundary_cycles = len(self.boundary_cycles)

\end{lstlisting}

The fatgraph's genus is computed using Euler's formula $V-E+n = 2-2g$:
\begin{lstlisting}
    self.genus = (self.num_edges - self.num_vertices
          - self.num_boundary_cycles + 2) / 2

\end{lstlisting}
Finally, a few graph invariants are recorded, for quickly
checking when two graphs are not isomorphic: the (computationally
heavy) fatgraph isomorphism algorithm will only be run if all primary
invariants are equal.
\begin{lstlisting}
    # used for isomorphism testing
    self.invariants = (
        self.num_vertices,
        self.num_edges,
        self.num_boundary_cycles,
        )

\end{lstlisting}


\subsubsection{Orientation.}
According to Definition~\ref{dfn:orientation}, orientation is given by an
ordering of the edges (which directly translates into an orientation
of the associated orbifold cell).

We can keep track of the orientation by mapping edges into natural
numbers in the range $[0, E)$ (where $E$ is the total number of edges
in the graph).  Since edges are represented within the "Fatgraph"
class as natural numbers in the range $[0, E)$, we need just to create
a list, indexed by edge number, that associates each edge with its
position according to the order given by the orientation.  Two such
lists need to compare equal if they differ by an even permutation.

The "orientation" attribute must be overridden each time a "Fatgraph"
object is derived from another "Fatgraph" instance (lines~123--124): e.g., when an edge
is contracted, the resulting graphs must derive its orientation from
the ``parent'' graph, if we want the edge contraction to correspond to
taking cell boundary in the orbifold model.  When no previous
orientation is given, the easiest one is chosen: the order on the set
of edges is the one induced by the (numeric) edge labels (line~126).
\begin{lstlisting}
    if 'orientation' in kwargs:
      self.edge_numbering = kwargs.get('orientation')
    else:
      self.edge_numbering = list(range(self.num_edges))

\end{lstlisting}

The above code snippet concludes the "Fatgraph.__init__" constructor
code.

According to Definition~\ref{dfn:orientable}, a fatgraph is orientable iff it
has no orientation-reversing automorphism.  There is no
way to practically ascertain if a fatgraph is orientable other than
enumerating all automorphims:
\begin{lstlisting}
  def is_oriented(self):
    """Return `True` iff `Fatgraph` is orientable."""

    for a in self.automorphisms():
      if a.is_orientation_reversing():
        return False
    # no orientation-reversing automorphism found
    return True

\end{lstlisting}


\subsection{Computation of boundary cycles}
\label{sec:compute-boundary-cycles}

The computation of boundary cycles is separated from the object
initialization code for clarity and to make it easier to test the
algorithm.\footnote{Python features ``doctest'' (see
  \ref{sec:doctests}): one can embed short snippets of Python code in
  the docstring of a function, to check the output of the function
  against predefined inputs.  The test cases have been expunged from
  the listing presented here.}
\begin{lstlisting}
  def compute_boundary_cycles(self):
    """
    Return a list of boundary cycles of this `Fatgraph` object.
    """
    
\end{lstlisting}
First, build the collection of ``corners'' of "graph", structuring it
like the set of vertices: the "corners" variable is a list, the $n$-th
item of which is (again) a list holding the corners around the $n$-th
vertex (i.e., "self.vertices[n]"), in the order they are encountered
when winding around the vertex.  By construction, `corners[v][i]` has
the the form "(v,i,j)" where "j" is the index following "i" in the
cyclic order, i.e., it represents the corner formed by the
``incoming'' $i$-th edge and the ``outgoing'' $j$-th edge.
%\footnote{for this we rely on the properties of Python's
%  `{\protect\Verb|%|}' (modulus) operator: for positive $n$, 
%  $k${\protect\Verb|%|}$n$ evaluates to the smallest non-negative 
%  residue of $k \text{mod} n$.}
\begin{lstlisting}
    corners = [ [ (v, i, (i+1)%len(self.vertices[v]))
                  for i in range(len(self.vertices[v])) ]
                for v in range(self.num_vertices) ]

\end{lstlisting}

The algorithm closely follows a geometrical procedure: starting with
any one corner, follow its ``outgoing'' edge to its other endpoint,
and repeat until we come back to the starting corner.  The list of
corners so gathered is a boundary cycle.  At each iteration, the used
corners are cleared out of the "corners" list by replacing them with
the special value "None", so that we won't pick them up again in
susequent iterations.

An auxiliary function is needed, to find the smallest index in a list
"L" which is associated with a non-"None" value. 
\begin{lstlisting}
    def first_index_not_none(L):
        for index, item in enumerate(L):
            if item is not None:
                return index
        return None
    
\end{lstlisting}
Note the return value of "first_index_not_none" is "None" is all
elements in list "L" are "None".

To build all boundary cycles, we loop over the list of corners (line~148).

First, scan the "corners" list to find an index pair "(v,i)" pointing
to a valid corner triple (meaning an ``unused'' corner). The trick is
to loop over all indexes in the "corners" list, and quit looping as
soon as "corners[v][i]" is not "None" (line~\nr{bcy-quit-ffwd});
Python retains the value of "v" and "i" outside the loop.
\begin{lstlisting}
    result = [ ]
    while True:                                 |\n{bcy-main-loop}|
      # fast-forward to the first unused corner
      for v in xrange(self.num_vertices):
        i = first_index_not_none(corners[v])
        if i is not None:
          break                                 |\n{bcy-quit-ffwd}|

\end{lstlisting}
Exit loop if all corners in the list are "None": if the above loop
could not find any corner, then "v" will be the last valid index of
the "corners" list (i.e., "len(corners)-1") and "i" will be "None" (by
definition of the "first_index_not_none" function):
\begin{lstlisting}
      if v == len(corners)-1 and i is None:
        break

\end{lstlisting}
Now build a list of corners comprising the same boundary cycle: start
with the the corner "corners[v][i]", follow the edge starting at the
second delimiter of the corner to its other endpoint
(lines~\nr{bcy-follow1}--\nr{bcy-follow2} and~\nr{bcy-follow3}), and
repeat until we come back to the starting corner
(line~\nr{bcy-loop2}). At each iteration, the used corners are cleared
out of the "corners" list by replacing them with the special value
"None" (line~\nr{bcy-mark-used}).
\begin{lstlisting}
      start = (v,i)
      triples = [ ]
      while (v,i) != start or len(triples) == 0:         |\n{bcy-loop2}|
        triples.append(corners[v][i])
        j = corners[v][i][2]                           |\n{bcy-follow1}|
        next_edge = self.vertices[v][j]                |\n{bcy-follow2}|
        corners[v][i] = None                         |\n{bcy-mark-used}|
        (v,i) = self.edges[next_edge].other_end(v, j)  |\n{bcy-follow3}|
\end{lstlisting}
The list of such corners, accumulated into the "triples" variable, is
turned into a "BoundaryCycle" object:
\begin{lstlisting}
      result.append(BoundaryCycle(triples))

\end{lstlisting}
Once we're out of the `"while True"' loop (started at
line~\nr{bcy-main-loop}), the list of all "BoundaryCycle" objects
is returned to the caller:
\begin{lstlisting}
    return result
    
\end{lstlisting}


\subsection{Construction of new fatgraphs}
\label{sec:construction}

This section lists the methods implemented in the "Fatgraph" class to
create new graphs out of existing ones by applying concrete
topological constructions.

\subsection{Contraction of an edge}
\label{sec:contract}

Recall from the definition in Section~\ref{sec:contractions}) that
contraction produces a ``child'' fatgraph from a ``parent'' fatgraph
and a chosen regular (i.e., non-looping) edge. 

The "Fatgraph.contract" method thus needs only take as input the ``parent''
graph and the (label of) the edge to contract:
\begin{lstlisting}
  def contract(self, edge):
    """
    Return new `Fatgraph` obtained by contracting the specified edge.
    """

\end{lstlisting}

On the concrete fatgraph representations, the contraction algorithm
proceeds in the following way:
\begin{itemize}
\item Two vertices are merged into one. Thus the list of vertices of
  the ``child'' fatgraph (stored in the "new_vertices" variable) has
  one item less than the "self.vertices" list; we choose always to
  plug the higher-numbered vertex into the lower-numbered one, and to
  delete the higher-numbered one from the list.
\item Deletion of an edge also affects the orientation: the canonical
  orientation on the ``child'' fatgraph keeps the edges in the same
  order as they are in the parent fatgraph.  However, since
  "edge_numbering" must be a permutation of the edge indices, we need
  to renumber the edges and shift the higher-numbered edges down one
  place.
\item The new graph is constructed with the new vertices list and the
  derived orientation; the "Fatgraph" class constructor has the
  responsibility of computing the new adjacency list. 
\end{itemize}

The list of vertices of the ``child'' fatgraph is built by removing
the contracted edge and shifting all indices above:
\begin{itemize}
\item edges labeled 0 to "edge-1" are unchanged;
\item edge "edge" is temporarily kept intact, it will be
  removed by mating operation (see below);
\item edges labeled "edge+1" and above are renumbered, 
  shifting the number down one position.
\end{itemize}
This prescription is implemented through applying a mapping to every
element in the cyclic list representing a vertex.  Assuming $l$ is the
value of "edge", we make "renumber_edges" into a dictionary which
maps $i$ to $i$ for $i \leq l$, and $i$ to $i-1$ for $i > l$:
\begin{lstlisting}
    renumber_edges = { i:i 
                       for i in range(0, edge+1) }
    renumber_edges.update({ i:(i-1)
          for i in range(edge+1, self.num_edges) })
\end{lstlisting}
The above pattern will often be applied when constructing Python
"dict" objects: the dictionary is first constructed with one set of
mappings ($i \mapsto i$ for $0 \leq i < l$) and then another set of
mappings are added with the "update" method ($i \mapsto i-1$ for $l <
i < E$).

Then apply this transformation to the edge labels in each vertex, to
get the vertices of the ``child'' fatgraph. (This yields incorrect
values on the endpoints of "edge": they will be replaced shortly.)
\begin{lstlisting}
    new_vertices = [ Vertex([ renumber_edges[e] 
                              for e in V ])
                     for V in self.vertices ]

\end{lstlisting}

Assume "v1" and "v2" are the indices of the endpoint vertices of the
contracted edge, and that it appears at position "pos1" in the first
vertex and at "pos2" in the second (line~\nr{contract-1}).  Now mate
endpoints of the contracted edge:
\begin{enumerate}
\item Rotate endpoints "v1", "v2" so that the given edge "edge" would
  appear \emph{last} in "v1" and \emph{first} in "v2". (Note that, by
  construction of the "Edge" objects (Section~\ref{sec:edges}), we have 
  "v1 < v2".) This can be accomplished by operating on the list:
\begin{lstlisting}
    def rotated(L, p):
      # return a copy of list `L`, rotated rightwards `p` places.
      return L[p+1:] + L[:p]
\end{lstlisting}
  Since "v1", "v2" are \emph{cyclic}, we can rotate "v1" and "v2" in
  the same direction (lines~\nr{contract-2a} and~\nr{contract-2b}).
\item Join vertices by concatenating the list of incident
  edges (line~\nr{contract-3}).
\item Set the newly-constructed vertex in the place of old first
  endpoint within list "new_vertices" (line~\nr{contract-4}).
\item Remove the second endpoint from the list of new vertices
  (line~\nr{contract-5}).
\end{enumerate}
\begin{lstlisting}
    # get endpoints of the contracted edge
    ((v1,pos1), (v2,pos2)) = self.edges[edge].endpoints |\n{contract-1}|

    # the mated vertex is placed at index "v1"
    new_vertices[v1] = Vertex(                          |\n{contract-4}|
      rotated(new_vertices[v1], pos1)                   |\n{contract-2a}|
      +                                                 |\n{contract-3}|
      rotated(new_vertices[v2], pos2)                   |\n{contract-2b}|
      )

    # the old vertex at index "v2" is removed
    del new_vertices[v2]                                |\n{contract-5}|

\end{lstlisting}

The list of new vertices is all that is needed to form the new
``child'' fatgraph.  However, the ``child'' fatgraph inherits an
orientation from the ``parent'' fatgraph, which might differ from the
default orientation.  Therefore, an orientation has to be derived for
the ``child'' fatgraph: let $G$ be the ``parent'' fatgraph and
$\alpha_1, \ldots, \alpha_k, \ldots, \alpha_l$ its edges, with
$\alpha_k$ being contracted to create the ``child'' graph $G'$; if
$\alpha_{m(1)} < \alpha_{m(2)} < \ldots < \alpha_{m(l)}$ (with $m(j) = k$)
is the ordering on $E(G)$ that induces the orientation on $G$, then
$\alpha_{m(1)} < \ldots < \alpha_{m(j-1)} < \alpha_{m(j+1)} < \ldots
< \alpha_{m(l)}$ descends to a total order on the edges of $G'$ and
induces the correct orientation. (I.e., the orientation that
corresponds to the orientation induced on the cell $\Delta(G')$ as a
face of $\Delta(G)$.)

Orientation is represented in a "Fatgraph" instance as a list, mapping
edge labels to a position in the total order; using the notation
above, the orientation of $G$ would be represented by the map
$n := m^{-1}$.  The orientation on $G'$ is represented by $n'$ defined
as:
\begin{equation*}
  n'(i) :=
  \begin{cases}
    n(i)    &\text{if $n(i)<k$,} 
    \\
    n(i)-1  &\text{if $n(i)>k$.}
  \end{cases}
\end{equation*}
Correspondingly, the "new_edge_numbering" is built by shifting values
in the ``parent'' fatgraph's "edge_numbering" down one position if
they are follow the contracted edge in the orientation order:
\begin{lstlisting}
    k = self.edge_numbering[edge]

    # edges with index below the contracted one are untouched
    renumber_edge_numbering = { n:n for n in range(0,k) }
    # edges with index above the contracted one are shifted down
    # one position
    renumber_edge_numbering.update({ 
        (n+1):n for n in range(k, self.num_edges) 
    })

    new_edge_numbering = [ 
        renumber_edge_numbering[self.edge_numbering[n]]
            for n in range(0,self.num_edges)
            if n != edge 
    ]
    
\end{lstlisting}

The ``child'' fatgraph can finally be constructed, overriding the
default orientation:
\begin{lstlisting}
    return Fatgraph(new_vertices, 
                    orientation=new_edge_numbering)

\end{lstlisting}


\subsection{The map $q(G,x,y)$: bridging two edges of a fatgraph}
\label{sec:bridge}

The method "Fatgraph.bridge" implements the construction $q(G,x,y)$
described in Section~\ref{sec:addition}:
\begin{lstlisting}
  def bridge(self, edge1, side1, edge2, side2):
    """
    Return a new `Fatgraph`, formed by inserting trivalent
    vertices in the middle of edges `edge1` and `edge2` and
    connecting them with a new edge.
    """
\end{lstlisting}
This function must be symmetric: the pairs "edge1", "side1" and
"edge2", "side2" can be swapped and the result stays the same.

Arguments "side1" and "side2" control which side the new edge is
attached to (valid values are 0 or 1), i.e., which of the two
inequivalent cyclic orders the new trivalent vertices will be given.
In more detail: let "0", "1", "2" be the indices of the edges attached
to the new vertex in the middle of "edge1", where "0","1" denote the
labels assigned to the two halves of "edge1".  If "side1" is "0", then
the new trivalent vertex will have the cyclic order "[0,1,2]"; if
"side1" is "1", then the labels "0","1" are swapped and the new
trivalent vertex gets the cyclic order "[1,0,2]".

The construction involves 5 edges in total, 3 of which need new
labels. They will be stored in variables "connecting_edge",
"one_half1", "other_half1", "one_half2" and "other_half2".
\begin{lstlisting}
    # assign new edge indices
    connecting_edge = self.num_edges
\end{lstlisting}
Break "edge1" in two halves: one of them (see below for a precise
account) gets the old "edge1" label, the other needs a new one.
\begin{lstlisting}
    one_half1 = edge1
    other_half1 = self.num_edges + 1
\end{lstlisting}
Break "edge2" in two halves as well; if "edge2" is the same edge as
"edge1", then we are breaking the second half of "edge1" in
two parts.  Otherwise, proceed as above.  In any case, the
"other half" of "edge2" needs a new edge label.
\begin{lstlisting}
    if edge2 == edge1:
      one_half2 = other_half1
    else:
      one_half2 = edge2
    other_half2 = self.num_edges + 2

\end{lstlisting}
The list of edges for the new fatgraph can now be constructed, but the
endpoints for the new edges have to be filled in
later.\footnote{There's a ``chicken and egg'' issue: we need the
  new vertices to construct the endpoints, but we need the edge labels
  to construct the vertices.  So, the edge labels are assigned first,
  then vertices are constructed and then finally the new edge
  endpoints are created.\label{fn:chicken-and-egg}}
\begin{lstlisting}
    # three new edges are added (constructed below)
    new_edges = self.edges + [
      None, # new edge: "connecting_edge"
      None, # new edge: "other_half1"
      None, # new edge: "other_half2"
      ]
\end{lstlisting}

Two new vertices are also created: the mid-points of the connected
edges. Depending on the value of "side1" (resp.~"side2"), one of the
two inequivalent cyclic orders is chosen on the new vertex "midpoint1"
(resp.~"midpoint2").
\begin{lstlisting}
    # assign new vertex indices
    midpoint1_index = self.num_vertices
    midpoint2_index = self.num_vertices + 1

    if side1 == 1:                                   |\n{bridge-midpoints-1}|
      midpoint1 = Vertex([other_half1, one_half1, connecting_edge])
    else: # side2 == 0
      midpoint1 = Vertex([one_half1, other_half1, connecting_edge])

    if side2 == 1:
      midpoint2 = Vertex([other_half2, one_half2, connecting_edge])
    else: # side2 == 0
      midpoint2 = Vertex([one_half2, other_half2, connecting_edge])

    # two new vertices are added: the mid-points of the connected edges.
    new_vertices = self.vertices + [midpoint1, midpoint2]

\end{lstlisting}
Once the new vertices have been constructed, the "Edge" objects can
also.

The connecting edge has endpoints in the mid-points of
"edge1" and "edge2", and is always in third position.
\begin{lstlisting}
    new_edges[connecting_edge] = Edge((midpoint1_index, 2), (midpoint2_index, 2))

\end{lstlisting}
A couple of shortcut variables are introduced to make the code cleaner:
\begin{lstlisting}
    opposite_side1 = 0 if (side1==1) else 1
    opposite_side2 = 0 if (side2==1) else 1

\end{lstlisting}

Construct the two halves of "edge1": if "v1a" and "v1b" are the
endpoints of "edge1", then the "one_half" edge extends from the "v1a"
endpoint of "edge1" to the new vertex "midpoint1".  The "other_half"
edge extends from the "midpoint1" new vertex to "v1b"; if we are
bridging an edge with itself ("edge1 == edge2") then "other_half"
ends in "midpoint2" instead.
\begin{lstlisting}
    ((v1a, pos1a), (v1b, pos1b)) = self.edges[edge1].endpoints

    new_edges[one_half1] = Edge((v1a, pos1a), 
                                (midpoint1_index, side1))
    if edge1 != edge2:
      # replace "edge1" with new "other_half1" in the second endpoint
      new_vertices[v1b] = Vertex(new_vertices[v1b][:pos1b]
                         + [other_half1]
                         + new_vertices[v1b][pos1b+1:])
      new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), 
                                    (v1b, pos1b))
    else:                                                        |\n{bridge-other-half1-1}|
      # same edge, the `other half' ends at the second endpoint
      new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), 
                                    (midpoint2_index, side2))    |\n{bridge-other-half1-2}|

\end{lstlisting}
Note that, when replacing the second endpoint in vertex "v1b", we need
to construct a new "Vertex" object, since "Vertex" instances can be
shared among different "Fatgraph" instances.

Also note that "side1" and "side2" are used as attachment indices in
the code snippet above; this is due to the choice of the cyclic list
representatives when defining "midpoint1" and "midpoint2"
(line~\nr{bridge-midpoints-1} and following ones).

A similar construction is applied to "edge2": again we need to distinguish the special case when
"edge1" and "edge2" are the same edge.  When the two bridged edges are
different, then "one_half2" extends from
"v2a" to "midpoint2"; otherwise, "one_half2" and "other_half1" hold
the the same edge, and the endpoints of "other_half1" have already
been correctly set in lines~\nr{bridge-other-half1-1} to~\nr{bridge-other-half1-2}.
\begin{lstlisting}
    ((v2a, pos2a), (v2b, pos2b)) = self.edges[edge2].endpoints

    if edge1 != edge2:
      new_edges[one_half2] = Edge((v2a, pos2a), (midpoint2_index, side2))
    else:
      # "edge1 == edge2", so "one_half2" == "other_half1"
      pass # that is: "new_edges[one_half2] = new_edges[other_half1]"
\end{lstlisting}
The "other_half2", instead, always ends at the endpoint "v2b", so we
can unconditionally replace "edge2" for "other_half2" in "v2b".
\begin{lstlisting}
    new_vertices[v2b] = Vertex(new_vertices[v2b][:pos2b]
                       + [other_half2]
                       + new_vertices[v2b][pos2b+1:])
    new_edges[other_half2] = Edge((midpoint2_index, opposite_side2), (v2b, pos2b))

\end{lstlisting}

Orientation is inherited from the ``parent'' graph, adding the three
new edge labels in the order they were created:
\begin{lstlisting}
    new_edge_numbering = self.edge_numbering + \
               [connecting_edge, other_half1, other_half2]

\end{lstlisting}
Finally, the ``child'' graph can be built, overriding the default
orientation and the construction of the adjacency list (for
computational efficiency):
\begin{lstlisting}
    return Fatgraph(new_vertices,
            edges = new_edges,
            num_edges = self.num_edges + 3,
            orientation = new_edge_numbering,
            )

\end{lstlisting}


\subsection{The map $p(G,x)$: add a simple boundary cycle}
\label{sec:hangcircle}

The method "Fatgraph.bridge" implements the construction $q(G,x,y)$
described in Section~\ref{sec:addition}:
\begin{lstlisting}
  def hangcircle(self, edge, side):
    """
    Return a new `Fatgraph`, formed by attaching a circle with
    a new edge to a new trivalent vertex in the middle of `edge`.
    """
\end{lstlisting}
The implementation of "Fatgraph.hangcircle" is closely related to
"Fatgraph.bridge" (see Section~\ref{sec:bridge}): break "edge" in two
halves: if "v1" and "v2" are the endpoints of "edge", then the
"one_half" edge extends from "v1" to the new vertex "midpoint"; the
"other_half" edge extends from the new "midpoint" vertex to "v2".

In particular, argument `side` controls which side of "edge" the
circle is hung to (valid values are "0" or "1"), i.e., which of the
two inequivalent cyclic orders the new "midpoint" vertex will be
given.

The new graph will have 3 edges more than the original one, all of
which need new edge labels:
\begin{lstlisting}
    one_half = edge
    other_half = self.num_edges
    connecting_edge = self.num_edges + 1
    circling_edge = self.num_edges + 2
    
    new_edges = self.edges + [
      None, # new edge: "other_half"
      None, # new edge: "connecting_edge"
      None, # new edge: "circling_edge"
      ]
\end{lstlisting}
Endpoint data for the new edges can only be filled once the new
vertices have been constructed (see note~\ref{fn:chicken-and-egg} on
page~\pageref{fn:chicken-and-egg}).% or \thefootnote
%  http://anthony.liekens.net/index.php/LaTeX/MultipleFootnoteReferences

Two new vertices are added: the mid-point of "edge", and
the vertex "T" lying on the circle.
\begin{lstlisting}
    midpoint_index = self.num_vertices
    T_index = self.num_vertices + 1

    if side == 1:
      midpoint = Vertex([other_half, one_half, connecting_edge])
    else: # side == 0
      midpoint = Vertex([one_half, other_half, connecting_edge])

    T = Vertex([circling_edge, circling_edge, connecting_edge])
    new_vertices = self.vertices + [midpoint, T]

\end{lstlisting}

Break "edge" into two edges "one_half" and "other_half": we set the
new endpoints in the corresponding entries in "new_edges" and then
replace "edge" with "other_half" in the endpoint "v2":
\begin{lstlisting}
    ((v1, pos1), (v2, pos2)) = self.edges[edge].endpoints

    opposite_side = 0 if side else 1

    new_edges[one_half] = Edge((v1, pos1), 
                               (midpoint_index, side))
    new_edges[other_half] = Edge((midpoint_index, opposite_side), 
                                 (v2, pos2))

    new_vertices[v2] = Vertex(new_vertices[v2][:pos2]
                       + [ other_half ]
                       + new_vertices[v2][pos2+1:])

\end{lstlisting}

The connecting edge has endpoints in the mid-point of
"edge" and in "T", and is always in third position:
\begin{lstlisting}
    new_edges[connecting_edge] = Edge((midpoint_index, 2), 
                                      (T_index, 2))

\end{lstlisting}

The circling edge is a loop with vertex "T":
\begin{lstlisting}
    new_edges[circling_edge] = Edge((T_index, 0), 
                                    (T_index, 1))

\end{lstlisting}

Orientation is inherited from the ``parent'' graph, adding the three
new edge labels in the order they were created:
\begin{lstlisting}
    new_edge_numbering = self.edge_numbering + \
               [other_half, connecting_edge, circling_edge]

\end{lstlisting}

Finally, the ``child'' graph can be built, overriding the default
orientation and the construction of the adjacency list (for
computational efficiency):
\begin{lstlisting}
    return Fatgraph(new_vertices,
            edges = new_edges,
            num_edges = self.num_edges + 3,
            orientation = new_edge_numbering,
            )
\end{lstlisting}


\subsection{Fatgraphs isomorphism and equality testing}
\label{sec:isomorphism}

The isomorphism problem on computer representations of fatgraphs
consists in finding out when two distinct "Fatgraph" instances
represent isomorphic fatgraphs (in the sense of
Definition~\ref{dfn:fatgraphs}) or even the same fatgraph.  Indeed,
the procedure for associating a "Fatgraph" instance to a fatgraph (see
Section~\ref{sec:fatgraphs}) involves labelling all edges, choosing a
starting edge (cilium) on each vertex and enumerating all vertices in
a certain order; for each choice, we get a different "Fatgraph"
instance representing the same (abstract) fatgraph.

\begin{definition}
  An isomorphism of "Fatgraph" objects "G1" and "G2" is a triple 
  "(pv, rot, pe)" where:
  \begin{itemize}
  \item "pv" is a permutation of ther vertices: the "i"-th vertex of
    "G1" is sent to the "pv[i]"-th vertex of "G2", rotated by "rot[i]"
    places leftwards;
  \item "pe" is a permutation of the edge labels: edge label "i" in
    "G1" is mapped to the edge label "pe[i]" in "G2".
  \end{itemize}
  The adjacency relation must be conserved by isomorphism triples: if
  "i" and "j" are the indices (within "G1.vertices") of endpoint
  vertices of the edge "k", then "pv[i]" and "pv[j]" must be the
  indices of endpoint vertices of edge "pe[k]" in "G2".
\end{definition}
Since a vertex in a "Fatgraph" instance is plainly the list of labels
of edges attached to that vertex, we can dually state the
compatibility condition above as requiring that, for any index "i"
into the list "G1.vertices" and any valid index "j" into
"G1.vertices[i]", we have:
\begin{equation}
  \label{eq:fg-iso}
  \text{\protect\Verb'G2.vertices[pv[i]][j+rot[i]] == pe[G1.vertices[i][j]]'}
\end{equation}
The above Formula~\eqref{eq:fg-iso} makes the parallel between "Fatgraph" object
isomorphisms and fatgraph maps (in the sense of
Definition~\ref{dfn:fatgraphs}) explicit.

\begin{definition}
  Let $v$ be a vertex of a fatgraph $G$.  A neighborhood $U$ of $v$ is
  \emph{small} iff it is contractible and no other vertex of $G$ lies
  in $U$.
\end{definition}
\emph{Note:} by a slight abuse of language, whenever ``vertex'' is
mentioned in the following, a small neighborhood of the 0-cell (the
vertex, proper) is really meant.

\begin{lemma}
  Let $G_1$, $G_2$ be fatgraphs, represented respectively by "G1" and
  "G2". Every isomorphism of fatgraphs $f: G_1 \to G_2$ induces a
  corresponding isomorphism "f = (pv, rot, pe)" on the computer
  representations. Conversely, every triple "(pv, rot, pe)"
  representing an isomorphism between the "Fatgraph" instances can be
  lifted to a (possibly trivial) fatgraph isomorphism between $G_1$
  and $G_2$.
\end{lemma}
\begin{proof}
  Every isomorphism $f: G_1 \to G_2$ naturally induces bijective maps
  $f_V: V(G_1) \to V(G_2)$ and $f_E: E(G_1) \to E(G_2)$ on vertices
  and edges.  When vertices are ciliated, $f_V$ determines (and is
  completetely determined by) a permutation on the set of vertices
  (which vertex maps to which one) and the set of displacements of the image of the
  cilium in the source vertex with respect to the
  cilium of the target vertex.  Similarly, $f_E$ determines a
  bijective mapping of edge labels, and is completely determined by
  it.  This is exactly the data collected in the triple "(pv, rots, pe)", 
  and the compatibility condition~\eqref{eq:fg-iso} holds by
  construction.

  Conversely, assume we are given a triple "(pv, rots, pe)",
  representing an isomorphism of "Fatgraph" instances.  We can
  construct a map $f_V$ between vertices of $G_1$ and vertices of
  $G_2$ as follows: map the vertex of $G_1$ corresponding to the
  "i"-th vertex in "G1.vertices" to the vertex of $G_2$ corresponding
  to the "pv[i]"-th vertex in "G2.vertices"; the mapping is such that
  the image of cilium of the "i"-th source vertex is displaced
  "rot[i]" positions from the cilium of the target vertex.  The map
  $f_V$ can be glued to a global map $f: G_1 \to G_2$ if and only if
  the adjacency relation is preserved; this is guaranteed by the
  compatibility condition~\eqref{eq:fg-iso}.
\end{proof}

The general isomorphism problem for (ordinary) graphs is a well-known
difficult problem. However, the situation is much simpler for
fatgraphs, because of the following property.
\begin{lemma}[Rigidity Property]\label{lemma:rigidity}
  Let $G_1$, $G_2$ be \emph{connected} fatgraphs, and $f: G_1 \to G_2$
  an isomorphism.  For any vertex $v \in V(G_1)$, and any small
  neighborhood $U$ of $v$, $f$ is uniquely determined (up to an
  homotopy fixing the vertices of $G$) by its restriction to $U$.
\end{lemma}
In particular, an isomorphism of graphs with ciliated vertices is
completely determined once the image $w=f(v)$ of a vertex $v$ is
known, together with the displacement (relative to the cyclic order at
$w$) of the image of the cilium of $v$ with respect to the cilium of
the image vertex $w$.
\begin{proof}
  Let $w = f(v)$; it is clear that $W = f(U)$ is a small neighborhood
  of $w$.  Consider $f$ as CW-complex morphism: $f = (f_0, f_1)$ where
  $f_i$ is a continuous map on the set of $i$-dimensional cells.

  Given $f|_U$, incrementally construct a CW-morphism $f': G_1 \to
  G_2$ as follows. Set $f'_0(v) = w$, then for each edge $x$ attached
  to $v$, let:
  \begin{itemize}
  \item $v'_x$ be the other endpoint of $x$,
  \item $x' = f_1(x)$,
  \item $w'_{x'}$ be the other endpoint of $x'$.
  \end{itemize}
  Since $f$ preserves the adjacency relation, we have $w'_{x'} =
  f_0(v'_x)$; therefore the following assignments extend $f'$ in a way
  that it still preserves adjacency relations and coincides with $f$
  on its definition domain:
  \begin{itemize}
  \item $f'_0(v'_x) = w'_x$,
  \item $f'_1(x) = f_1(x)$.
  \end{itemize}

  A simple connectedness argument proves that this procedure extends
  $f'$ to a CW-morphism that agrees with $f$ on all of $G_1$.
\end{proof}

The stage is now set for presenting the algorithm to enumerate the
fatgraph isomorphisms between two given instances.
\begin{lstlisting}
  def isomorphisms(G1, G2):
    """
    Iterate over `Fatgraph` isomorphisms from `G1` to `G2`.
    """
\end{lstlisting}
If there are no isomorphisms connecting the two graphs, then no
item is returned by the iterator.

As this procedure is quite complex, we break it into a
number of auxiliary functions.

The auxiliary function "valence_spectrum", given a "Fatgraph" instance
"G", returns a mapping (Python "dict" object) that associates to each
valence the list of indices (within "G.vertices") of vertices with
that valence.
\begin{lstlisting}
    def valence_spectrum(G):
      result = defaultdict(list)
      for (index, vertex) in enumerate(G.vertices):
        l = len(vertex)
        result[l].append(index)
      return result

\end{lstlisting}

Similarly, the function "vertex_valences" returns the set of all
valences of vertices in fatgraph "G":
\begin{lstlisting}
  def vertex_valences(G):
    return frozenset(len(v) for v in G.vertices)
\end{lstlisting}

For each pair $(n, L)$ in the valence spectrum, call \emph{intensity}
the product $n \cdot L$ (valence times the number of vertices with
that valence).  The function "starting_vertices" returns the pair that
minimizes intensity.
\begin{lstlisting}
    def starting_vertices(G):
      val = max(vertex_valences(G))
      vs = None
      n = len(G.vertices)+1
      for (val_, vs_) in valence_spectrum(G).items():
        n_ = len(vs_)
        if (n_*val_ < n*val) \
             or (n_*val_ == n*val and val_<val):
          val = val_
          vs = vs_
          n = n_
      return (val, vs)

\end{lstlisting}

The function "compatible" returns boolean "True" iff vertices "v1" and
"v2" have the same valence and number of loops.  (This is used as a
short-cut test to abandon a candidate mapping before trying more
computationally expensive full adjacency list extension.)
\begin{lstlisting}
    def compatible(v1, v2):
      if len(v1) == len(v2) and v1.num_loops == v2.num_loops:
        return True
      else:
        return False
        
\end{lstlisting}
Function "compatible_vertices" iterates over (indices of)
vertices in "G" that are compatible with "v" (i.e., which "v" could be
mapped to). Third argument "ixs" restricts the search to a given
subset of vertex indices in "G".
\begin{lstlisting}
    def compatible_vertices(v, G, ixs):
      for index in ixs:
        if compatible(v, G.vertices[index]):
          yield index

\end{lstlisting}

The "CannotExtendMap" exception is used for error reporting by the
"extend_map" function (see below); its code is just Python idiomatic
way of creating a new custom error.
\begin{lstlisting}
    class CannotExtendMap(Exception):
      """
      Exception raised by `extend_map` on failure
      to extend a partial map.
      """
      pass

\end{lstlisting}

The following "extend_map" function alters the given "(pv,rots,pe)"
triple by adding a mapping of the "i1"-th vertex of "G1" into the
"i2"-th vertex of "G2" (and rotating the target vertex by "r" places
rightwards).  If the extension is successful, it returns the extended
map "(pv, rot, pe)"; otherwise an exception "CannotExtendMap" is
raised.  A partial map is represented by a triple "(pv,rot,pe)" (just
as a "Fatgraph" isomorphism), with the additional proviso that
unassigned items in "rot" are represented by "None".
\begin{lstlisting}
    def extend_map(pv, rots, pe, G1, i1, r, G2, i2):
      v1 = G1.vertices[i1]
      v2 = G2.vertices[i2]
      if not compatible(v1, v2):
        raise CannotExtendMap

      # rotation "r" has to be $\geq 0$ for the "[r:r+...]" shift below to work
      if r < 0:
        r += len(v2)

\end{lstlisting}
If vertex index "i1" already has a mapping according to "pv", then
check whether the target is the same one that is currently being
added: if yes, there is nothing more to do and the function can return
immediately; if not, signal error condition "CannotExtendMap" to
caller:
\begin{lstlisting}
      if pv.has_key(i1):
        if pv[i1] != i2 or (rots[i1]-r)%len(v2) != 0:
          raise CannotExtendMap
        else:
          return (pv, rots, pe)

\end{lstlisting}
Check that the "pe" mapping of edge-labels can be extended by mapping
labels of edges from "v1" to edges of "v2" (rotated rightwards "r"
places).  Informally, the "pe.extend" function tries to alter "pe" so
that labels of corresponding edges in "v1" and "v2" are mapped one to
the other; more precisely, the label of the cilium at "v1" is mapped
to the label of the cilum at "v2", the label of the successor is
mapped to the label of the successor, and so on.  The function
"pe.extend" returns "None" if "pe" could not be extended according to
this procedure; in this case "extend_map" raises a "CannotExtendMap"
exception again.
\begin{lstlisting}
      v2 = v2[r:r+len(v2)]
      if not pe.extend(v1, v2):
        raise CannotExtendMap
\end{lstlisting}
Note that the Python object "v2" (alias for "G2.vertices[i2]") is
modified \emph{in place}; however, due to the cyclical invariance of
the fatgraph vertices, this does not change the (abstract) fatgraph
that "G2" represents.

Finally, since all compatibility checks have passed, add the mapping
to "pv" and "rots" and return modified triple:
\begin{lstlisting}
      pv[i1] = i2
      rots[i1] = r
      return (pv, rots, pe) # end of "extend_map"

\end{lstlisting}

\begin{definition}
  Define a \emph{vertex-to-vertex} mapping as a triplet
  "(src,dst,rot)", where:
  \begin{itemize}
  \item "src" is the index of a vertex in "G1", connected to "v1" by
    an edge "x";
  \item "dst" is the index of a vertex in "G2", connected to "v2" by
    the image (according to "pe") of edge "x";
  \item "rot" is the rotation to be applied to "G1[src]" so that edge
    "x" and its image appear at the same index position.
  \end{itemize}
\end{definition}

The following function "neighbors" lists vertex-to-vertex mappings
that extend map "pv" in the neighborhood of given vertices "v1" (in
the domain fatgraph "G1") and "v2" (in the codomain fatgraph "G2").
It returns a list of triplets "(src,dst,rot)", each representing a
vertex-to-vertex mapping.

The "neighbors" algorithm is implemented by looping over the edges at
vertex "v1" (line~\nr{neighbors:1}): for each edge "x", the variable
"src_v" stores the vertex index of the endpoint of "x" different from
"v1" (line~\nr{neighbors:3}), and "src_a" stores the attachment index
of "x" at this other vertex (line~\nr{neighbors:5}). Looping edges are
ignored (line~\nr{neighbors:2}), as well as vertices that have already
been added to "pv" (line~\nr{neighbors:4}).  Similarly, the ``other''
endpoint and the attachment index of the image of "x" are stored in
variables "dst_v" and "dst_a" (line~\nr{neighbors:6}).  Finally, the
rotation needed in mapping "v1" onto "v2" so that "x" and its image
edge appear at the same attachment index is computed as difference
between "dst_a" and "src_a" (line~\nr{neighbors:7}).
\begin{lstlisting}
    def neighbors(pv, pe, G1, v1, G2, v2):
      result = [ ]
      for x in G1.vertices[v1]:                      |\n{neighbors:1}|
        if G1.edges[x].is_loop():                    |\n{neighbors:2}|
          continue # with next edge "x"
        ((s1, a1), (s2, a2)) = G1.edges[x].endpoints 
        src_v = s2 if (s1 == v1) else s1             |\n{neighbors:3}|
        if src_v in pv:                              |\n{neighbors:4}|
          continue # to next "x"
        src_a = a2 if (s1 == v1) else a1             |\n{neighbors:5}|
        ((d1, b1), (d2, b2)) = G2.edges[pe[x]].endpoints
        (dst_v,dst_a) = (d2,b2) if (d1 == v2) else (d1,b1) |\n{neighbors:6}|
        result.append((src_v, dst_v, dst_a-src_a))   |\n{neighbors:7}|
      return result  # end of "neighbors"
      
\end{lstlisting}

The main algorithm for enumerating isomorphisms can now be described.

Since the isomorphism computation is implemented as an exhaustive
search, it is worth doing a few trivial checks to rule out simple
cases (for efficiency reasons):
\begin{lstlisting}
    vs1 = valence_spectrum(G1)
    vs2 = valence_spectrum(G2)
    # if graphs differ in vertex valences, no isomorphisms
    if not set(vs1.keys()) == set(vs2.keys()):
      return # StopIteration
    # if graphs have unequal vertex distribution by valence, no isomorphisms
    for val in vertex_valences(G1):
      if len(vs1[val]) != len(vs2[val]):
        return # StopIteration

\end{lstlisting}

By the rigidity lemma~\ref{lemma:rigidity}, any fatgraph isomorphism
is uniquely determined by the mapping of a small neighborhood of any
vertex.  The overall strategy of the algorithm is thus to pick a pair
of ``compatible'' vertices and try to extend the map as in the proof
of of lemma~\ref{lemma:rigidity}.  This isomorphisms enumeration
algorithm has thus quadratic complexity in the number of
vertices:\FIXME{Example of fatgraph where the upper bound is actually
  attained??} for each pair of same-valence vertices and for each
rotation displacement (up to the valence), an attempt to map one onto
the other needs to be made.  

Since an isomorphism is uniquely determined by its restriction to
\emph{any one} vertex, one can restrict to considering just pairs of
the form $(v_1, v_2)$ where $v_1$ is one chosen vertex in $G_1$.  The
chosen starting vertex $v_1$ should be selected so to minimize the
number of mapping attempts performed; this is currently done by
minimizing the product of valence and number of vertices of that
valence on $G_2$ (line~\nr{iso:1}), and then picking a random vertex
of the chosen valence in $G_1$ as $v_1$
(line~\nr{iso:2}):\footnote{The checks already performed ensure that
  \Verb`G1` and \Verb`G2` have the same ``valence spectrum'', so
  \Verb`G1` has at least one vertex of the chosen valence.}
\begin{lstlisting}
    (valence, indexes) = starting_vertices(G2)            |\n{iso:1}|
    v1_index = vs1[valence][0]                            |\n{iso:2}|
    v1 = G1.vertices[v1_index]
\end{lstlisting}
Then the algorithm tries all possible ways of mapping $v_1$ into a
compatible vertex $v_2$ in $G_2$:
\begin{lstlisting}
    for v2_index in compatible_vertices(v1, G2, indexes):   |\n{iso:v-loop}|
      for rot in range(valence):                          |\n{iso:rot-loop}|
\end{lstlisting}
The body of the inner loop mimicks the construction in the proof
of Lemma~\ref{lemma:rigidity}.  First, given a target vertex $v_2$ and a
rotation "rot", a new triple "(pv,rots,pe)" is created and set to
represent the initial mapping of (a small neighborhood of) $v_1$ to (a
small neighborhood of) $v_2$:
\begin{lstlisting}
        try:                                             |\n{iso:try-start}|
          pv = Permutation()
          rots = [ None for x in range(G1.num_vertices) ]
          pe = Permutation()

          pv[v1_index] = v2_index
          rots[v1_index] = rot
          if not pe.extend(v1, G2.vertices[v2_index][rot:rot+valence]):
            continue # to next `rot`

\end{lstlisting}
The invocation to "pe.extend" may fail if the edge labels on $v_1$ and
$v_2$ (rotated by "rot") do not match, in which case execution jumps to
the next candidate "rot".
Elements in "rots" are initialized to the special value "None", as
required by the contract of function "extend_map".

The mapping defined by "(pv,rots,pe)" is finally extended to neighbors
of the vertices already inserted:
\begin{lstlisting}
          nexts = neighbors(pv, pe, G1, v1_index, G2, v2_index)  |\n{iso:3}|
          while len(pv) < G1.num_vertices:
            neighborhood = [ ]
            for (i1, i2, r) in nexts:                            |\n{iso:4}|
              (pv, rots, pe) = extend_map(pv, rots, pe, G1, i1, r, G2, i2)
              neighborhood += neighbors(pv, pe, G1, i1, G2, i2)  |\n{iso:5}|
            nexts = neighborhood                           |\n{iso:try-end}|

\end{lstlisting}
Indeed:
\begin{itemize}
\item The variable "nexts" is initially loaded with a list of all
  possible mappings of a vertex adjacent to $v_1$ onto a vertex
  adjacent to $v_2$ (line~\nr{iso:3}).  Recall that "neighbors" does
  not include any vertices that already appear in "pv" into its
  output.
\item For any such mapping, an attempt is made to extend the current
  "(pv,rots,pe)"; if the mapping to be added conflicts with some
  mapping already stored, then an exception "CannotExtendMap" is
  raised, and execution continues at line~\nr{iso:except}.
\item Neighbors of the newly-added vertex pair are appended to the
  "neighborhood" list (lines~\nr{iso:4}--\nr{5}).
\item The contents of "neighborhood" are used to load the variable
  "nexts" just before the subsequent iteration.
\end{itemize}
If any "extend_map" failed in the above block (between
lines~\nr{iso:try-start} and~\nr{iso:try-end}), then start again at
line~\nr{iso:rot-loop} with the next "rot":
\begin{lstlisting}
        except CannotExtendMap:                             |\n{iso:except}|
          continue # to next "rot"

\end{lstlisting}

If the execution flow ever reaches this point, then the current
"(pv,rots,pe)" triple represents a bijective map on the vertices and
edges, which preserves the adjacency relations.  It is thus an
isomorphism and we can construct an "Isomorphism" object from
it\FIXME{ref!} and return to the caller function:
\begin{lstlisting}
        yield Isomorphism(G1, G2, pv, rots, pe)                |\n{iso:end}|
        # end of "Fatgraph.isomorphism"

\end{lstlisting}
Note that it is perfectly normal for the execution flow to never reach
line~\nr{iso:end}: indeed, the double loop at lines
\nr{iso:v-loop}--\nr{iso:rot-loop} tries several possible candidate
mappings, but only few of them (possibly none!) is a isomorphism.

When the loop started at line~\nr{iso:v-loop} is over, execution
reaches the end of the "isomorphisms" function, signalling the end of
the iteration.

Given the "Fatgraph.isomorphism" enumeration algorithm, it is trivial
to provide a method for computing all automorphisms of a fatgraph:
\begin{lstlisting}
  def automorphisms(self):
    return self.isomorphisms(self)

\end{lstlisting}
Unfortunately, there is no shortcut to computing the cardinality of
the automorphism group, other than explicitly computing all the
automorphisms and counting them:
\begin{lstlisting}
  def num_automorphisms(self):
    return len(list(self.automorphisms()))

\end{lstlisting}

A comparison "G1 == G2" between two "Fatgraph" instances is internally
translated by Python into a call to the following
"Fatgraph.__eq__(G1,G2)" method.  The "__eq__" method shall return
"True" when the two "Fatgraph" instances being compared are
isomorphic, and "False" otherwise.
\begin{lstlisting}
  def __eq__(G1, G2):
    """Return `True` if `G1` and `G2` are isomorphic."""

\end{lstlisting}
Comparison of a few invariants is attempted before invoking the
computationally heavy "isomorphism" method:
\begin{itemize}
\item if "G1" and "G2" are variables aliasing the same Python object,
  then we can quickly assert equality:
\begin{lstlisting}
    if G1 is G2:                       |\n{fgeq:01}|
      return True
\end{lstlisting}
\item if basic invariants do not compare equal, then the two fatgraphs
  are not isomorphic and the function ends early:
\begin{lstlisting}
    if G1.invariants != G2.invariants: |\n{fgeq:02}|
      return False

\end{lstlisting}
\end{itemize}
Otherwise, we have to go the long way and try to find an explicit
isomorphism between "G1" and "G2".  Since we are not interested in the
actual isomorphism, we just try getting one (the "next()" method
invocation on line~\nr{fgeq:1}): if we succed, the isomorphisms exists
and we return a positive answer to the equality question; else, Python
signals a "StopIteration" exception to indicate that there are no
results from the "isomorphism" iterator (line~\nr{fgeq:2}): so there
are no isomorphisms between the given graphs and we can only return
"False":
\begin{lstlisting}
    try:
      # if there is any morphism, then return "True"
      Fatgraph.isomorphisms(G1,G2).next()     |\n{fgeq:1}|
      return True
    except StopIteration:                     |\n{fgeq:2}|
      # list of morphisms is empty, objects are not equal.
      return False

\end{lstlisting}
Python's object comparison protocol states that a "__ne__" method
should be provided, for inequality comparisons "G1 != G2"; in this
case, "__ne__" just returns the opposite of "__eq__":
\begin{lstlisting}
  def __ne__(G1, G2):
    return not Fatgraph.__eq__(G1, G2)
\end{lstlisting}


\subsection{Complementary methods}
\label{sec:complementary}

This section briefly lists those methods of the "Fatgraph" class that
are needed for proper working of the class, but do not have any
special interest by themselves.

Mathod "assimilate" modifies a "Fatgraph" instance to be exactly equal
to another given instance; after a call into "assimilate", attributes
of both "Fatgraph"s will point to the same Python objects.  The only
use of this call will be evident later on: we will need to create a
"NumberedFatgraph" instance and make it a clone of an existing
un-numbered "Fatgraph".
\begin{lstlisting}
  def assimilate(self, other):
    """
    Copy-constructor: make `self` equal to `other`.
    """
    self.boundary_cycles = other.boundary_cycles
    self.edges = other.edges
    self.edge_numbering = other.edge_numbering
    self.genus = other.genus
    self.num_boundary_cycles = other.num_boundary_cycles
    self.num_edges = other.num_edges
    self.num_vertices = other.num_vertices
    self.vertices = other.vertices
    self.invariants = (
        self.num_vertices,
        self.num_edges,
        self.num_boundary_cycles,
        )

\end{lstlisting}


\subsubsection{Orbits under automorphisms}
The "edge_orbits" function computes orbits of the edges under the
action of graph automorphism group, and a representative for each
orbit.  It returns a Python dictionary, whose keys are the
representatives, and whose values are the orbits.  Orbits are
represented as Python "set" objects.
\begin{lstlisting}
  def edge_orbits(G):
    """
    Compute orbits of the edges under the action of graph
    automorphism group, and a representative for each orbit.
    """
\end{lstlisting}
The orbit set is constructed progressively: we start with "orbits"
holding a map of each edge $x$ into the singleton set $\{x\}$
(line~\nr{orbits:1}). Then, for each automorphisms $a \in \Aut(G)$,
the image $y = a(x)$ is computed (line~\nr{orbits:2}|); if $y$ is
in the repsentative set, then the orbits of $x$ and $y$ are merged
into one (line~\nr{orbits:3}), with the edge with lower numerical
label being kept as representative.  The guard conditions at
lines~\nr{orbits:4} and~\nr{orbits:5} are there just for efficiency:
if an edge is not in the (current) representative set, or its image is
not, then their orbits have already been computed and computation
should proceed.
\begin{lstlisting}
    orbits = { x:set([x]) for x in range(G.num_edges) }  |\n{orbits:1}|
    for a in G.automorphisms():                          
      for x in range(G.num_edges):
        if x not in orbits:                              |\n{orbits:4}|
          continue # with next "x"
        y = a.pe[x]                                      |\n{orbits:2}|
        if y not in orbits:                              |\n{orbits:5}|
          continue # with next "x"
        # "x" and "y" are in the same orbit, only keep the one
        # with lower abs. value, and remove the other.
        if y > x:
          orbits[x].update(orbits[y])                    |\n{orbits:3}|
          del orbits[y]
    return orbits

\end{lstlisting}

The "edge_pair_orbits" function works exactly like "edge_orbits",
except the action of $\Aut(G)$ on the cartesian square $E(G) \times
E(G)$ is computed instead.  Apart from little formal differences, the
algorithm works exactly the same.
\begin{lstlisting}
  def edge_pair_orbits(self):
    """
    Compute orbits of pairs `(edge1, edge2)` under the action
    of graph automorphism group, and a representative for each
    orbit.
    """
    edge_pairs = [ (x,y) 
             for x in range(self.num_edges)
             for y in range(self.num_edges) ]
    orbits = { (p, set([p])) for p in edge_pairs }
    for a in self.automorphisms():
      for p in edge_pairs:
        if p not in orbits:
          continue
        q = (a.pe[p[0]], a.pe[p[1]])
        if q not in orbits:
          continue
        if p < q:
          orbits[p].update(orbits[q])
          del orbits[q]
    return orbits

\end{lstlisting}


\subsubsection{Printed representation.}
On "Fatgraph" objects, both "__repr__" and "__str__" return the
same string, i.e., the constructor invocation with the vertex list,
which is guaranteed to produce an isomorphic "Fatgraph" instance.
\begin{lstlisting}
  def __repr__(self):
    return "Fatgraph(%s)" % repr(self.vertices)
  
  def __str__(self):
    return repr(self)

\end{lstlisting}


\subsection{Isomorphism objects}
\label{sec:iso}

The following "Isomorphism" class defines common operations that one
expects to perform with fatgraph isomorphisms.
\begin{lstlisting}
class Isomorphism(object):
  """
  An isomorphism of `Fatgraphs`.
  """
\end{lstlisting}
Five parameters are passed to the constructor: the domain
and codomain fatgraphs (named "source" and "target" in the code) and
the tripe "(pv,rots,pe)" used to represent a fatgraph isomorphism in
the "Fatgraph.isomorphisms" method.  The "__init__" method does
nothing more than saving these values for later reference:
\begin{lstlisting}
  def __init__(self, source, target, pv, rot, pe):
    self.source = source
    self.target = target
    self.pe = pe
    self.rot = rot
    self.pv = pv

\end{lstlisting}

The "compare_orientations" function returns +1 or -1 depending on
whether the orientations of the target Fatgraph pulls back to the
orientation of the source "Fatgraph" via the "self" "Isomorphism"
instance.
\begin{lstlisting}
  def compare_orientations(self):
    image_edge_numbering = Permutation(
      (self.source.edge_numbering[x], self.target.edge_numbering[self.pe[x]])
                                        for x in range(self.source.num_edges)
    )
    return image_edge_numbering.sign()

\end{lstlisting}

Function "is_orientation_reversing" returns boolean true iff the
"self" isomorphism reverses orientation on the "source" and "target"
fatgraphs: 
\begin{lstlisting}
  def is_orientation_reversing(self):
    return (-1 == self.compare_orientations())

\end{lstlisting}

The "transform_boundary_cycle" method is used when comparing
\emph{numbered} fatgraphs: as the numbering is a function on the
boundary cycles, we need to know exactly which boundary cycle of the
target graph corresponds to a given boundary cycle in the source
graph.  Recall that "BoundaryCycle" instances are defined as list of
\emph{corners}; function "transform_boundary_cycle" takes a
"BoundaryCycle" and returns a new "BoundaryCycle" instance, obtained
by transforming each corner according to a graph isomorphism.
\begin{lstlisting}
  def transform_boundary_cycle(self, bcy):
    triples = [ ]
\end{lstlisting}
Indeed, "transform_boundary_cycle" is straightforward loop over the
corners making up the given boundary cycle "bcy":
For each corner "(v,i,j)", a new one is constructed by transforming
the vertex index according to map "pv", and displacing indices "i" and
"j" by the rotation amount indicated by "rot" (modulo the number of
edges attached to the given vertex):
\begin{lstlisting}
    for (v, i, j) in bcy:
      l = len(self.source.vertices[v])
      v_ = self.pv[v]
      i_ = (i + self.rot[v]) % l
      j_ = (j + self.rot[v]) % l
\end{lstlisting}
The "BoundaryCycle" constructor guarantees that index "j" in
a corner is the successor to index "i" according to the cyclic order
at "v", so an extra check needs to be done to accomodate the case
where we end up with "i==l" and "j==0" by the above rotation:
\begin{lstlisting}
      # ensure the contract is honored, that `j` is the
      # index following `i` in the cyclic order
      if i_ == 0 and j_ == l:
        i_, j_ = j_, i_
      triples.append((v_, i_, j_))
\end{lstlisting}
Finally, a new "BoundaryCycle" object is constructed with the list of
new triples:
\begin{lstlisting}
    return BoundaryCycle(triples, self.target)
    # end of "transform_boundary_cycle"
  # end of "Isomorphism" class
\end{lstlisting}


\section{A framework for computing homology}
\label{sec:homology}

Before proceeding to the computation of Betti numbers of the numbered
fatgraph complex $\R_{g,n}$, we present a small framework for computing
homology (over $\setQ$) of any differential complex $(W_*, d_*)$, given a
basis of the graded vector space $W_*$.  This abstract setting lends
itself to a particularly simple implementation; homology computations
of $\R_{g,n}$ will follow as a particular case.

The Betti numbers of a complex $(W_*, d_*)$ can be reckoned (via a
little linear algebra) from the matrix form $D_k$ of the boundary
operators $d_k$.  In order to compute the matrices $D_k$, we need to
compute the coordinate vector of $d_ke^{(k)}_j$ for all vectors
$e^{(k)}_j$ in a basis of $W_k$.

The "VectorSpace" class provides a method to compute the coordinate
vector, w.r.t. a given basis, of any linear combination of elements of
that basis.
\begin{lstlisting}
class VectorSpace(object):
    """
    Represent the vector space freely generated 
    by the given `base` vectors.
    """
\end{lstlisting}
A "VectorSpace" object is constructed out of a list\footnote{To be
  precise: from any Python sequence that supports \Verb'len' and
  \Verb'index' operators with the same semantics as \Verb'list'
  objects.} of basis elements; any Python object can be a basis
element, as long as it can be used as a dictionary key and is distinct
from all other basis elements.
\begin{lstlisting}
    def __init__(self, base):
        """Constructor, taking list of base vectors."""
        self.base = base

\end{lstlisting}
The dimension of the vector space is available via the "dimension"
method, which just returns the number of basis elements:
\begin{lstlisting}
    def dimension(self):
        return len(self.base)

\end{lstlisting}

A linear combination (of vectors in the given basis) is represented
with a Python sequence of pairs "(v,c)" where "v" is a basis vector
and "c" is a coefficient.  A given vector "v" may appear in several
pairs. 

The "coordinates" method returns a (sparse) coordinate vector of the
given linear combination.  The sparse coordinate vector is implemented
as a Python "defaultdict":  it associates an index $n$ with the
coefficient of the $n$-th basis vector; any vector not appearing in
the linear combination will have the default coefficient $0$.
\begin{lstlisting}
    def coordinates(self, combo):
        """Return the (sparse) coordinate vector of "combo"."""
        coordinates = defaultdict(lambda: 0) 
        for (vector, coefficient) in iter(combo):
            coordinates[self.base.index(vector)] += coefficient
        return coordinates
    # end of class "VectorSpace"

\end{lstlisting}

The "ChainComplex" class represents a (finite) chain complex over
$\setQ$, and provides methods to compute the ranks of the homology
modules.

A "ChainComplex" instance "C" of length $l+1$ comprises vector spaces
"C.module[i]" and differentials "C.differential[i]"; the "i" index
runs from "0" to $l$.  

Creating a "ChainComplex" instance requires only the complex length as
parameter; differentials and vector spaces are initially set to null.
(In othe words, "ChainComplex(l)" creates the null chain complex $0
\to 0 \to \cdots \to 0$.)
\begin{lstlisting}
class ChainComplex(object):
    """Represents a (finite-length) chain (homology) complex."""

    def __init__(self, length):
        """Create a chain complex of specified length."""
        self.length = length
        self.module = length * [ VectorSpace() ]
        def null_differential(vector):
          return [ ] # null linear combination
        self.differential = length * [ null_differential ]

\end{lstlisting}
A "ChainComplex" instance must be initialized by assigning
"VectorSpace" instances into each "C.module[i]" (for "i" in the range
$0 \ldots l$), and appropriate maps into "C.differential[i]" (with "i"
ranging from 1 to $l$).  Each "C.module[i]" represents the degree "i"
slice of the graded vector space "C".  The map "C.differential[i]"
sends (linear combinations of) elements in vector space "C.module[i]"
to linear combinations of vectors in "C.module[i-1]".

The following example Python code builds a "ChainComplex" object that
computes the homology of a closed interval:
\begin{codexmp}
  C = ChainComplex(2)
  C.module[1] = VectorSpace(['a'])
  C.module[0] = VectorSpace(['b0', 'b1'])
  C.differential[1] = lambda a: [('b0',1), ('b1', -1)]
\end{codexmp}
The variable "C" is initialized with a "ChainComplex" of length 2,
thus comprising "VectorSpace" instances "C.module[1]" (generated by
the unique 1-dimensional cell, here represented by the Python string
"'a'"), and "C.module[0]" (generated by two 0-dimensional cells,
represented by Python strings "'b0'" and "'b1'").  The unique
non-trivial differential "C.differential[1]" is set to the map $a
\mapsto b_0 - b_1$, sending the unique 1-cell into the difference of
the two 0-cells.


The method "compute_homology_ranks" returns a list of integers: item
at index "n" is the rank of the "n"-th homology module of a chain
complex.  Since the chain complex has finite length, homology group
indices can only run from 0 to the length of the complex (all other
groups being, trivially, null).
\begin{lstlisting}

    def compute_homology_ranks(C):
        """Compute and return (list of) homology group ranks."""

\end{lstlisting}
The ranks of the boundary operators are accumulated into a list
"ranks".  The "compute_boundary_operators" method returns an list of
triplets "(A, ddim, cdim)" where "A" is the matrix form of a boundary
operator, "ddim" is the dimension of its domain, and "cdim" the
dimension of the codomain; i.e., if "A" is the matrix form of
differential $d_i: C_i \to C_{i-1}$, then "ddim" is $\dim C_i$ and
"cdim" is $\dim C_{i-1}$.
\begin{lstlisting}
        ranks = [ ]
        bds = C.compute_boundary_operators()
        for (A, ddim, cdim) in bds:
            ranks.append(A.rank())

\end{lstlisting}
The objects representing matrices have a "rank()" method that computes
the rank.  Algorithms for computing the rank of matrices are
well-known\FIXME{reference!} and fast implementations are available in
the form of programming libraries; on these grounds, no implementation
of the "rank" function is given here, the production version of the
program used the freely-available LinBox C++ library\FIXME{reference!}
for representing matrices and computing their rank. However, except
for trivial cases (very small $g,n$), computation of the rank is the
most time-consuming part of the whole algorithm.

Computing the Betti numbers is now just a matter of basic linear algebra.
By the rank-nullity theorem, if $A:V\to W$ is a linear map,
then $\dim\Ker(A) =  \dim(V) - \rk(A)$; hence, if $d_i: C_i \to
C_{i-1}$ is the $i$-th differential, $Z_i = \Ker(d_i)$ and $B_i =
d_i(C_i) \subseteq C_{i-1}$, then:
\begin{align*}
  \dim(Z_i) &= \dim\Ker(d_i) = \dim(C_i) - rk(d_i) 
  \\
  \dim(B_i) &= \rk(d_{i+1})
\end{align*}
Therefore:
\begin{equation*}
  \dim(H_i) = \dim(Z_i / B_i) = \dim(Z_i) - \dim(B_i)
            = \dim(C_i) - \rk(d_i) - \rk(d_{i+1}).
\end{equation*}
The above formula can be simultanously applied to all indices $i$
using Python's ``list comprehension'' syntax:
\begin{lstlisting}
        ranks.append(0) # augment complex with the null map.
        return [ (C.module[i].dimension() - ranks[i] - ranks[i+1])
                 for i in range(C.length)) ]
        # end of "compute_homology_ranks"

\end{lstlisting}

A method to compute the matrix form of the boundary operators $d_i$ is
the only missing piece for the generic homology framework:
\begin{lstlisting}
    def compute_boundary_operators(C):
        """Compute and return matrix form of boundary operators."""

\end{lstlisting}
The "compute_boundary_operators" function returns a list of
"SimpleMatrix" instances.  

The "SimpleMatrix" class is just an interface to the matrix storage
provided by the C++ library LinBox\FIXME{reference!}.  LinBox provides
a optimized function library for linear algebra on matrices with
entries in $\setZ$, $\setQ$ or a finite field.  Since computation of
the rank is the most time-consuming part of the whole algorithm, and
linear algebra algorithms have been extensively
studied,\FIXME{reference!} we shall not present the implementation of
"SimpleMatrix" here, nor discuss in detail how the functionality of
LinBox is used.  

It suffices to describe the methods of "SimpleMatrix" that are
actually used:
\begin{itemize}
\item The constructor "SimpleMatrix(p,q)" that returns a $p \times q$
  matrix with null entries.
\item The method "A.addToEntry(i,j,c)" that adds (integer) "c" to the
  entry on row "i" and column "j" of matrix "A".
\item The method "A.rank()" that returns the rank of matrix "A".
\end{itemize}

Contrary to usual notation, we stipulate that the matrix form of
boundary operators operates on \emph{column} vectors: the "i"-th
differential "D[i]" is "dim C.module[i-1]" rows (range) by "dim
C.module[i]" columns (domain).

The body of "compute_boundary_operators" is quite straightforward: a
list "D" is created to hold the result, and initialized with a null
matrix (corresponding to the differential $d_0: C_0 \to 0$); for each
degree of the complex, a matrix "d_i" is constructed, such that the
entry at the $k$-th column and $j$-th row of "d_i" contains the
component of $de^{(i)}_j$ w.r.t. the $k$-th basis vector $e^{(i-1)}_k$
of $C_{i-1}$.
\begin{lstlisting}
        NullMatrix = SimpleMatrix(0,0)
        D = [ ]                                           |\n{bds:1}|
        D.append( (NullMatrix, 0, C.module[0].dimension()) )
        for i in range(1, C.length):
            d_i = SimpleMatrix(C.module[i-1].dimension(),
                               C.module[i].dimension())
            for j in range(C.module[i].dimension()):
                for (k, c) in C.module[i-1].coordinates(C.differential[i](C.module[i].base[j])).items():
                    d_i.addToEntry(k, j, c)
            D.append( (d_i, C.module[i-1].dimension(), 
                          C.module[i].dimension()) )
        return D

\end{lstlisting}


\section{The homology complex of numbered fatgraphs}
\label{sec:homology-numbered-fatgraphs}

The code in the previous section, while perfectly working, is not
efficient in the case of fatgraphs, as the inner loop of method
"compute_boundary_operators" is executed once for each graph, and has
to perform several costly lookups in "C.base" to find out the
coordinate vector of $de^{(i)}_j$.  In the case of the complex $W_*$
of orientable fatgraphs, we can take a shortcut: if two topological
fatgraphs $G$ and $G'$ are not isomorphic, so are any two numbered
fatgraphs $(G,\nu)$ and $(G',\nu')$.  There are $n! / |Aut(G)|$
numbered fatgraphs per given topological fatgraph $G$, so this
approach can cut the complexity down by a factor of $O((n!)^2)$.

Recall that a numbered fatgraph automorphism $a: (G,\nu) \to (G,\nu)$
must satisfy the following diagram:
\begin{equation*}
  \xymatrix{%
    \Holes{G} &  & \Holes{G}
    \\
    & &
    \\
    & \{ 1, \ldots, n \} &
    \ar^{\Holes{a}} "1,1";"1,3"
    \ar_{\nu} "1,1";"3,2"
    \ar_{\nu} "1,3";"3,2"
  }%
\end{equation*}
Therefore $\Holes{a} = \id_{\Holes{G}}$, i.e., $a$ induces the
identity map on the boundary cycles of $G$.

Let $(G, \nu_0)$ be a chosen numbered fatgraph.  Define a group
homomorphism $\Phi: \Aut(G) \ni a \mapsto \nu_0 \comp \Holes{a} \comp
\nu_0^{-1} \in \Sym{n}$; then $P = \Phi(\Aut G)$ is a subgroup of
$\Sym{n}$.
\begin{lemma}
  There is a bijective correspondence between (isomorphism classes of)
  numbered fatgraphs over the same underlying topological fatgraph $G$
  and cosets of $P$ within $\Sym{n}$.
\end{lemma}
\begin{proof}
  Let $\sigma \in \Sym{n}$ be such that $\sigma P = P$; then there
  exist $a, a' \in \Aut G$ such that:
  \begin{equation*}
    \sigma \comp \nu_0 \comp \Holes{a'} \comp \nu_0^{-1}
    = \nu_0 \comp \Holes{a} \comp \nu_0^{-1}
  \end{equation*}
  whence:
  \begin{equation*}
    (\sigma \comp \nu_0) \comp \Holes{a' \comp a^{-1}} \comp
    \nu_0^{-1} = \id
  \end{equation*}
  therefore $a' \comp a^{-1}$ is a numbered fatgraph isomorphism
  between $(G, \nu)$ and $(G, \sigma \comp \nu)$.

  Viceversa, assume $(G, \nu_0)$ and $(G, \nu_1)$ are isomorphic as
  numbered fatgraphs: then there exists $a \in \Aut G$ such that
  $\nu_1 \comp \Holes{a} \comp \nu_0^{-1}$ is the identity on
  $\Sym{n}$.  Let $\sigma = \nu_0 \comp \nu_1^{-1}$; given any $P \ni
  \pi = \nu_0 \comp \Holes{a'} \comp \nu_0^{-1}$ we have:
  \begin{multline*}
    \nu_0 \comp \Holes{a'} \comp \nu_0^{-1} 
    = (\nu_0 \comp \nu_1) \comp \nu_1^{-1} \comp (\nu_1 \comp
      \Holes{a} \comp \nu_0^{-1}) \comp \nu_0 \comp \Holes{a^{-1} \comp
      a'} \comp \nu_0^{-1}
    = (\nu_0 \comp \nu_1) \comp \nu_1^{-1} \comp \nu_0 \comp
      \Holes{a^{-1} \comp a'} \comp \nu_0^{-1}
    \in \sigma P,
  \end{multline*}
  therefore $P = \sigma P$.
\end{proof}

Crucial to this is the representation of numbered fatgraphs
(cf.~\ref{sec:numbered-rg}).  
A numbered fatgraph can be constructed
from a "Fatgraph" instance (called the \emph{underlying graph}) and a
numbering (i.e., a bijective map assigning an integer to each boundary
components of the underlying graph).
The ``numbering'' is represented with a Python dictionary mapping a
"BoundaryCycle" instance "bcy" to the integer "n".

\begin{lstlisting}
class NumberedFatgraphPool(object):
    """An immutable virtual collection of "NumberedFatgraph"s.
    Items are all distinct (up to isomorphism) decorations of a
    "Fatgraph" instance "graph" with a numbering of the boundary
    cycles.

    Implements object lookup by index and iteration over the whole list.

       
    Note that, when only one numbering out of many possible ones is
    returned because of isomorphism, the returned numbering may not be
    the trivial one (it is infact the first permutation of 0..n
    returned by "InplacePermutationIterator")::

    When the graph has only one boundary component, there is only one
    possible numbering, which is actually returned::
    """
    def __init__(self, graph):
        bc = graph.boundary_cycles
        n = len(bc) # == graph.num_boundary_cycles
        orientable = True

        ## Find out which automorphisms permute the boundary cycles among
        ## themselves.
        P = []  #: permutation of boundary cycles induced by "a \in Aut(G)"
        P_ = [] #: corresponding graph automorphisms: "P[i]" is induced by "P_[i]"
        automorphisms = [] # numbered fatgraph automorphisms
        for a in graph.automorphisms():
            p = Permutation()
            for src in range(n):
                dst_cy = a.transform_boundary_cycle(bc[src])
                try:
                    dst = bc.index(dst_cy)
                except ValueError:
                    # "dst_cy" not in "bc"
                    break # continue with next "a"
                p[src] = dst
            if len(p) != n: # not all "src" were mapped to a "dst"
                continue # with next "a"
            if p.is_identity():
                # "a" preserves the boundary cycles pointwise,
                # so it induces an automorphism of the numbered graph
                automorphisms.append(a)
                if a.compare_orientations() == -1:
                    orientable = False
            if p not in P:
                # "a" induces permutation "p" on the set "bc"
                P.append(p)
                P_.append(a)

        ## There will be as many distinct numberings as there are cosets
        ## of "P" in $\Sym n$
        if len(P) > 1:
            def unseen(candidate, P, already):
                """
                Return "False" iff any of the images of "candidate" by an
                element of group "P" is contained in set "already".
                """
                for p in P:
                    if p.rearranged(candidate) in already:
                        return False
                return True
            numberings = []
            for candidate in InplacePermutationIterator(range(n)):
                if unseen(candidate, P, numberings):
                    numberings.append(copy(candidate))
        else:
            # if "P" is the one-element group, then all orbits are trivial
            numberings = [ copy(p) for p in InplacePermutationIterator(range(n)) ]

        # things to remember
        self.graph = graph
        self.is_orientable = orientable
        self.P = P
        self.P_ = P_
        self.numberings = numberings
        self.num_automorphisms = len(automorphisms)


    def __len__(self):
        return len(self.numberings)


    def facets(self, edge, other):
        """Iterate over facets obtained by contracting "edge" and
        projecting onto "other".

        Each returned item is a triple "(j, k, s)", where:
          - "j" is the index of a "NumberedFatgraph" in "self";
          - "k" is the index of a "NumberedFatgraph" in "other";
          - "s" is the sign by which "self[j].contract(edge)" projects onto "other[k]".
        Only triples for which "s != 0" are returned.

        Examples::
        
          >>> p0 = NumberedFatgraphPool(Fatgraph([Vertex([1, 2, 0, 1, 0]), Vertex([3, 3, 2])]))
          >>> p1 = NumberedFatgraphPool(Fatgraph([Vertex([0, 1, 0, 1, 2, 2])]))
          >>> list(NumberedFatgraphPool.facets(p0, 2, p1))
          [(0, 0, 1), (1, 1, 1)]
        """
        def push_fwd(f, g1, g2):
            """Return a "Permutation" instance corresponding to the
            map induced by ismorphism "f" on the boundary cycles, or
            "None" if no such map exists.

            Indeed, there are cases (see examples in the
            "Fatgraph.__eq__" docstring), in which the
            "Fatgraph.isomorphisms" algorithm may find a valid
            mapping, changing from "g1" to an *alternate*
            representation of "g2" - these should fail as they don't
            preserve the boundary cycles.
            """
            result = Permutation() #: map induced by "f" on boundary cycles
            for (src, bc1) in enumerate(g1.boundary_cycles):
                bc2 = f.transform_boundary_cycle(bc1)
                try:
                    result[src] = g2.boundary_cycles.index(bc2)
                except KeyError:
                    return None
            return result

        def compute_nb_map(pull_back_bcy_map, src, dst):
            """
            Return a pair of "dict" instances:
              - the first maps (indices of ) numberings in
                "NumberedFatgraphPool" instance "src" to corresponding
                (indices of) numberings in "NumberedFatgraphPool"
                instance "dst".

              - the second maps the same indices into the
                automorphism "a" of "dst.graph" such that::

                  src.numberings[i] = pull_back(<permutation induced by a applied to> dst.numberings[i])

            Raises "KeyError" if no such mapping could be found.

            Indices must be "int"s here, as "list"s cannot be used as
            dictionary keys.
            """
            nb_map = dict()
            a_map = dict()
            for (i, nb) in enumerate(src.numberings):
                (i_, k) = dst._index(pull_back_bcy_map(nb))
                nb_map[i] = i_
                a_map[i] = k
            return (nb_map, a_map)

        g0 = self.graph
        g1 = g0.contract(edge)
        g2 = other.graph
        assert len(g1.boundary_cycles) == len(g2.boundary_cycles)
        
        ## 1. compute map induced on "g0.boundary_cycles" from the
        ##    graph map "f0" which contracts "edge".
        (e1, e2) = g0.endpoints(edge)
        f0_push_fwd = Permutation(enumerate(
            g1.boundary_cycles.index(g0.contract_boundary_cycle(bcy, e1, e2))
            for bcy in g0.boundary_cycles
            ))

        ## 2. compute isomorphism map "f1" from "other.graph" to "self.graph.contract(edge)";
        ##    if there is no such isomorphisms, then stop iteration.
        ##    The reason for having this map go in the opposite direction as "f0"
        ##    is to avoid inverting its push-forward.  (Thus saving a little complexity.)

        # if there is no isomorphism from "g2" to "g1", the "for" loop
        # down here will not run, so we need a way to detect that a
        # valid isomorphism has been found.
        f1_found = False
        for f1 in Fatgraph.isomorphisms(g2, g1):
            f1_push_fwd = push_fwd(f1, g2, g1)
            if f1_push_fwd is None:
                continue # with next isomorphism
            # now check that every numbering of "g0" can be mapped to
            # a numbering on "g2" through the composite map "f1^(-1) * f0"
            def pull_back(nb): return f1_push_fwd.rearranged(f0_push_fwd.inverse().rearranged(nb))
            try:
                nb_map, a_map = compute_nb_map(pull_back, self, other)
            except KeyError:
                continue # with next isomorphism
            # if we got to this point, the "f1" is a graph
            # automorphism that induces a map on the boundary cycles
            f1_found = True
            break # correct "f1" found
        if not f1_found:
            # no isomorphism between "g1" and "g2", stop here.
            raise StopIteration

        ## For every numbering "nb" on "g0", compute the (index of)
        ## corresponding numbering on "g2" (under the composition map
        ## "f1^(-1) * f0") and return the triple "(index of nb, index of
        ## push-forward, sign)".
        for (j, nb) in enumerate(self.numberings):
            k = nb_map[j]
            a = a_map[j]
            ## there are three components to the sign "s":
            ##   - the sign given by the ismorphism "f1"
            ##   - the sign of the automorphism of "g2" that transforms the
            ##     push-forward numbering into the chosen representative in the same orbit
            ##   - the alternating sign from the homology differential
            s = f1.compare_orientations() \
                * a.compare_orientations() \
                * minus_one_exp(g0.edge_numbering[edge])
            yield (j, k, s)

    def _index(self, numbering):
        """
        """
        for (i, p) in enumerate(self.P):
            try:
                j = self.numberings.index(p.rearranged(numbering))
                # once a "p" has matched, there's no reason to try others
                return (j, self.P_[i])
            except ValueError:
                pass # ignore errors if "p" is not included in "self.numberings"
\end{lstlisting}

The overall purpose of "NumberedFatgraphPool" objects is to not
enumerate numbered fatgraphs explicitly, but rather take advantage of
the similar properties that all numbered fatgraphs with the same
underlying topological fatgraph have, to aggregate them into a single
lump.   The "VectorSpace" class previously introduced requires a basis
to be spelt out in full, so we need to provide a specialized version
that knows that a single "NumberedFatgraphPool" instance may actually
represent several numbered fatgraphs.  

The "dimension" method must thus be corrected: the number of
generators of the vector space is the total number of numbered
fatgraphs, i.e., each "NumberedFatgraphPool" must contribute for the
total number of numbered fatgraphs it aggregates (gotten by the Python
"len" operator):
\begin{lstlisting}
class MgnVectorSpace(VectorSpace):
    """A vector space with a basis of `NumberedFatgraphPool` elements."""
    def dimension(self):
        return sum(len(pool) for pool in self.base)

\end{lstlisting}
If we were using the naive "compute_homology_ranks" method provided by
the "ChainComplex" class, we would need to override also the
"coordinate" method to account for the use of "NumberedFatgraphPool"
aggregates in the basis; the following specialized "MgnChainComplex"
class uses a (slightly) different "compute_boundary_operator"
algorithm which renders this unneeded.

\begin{lstlisting}
class MgnChainComplex(ChainComplex):
    """A specialized "ChainComplex"."""
    def __init__(self, length):
        ChainComplex.__init__(self, length)
        for i in range(length):
            self.module[i] = AggregateList()

    def compute_boundary_operators(C):
        #: Matrix form of boundary operators; the "i"-th differential
        #: "D[i]" is "dim C[i-1]" rows (range) by "dim C[i]" columns
        #: (domain).
        m = C.module # micro-optimization
        D = DifferentialComplex()
        D.append(NullMatrix, 0, len(m[0]))
        for i in range(1, len(C)):
            p = len(m[i-1]) # == dim C[i-1]
            q = len(m[i])   # == dim C[i]
            d = SimpleMatrix(p, q)
            j0 = 0
            for pool1 in m[i]:
                k0 = 0
                for pool2 in m[i-1]:
                    for edgeno in range(pool1.graph.num_edges):
                        if pool1.graph.is_loop(edgeno):
                            continue # with next "edgeno"
                        for (j, k, s) in NumberedFatgraphPool.facets(pool1, edgeno, pool2):
                            d.addToEntry(k+k0, j+j0, s)
                    k0 += len(pool2)
                j0 += len(pool1)
            D.append(d, p, q)
        return D

\end{lstlisting}

\section{Putting it all together}
\label{sec:algorithm-finale}

Everything is now set for presenting the final piece of code, that
uses all the classes and functions defined so far to actually compute
the Betti numbers of the homology complex of numbered fatgraphs.

The following "FatgraphComplex" function returns an "MgnChainComplex"
instance, populated with all orientable numbered fatgraph of the given
genus "g" and number of boundary cycles "n".  
\begin{lstlisting}
def FatgraphComplex(g, n):
    """
    Return the fatgraph complex for given genus "g" and number of
    boundary components "n".
    """
\end{lstlisting}
The maximum number of edges is reached in graphs with all vertices
tri-valent, so, combining Euler's formula with $3V = 2E$, we
get: $E = 6g + 3n - 6$.  These are also graphs corresponding
to top-dimensional cells.
\begin{lstlisting}
    top_dimension = 6*g + 3*n - 6

\end{lstlisting}
Construction of the complex of numbered fatgraphs is
straightforward: a null complex is initialized and stored in the
variable "C" (line~\nr{finale:1}); then a loop is run over all the
graphs in $\R_{g,n}$ (lines~\nr{finale:2}--\nr{finale:6}); for each of
the topological fatgraphs, a corresponding numbered fatgraph pool is
created (line~\nr{finale:3}) and immediately discarded if none of the
numbered fatgraphs in it is orientable
(lines~\nr{finale:4}--\nr{finale:5}); finally, orientable numbered
graphs are aggregated to the degree $E-1$ vector space of the complex
"C" (line~\nr{finale:6}).
\begin{lstlisting}
    C = MgnChainComplex(top_dimension)      |\n{finale:1}|
    for graph in MgnGraphsIterator(g,n):    |\n{finale:2}|
        pool = NumberedFatgraphPool(graph)  |\n{finale:3}|
        if not pool.is_orientable:          |\n{finale:4}|
            continue # with next "graph"    |\n{finale:5}|
        grade = graph.num_edges - 1
        C.module[grade].aggregate(pool)     |\n{finale:6}|
        
    return C # end of "FatgraphComplex"
\end{lstlisting}

Computing homology ranks is then just a matter of invoking the method
"compute_homology_ranks()" on the resulting complex "C":
\begin{lstlisting}
(g, n) = (2, 1)
C = FatgraphComplex(g,n)
print (C.compute_homology_ranks())
\end{lstlisting}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 
