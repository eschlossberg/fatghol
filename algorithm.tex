
\chapter{An algorithm for computing graph homology}
\label{chap:algorithm}

This chapter presents an algorithm to compute homology of the fatgraph
complex $\R_{g,n}$.  By \csref{thm:fatgraph-homology}, this is
tantamount to the (co)homology with rational coefficients of the
moduli spaces $\M_{g,n}$. An effective computer implementation of the
algorithm is presented, which is capable of computing the Betti
numbers of $\M_{g,n}$ for $(2g+n) < 6$ on standard desktop-class
hardware.  The size of the fatgraph complex increases factorially with
$2g+n$, so a parallel algorithm is needed to compute the Betti numbers
of $\M_{g,n}$ for $(2g+n) \geq 6$; this will be the subject of a later
chapter.

Generators of the homology modules could be computed with a little
variant in the last step of the algorithm; however, this is not
interesting in connection with the homology of $\M_{g,n}$, since
expression of a fatgraph homology class in terms of algebro-geometric
classes has proved to be a difficult problem 
\cite{mondello:2004,
  igusa:combinatorial-miller-morita-mumford-classes-and-witten-cycles,
  igusa:graph-cohomology-and-kontsevich-cycles},
and to-date lacks a general solution.

The Python programming language is used in this chapter to articulate
the algorithm.  Python claims to be ``executable pseudo-code'',
combining a readable and ``natural'' syntax that makes it well suited
to teaching programming to novices \cite{georgatos:python}, with the
power of a general-purpose language that is presently in daily use for
several real-world applications (see, e.g., \cite{python:success}).
The advantage is clear: the code listed in this chapter can be copied
to a Python file and actually executed.  For the reader's convenience,
\csref{chap:python} recaps the Python syntax and briefly explains the
constructs and idioms used in programming this algorithm.


\section[Overview]{Overview of the algorithm}
\label{sec:overview}

\csref{thm:fatgraph-homology} provides an effective way to compute the
(co)homology of $\M_{g,n}$.  The Betti numbers of $\M_{g,n}$ can be
computed from the knowledge of the dimension of chain spaces $W_p$ and
the ranks of the boundary operators $D_p$; this can effectively be
accomplished in the following stages:
\begin{enumerate}[I.]
\item Compute the basis set of $W_*$; by definition, the basis set is
  the set of \emph{orientable} fatgraphs indexing
  the cells of $\Mcomb_{g,n}$.
\item Work out the differential $D: W_* \to W_*$ in an
  effectively computable way, i.e., as matrix operators $D_p$ mapping
  coordinates in the fatgraph basis of $W_p$ into coordinates
  w.r.t. the fatgraph basis of $W_{p-1}$.
\item Compute the ranks of the matrices $D_p$.
\end{enumerate}

Stage~I needs just the pair $g,n$ as input; its output is the set of
orientable numbered fatgraphs belonging in $\R_{g,n}$: the core of
Stage~I is an algorithm to enumerate the fatgraph of given genus and
number of boundary cycles. By definition, numbered fatgraphs are
decorated abstract fatgraphs, and the decoration is a simple
combinatorial datum: therefore, the problem can be reduced to
enumerating abstract fatgraphs.  With a recursive algorithm, one can
construct trivalent $\M_{g,n}$-fatgraphs from $\M_{g-1,n}$ and
$\M_{g',n'} \times \M_{g'',n''}$ with $g'+g''=g$ and $n'+n''=n$; all
other graphs are gotten by contraction of regular edges.

The differential $D$ has a simple geometrical definition: $D(G)$ is a
sum of graphs $G'$ gotten by contracting a non-loop edge of $G$. A
naive implementation of Stage~II would just compare each contraction
of a graph with $k$ edges with any graph with $k-1$ edges, and score a
$\pm 1$ in the corresponding entry of the matrix $D_k$.  However, this
algorithm has quadratic complexity, and the large number of graphs
involved make it very inefficient already for $\M_{0,5}$.  The simple
observation that contraction of edges is defined on the topological
fatgraph underlying a numbered fatgraph allows us to apply the naive
algorithm to topological fatgraphs ---which cuts complexity down by a
factor~$(n!)^2$---, and then extend the result by the action of graph
automorphism groups on the numberings of boundary cycles.  This
is the variant detailed in \csref{sec:stage-ii}.

Stage~III is the simplest: by elementary linear algebra, the Betti
numbers can be computed from the rank of matrices $D_k$ and the
dimension of their domain space.  The computational problem of
determining the rank of a matrix has been extensively studied, and
several implementations of popular algorithms are already available in
the form of function libraries, ready for use. It should be noted,
however, that this is the step that consumes more computer time
(except for the very simple cases $2g+n<5$).

\section[Stage I]{Stage I: generate the fatgraphs complex}
\label{sec:stage-i}

Exposition of the Stage~I code will proceed in a \emph{top-down}
fashion: we shall work our way from the topmost function, which
returns the collection of all fatgraphs in $\R_{g,n}$, down to the
computer representation of a fatgraph.  This way, requirements that
functions and objects must satisfy become evident during the analysis,
and implementation details are introduced only when needed.

\subsection{Generation of all Fatgraphs in $\R_{g,n}$}
\label{sec:stage1-all}

Computations in Stage~I output the set of orientable fatgraphs
$\R_{g,n}$ from the input pair $g, n$, with $2g +n - 2 > 0$.  The
numbering will be added in Stage~II of the algorithm, so just the set
of undecorated fatgraphs is output here.

Let \l{MgnGraphs} be the function which, given the two integers $g$,
$n$ as input, and returns the collection of $\R_{g,n}$ graphs.  Let us
further stipulate that the output result will be represented as a
Python \l{list}: the $0$-th item in this list is the list of graphs
with the maximal number $m$ of edges; the $k$-th item in the list is
the list of graphs having $m - k$ edges.  There are algorithmic
advantages in this subdivision, which are explained below.

The Python implementation of the \l{MgnGraphs} function is as follows:
\begin{lstlisting}[name=MgnGraphs,firstnumber=1]
def MgnGraphs(g,n):
  """
  Return all connected fatgraphs having
  prescribed genus `g` and number of boundary cycles `n`.
  """
  # `graphs` is the function output -- start with an empty list
  graphs = []

  # maximum number of edges
  m = 4*g + 2*n - 5
\end{lstlisting}
Graphs with the maximal number of edges are trivalent graphs; they are
computed by a separate function \l{MgnTrivalentGraphs}, described in
\csref{sec:stage1-trivalent}.
\begin{lstlisting}[name=MgnGraphs,firstnumber=11]
  # first item `graphs[0]` contains all 3-valent graphs
  graphs.append(list(MgnTrivalentGraphs(g,n)))
\end{lstlisting}
We can then proceed to generating all graphs in $\R_{g,n}$ by
sequential contraction of graphs edges: by contracting one edge in
trivalent graphs we get the list \l{graphs[1]} of all graphs with
$m-1$ edges; contracting one edge in $G \in \text{\l{graphs[1]}}$, we
get $F \in \text{\l{graphs[2]}}$ with $m-2$ edges; and so on:
\begin{lstlisting}[name=MgnGraphs,firstnumber=13]
  for k in range(1,m):
    graphs.append([]) # start with empty list
    for G in graphs[k-1]:
      for e in G.edge_orbits():
        if not e.is_loop():
          F = G.contract(e)
          if F not in graphs[k]:
            graphs[k].append(F)
\end{lstlisting}
A line-by-line explanation is in order.

At line 13, the \l{range(1,m)} function sequentially generates all
integers in the half-open range $[1, m)$; therefore, the \l{for}-loop
body in lines 14--20 is executed $m-1$ times, with $k$ taking the
values $1$, ..., $m-1$ in order.  Note that, by Python syntax, the
loop body is indented w.r.t the loop head line.

At line 14, \l{graph[k]} is initialized to an empty list: at the start
of the loop body, the \l{graphs} list only has items \l{graphs[0]}
through \l{graphs[k-1]}.

Line 15 introduces a new loop: code in lines 16--20 will be executed
once for each fatgraph \l{G} in \l{graphs[k-1]}.

Line 16 starts the core of the function: contract edges of the
fatgraph \l{G} to generate new fatgraphs with $m-k$ edges.  However,
we need not contract every edge of a fatgraph: if $a \in \Aut(G)$ is
an automorphism and $x \in E(G)$ is an edge, then the contracted
graphs $G' = G/x$ and $G'' = G/a(x)$ are isomorphic.  Hence, we can
restrict the computation to consider only one edge per orbit of the
action induced by $\Aut(G)$ on the set $E(G)$. This is what the method
call \l{G.edge_orbits()} provides: for each graph \l{G}, it partitions
the set of edges of \l{G} into orbits and returns one representative
edge \l{e} for each one.

Line 17 skips non-regular edges: the following code is executed if and
only if \l{e} is not a loop.

Line 18 computes the fatgraph \l{F} obtained by contracting the
current edge \l{e} in \l{G}: the \l{Fatgraph.contract(G,e)} invocation
returns a \emph{new} fatgraph instance obtained by applying
topological contraction.

Lines 19--20 add \l{F} to \l{graphs[k]} \emph{only if it is not
  already there}.  This is actually very concise syntax for the most
computationally expensive part of the \l{MgnGraphs} function: Python
performs a comparison between \l{F} and each element in \l{graphs[k]};
each comparison invokes the \l{Fatgraph.__eq__} method, which in turn
invokes \l{Fatgraph.isomorphism}.

If $N_k = \text{\l{len(graph[k])}}$ is the number of elements in
\l{graph[k]} and $T_\text{iso}$ is the average time needed to
determine if two graphs are isomorphic, then evaluating the expression
`\l{F in graphs[k]}' takes $O(N_k \cdot T_\text{iso})$ time: thus, the
subdivision of \l{graphs} into lists, each one holding graphs with a
specific number of edges, reduces the number of fatgraph comparisons
done in the innermost loop of \l{MgnGraphs}.  (Although graphs with a
different number of edges are readily seen not to be isomorphic, the
isomorphism test is performed in the innermost loop, so it is executed
nonetheless a considerable number of times, and each saving, albeit
small, can result in a substantial shortening of the total running
time.)

Finally, function \l{MgnGraphs} exits and returns the list \l{graphs} to the
caller:
\begin{lstlisting}[name=MgnGraphs,firstnumber=21]
  # `graphs` is the final output of this function
  return graphs
\end{lstlisting}

Note that the top-level function \l{MgnGraphs} is quite independent of
the actual Python implementation of the \l{Fatgraph} type of objects:
all is needed here, is that a \l{Fatgraph} instance has methods for
enumerating edges, contracting an edge, and testing two graphs for
isomorphism.

\begin{lemma}
  If \l{MgnTrivalentGraphs(g,n)} returns the complete list of
  \emph{trivalent} fatgraphs in $\R_{g,n}$, then the function
  \l{MgnGraphs} defined above returns the complete set of fatgraphs
  $\R_{g,n}$.
\end{lemma}
\begin{proof}
  By the above dissection of the algorithm, all we need to prove is
  that any fatgraph in $\R_{g,n}$ can be obtained by a chain of edge
  contractions from a trivalent fatgraph.  This follows immediately
  from the fact that any fatgraph vertex $V$ of valence $v \geq 3$ can
  be expanded (in several ways) into vertices $V_1$, $V_2$ of valences
  $v_1$, $v_2$ such that $v = (v_1 -1) + (v_2 -1)$, plus a connecting
  edge.
\end{proof}


\subsection{Generation of Trivalent Fatgraphs}
\label{sec:stage1-trivalent}

The generation of trivalent graphs can be tackled by an inductive
procedure: given a trivalent graph, a new edge is added, which joins
the midpoints of two existing edges.  
In order to determine which graphs should be input to the ``edge
addition'' procedure, one can instead follow the reverse route, and
ascertain how a trivalent graph is transformed by \emph{deletion} of
an edge.

\subsubsection{Removal of edges}
\label{sec:removal}

Let $G \in \R_{g,n}$ be a \emph{connected} trivalent graph. Each edge
$x \in E(G)$ falls into one of the following categories:
\begin{enumerate}[\sl A)]
\item $x$ is a loop: both endpoints of $x$ are
  attached to a single vertex $v$; another edge $x'$ joins $v$ with a
  distinct vertex $v'$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ and separates two distinct boundary cycles $\beta, \beta'
  \in B(G)$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ but belongs to only one boundary cycle $\beta \in B(G)$
  (in which it occurs twice, once for each orientation).
\end{enumerate}
Deletion of edge $x$ requires different adjustments in order to get a
trivalent graph again in each of the three cases above; it also yields
a different result in each case.
\begin{figure}
  \centering
  % rubber: make removal.eps from removal.fig
  % rubber: make removal.pdf from removal.fig
  \includegraphics{removal}
  \caption{Graphical illustration of fatgraph edge removal.  Top row: a regular edge is removed from an $\R_{0,4}$ graph; its endpoints are further removed; the remaining edges are joined and the resulting graph is a trivalent fatgraph in $\R_{0,3}$.  Bottom row: a loop is removed from a trivalent $\R_{0,4}$ graph; the stem together with its endpoints has to be removed as well; the remaining edges are joined, and we end up with a trivalent fatgraph in $\R_{0,3}$.}
  \label{fig:removal}
\end{figure}

Case {\sl A)}: If $x$ is a loop attached to $v$, then, after deletion
of $x$, one needs to also delete the loose edge $x'$ and also the
vertex $v'$ (that is, join the two other edges attached to $v'$; see
\csref{fig:removal}, bottom row).  The resulting fatgraph $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$, $x'$ have been deleted and two other
  edges merged into one;
\item one boundary cycle less: the boundary cycle totally bounded by
  $x$ has been removed.
\end{itemize}
Therefore:
\begin{align*}
  2 - 2g' &= \chi(G') = V' - E' + n' 
  \\
  &= (V-2) -(E-3) + (n-1)
  \\
  &= V - E + n = \chi(G) = 2 - 2g,
\end{align*}
hence $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:A}\tag{A}
\end{equation}

In case {\sl B)}, $x$ joins distinct vertices $v$,
$v'$ and separates distinct boundary cycles (see \csref{fig:removal},
bottom row).  Delete $x$ and merge the two edges attached to each of
the two vertices $v$ and $v'$; in the process, the two boundary cycles
$\beta, \beta'$ also merge into one. The resulting fatgraph $G'$ is
connected. Indeed, given any two vertices $u, u' \in V(G')$, there is
a path $(x_1, \ldots, x_k)$ connecting $u$ with $u'$ in $G$; if this
path passes through $x$, one can replace the occurrence of $x$ with
the perimeter ---excluding $x$--- of one of the two boundary cycles
$\beta, \beta'$ to get a path joining $v$ and $v'$ which avoids $x$,
and thus projects to a path in $G'$.  Again we see that $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle less: the boundary cycles $\beta$, $\beta'$
  have been merged into one.
\end{itemize}
Therefore $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:B}\tag{B}
\end{equation}

In case {\sl C)}, $x$ joins distinct vertices $v$,
$v'$ but belongs into \emph{one} boundary cycle $\beta \in B(G)$ only.
Delete edge $x$ and the two vertices $v$, $v'$, joining the attached
edges two by two as in case {\sl B)}.
\begin{enumerate}
\item[\sl C')] If the resulting fatgraph $G'$ is connected, then
  $\beta \in B(G)$ has been split into two distinct boundary cycles
  $\beta', \beta'' \in B(G')$.  Indeed, write the boundary cycle
  $\beta$ as an ordered sequence of oriented edges: $y_0 \to y_1 \to
  \ldots \to y_l \to y_0$.  (The $y_*$ appear in this sequence in the
  exact order they are encountered when waling along $\beta$ in the
  sense given by the fatgraph orientation.) The oriented edges $y_j$
  are pairwise distinct: if $y_i$ and $y_k$ share the same supporting
  edge, then $y_i$ and $y_k$ have opposite orientations. By the
  initial assumption of case~{\sl C)}, edge $x$
  must appear \emph{twice} in the list: if $\bar x$ and $\underline x$
  denote the two orientations of $x$, then $y_i = \bar x$ and $y_k =
  \underline x$.  Deleting $x$ from $\beta$ is (from a homotopy point
  of view) the same as replacing $y_i = \bar x$ with $\bar x \to
  \underline x$, and $y_k = \underline x$ with $\underline x \to \bar
  x$ when walking a boundary cycle. Then we see that $\beta$ splits
  into two disjoint cycles:
\begin{align*}
  \beta' &= y_0 \to y_1 \to \cdots \to y_{i-1} \to \bar{x} \to
  \underline{x} \to y_{k+1} \to \cdots \to y_l \to y_0
  \\
  \beta'' &= y_{i+1} \to \cdots \to y_{k-1} \to \underline{x} \to
  \bar{x} \to y_{i+1}
\end{align*}
In this case, $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle \emph{more}: the boundary cycle $\beta$ has
  been split in the pair $\beta'$, $\beta''$.
\end{itemize}
Therefore $g'=g-1$ and $n'=n+1$, so:
\begin{equation}
G' \in \R_{g-1,n+1}.
\label{eq:C'}\tag{C'}
\end{equation}

\item[\sl C'')] $G'$ is a disconnected union of fatgraphs $G'_1$ and
  $G'_2$; for this to hold unconditionally, we temporarily allow a
  single circle into the set of connected fatgraphs (as a fatgraph
  with one closed edge and no vertices) as the one and only element of
  $\R_{0,2}$.  As will be shown in \csref{lemma:no-c2}, this is
  irrelevant for the algorithm.  Now:
  \begin{equation*} V'_1 + V'_2 = V -2, 
    \qquad E'_1 + E'_2 = E - 3,
    \qquad n'_1 + n'_2 = n + 1,
  \end{equation*} hence:
\begin{align*} 
  (2- 2g'_1) + (2-2g'_2) &= (V-2) - (E-3) + (n+1) 
  \\ 
  &= (V-E+n) + 2 = 4 - 2g
\end{align*} 
So that $g'_1 + g'_2 = g$, $n'_1 + n'_2 = n+1$ and
\begin{equation} 
  G'= G'_1 \otimes G'_2 \in \R_{g'_1, n'_1} \times \R_{g'_2, n'_2}.
  \label{eq:C''}\tag{C''}
\end{equation}
\end{enumerate}

\subsubsection{Inverse construction}
\label{sec:addition}

If $x \in E(G)$ is an edge of fatgraph $G$, denote $\bar{x}$ and
$\underline{x}$ the two opposite orientations of $x$.

In the following, let $\R'_{g,n}$ be the set of fatgraphs with a
selected oriented edge:
\begin{equation*}
  \R'_{g,n} := \{ (G,\bar x) : G \in \R_{g,n}, \bar{x} \in L(G)\}.
\end{equation*}
Similarly, let $\R''_{g,n}$ be the set of fatgraphs with two
chosen oriented edges:
\begin{equation*}
  \R''_{g,n} := \{ (G, \bar x, \bar y) : G \in \R_{g,n}, 
                   \bar{x}, \bar{y} \in L(G) \}.
\end{equation*}
The following abbreviations come in handy: let $\R = \cup \R_{g,n}$,
$\R' = \cup \R'_{g,n}$, and $\R'' = \cup \R''_{g,n}$.

Define the attachment of a new edge to a fatgraph in the following
way.  Given a fatgraph $G$ and an \emph{oriented} edge $\bar{x}$, we
can create a new trivalent vertex $v$ in the midpoint of $x$, and
attach a new edge to it, in such a way that the two halves of $x$
appear, in the cyclic order at $v$, in the same order induced by the
by the orientation of $\bar{x}$.  \csref{fig:adding} depicts the process.

\begin{figure}[bh]
  \centering
  % rubber: make adding.eps from adding.fig
  % rubber: make adding.pdf from adding.fig
  \includegraphics{adding}
  \caption{When adding a new vertex in the middle of an edge $x$, the cyclic order depends on the oriented edge: the two orientations $\bar{x}$ and $\underline{x}$ get two inequivalent cyclic orders.}
  \label{fig:adding}
\end{figure}

We can define maps that invert the constructions {\sl A)}, {\sl B)},
{\sl C')} and {\sl C'')} defined in the previos section.

Let $p_{g,n} : \R'_{g,n-1} \to \R_{g,n}$ be the map that creates
$p(G,\bar{x})$ from a pair $(G, \bar{x})$ by attaching a ``slip
knot''\footnote{A single 3-valent vertex with one loop attached and a
  regular edge with one loose end.} to the midpoint of $x$ by the
loose end.  The map $p: \R' \to \R$, $p|_{\R'_{g,n}} := p_{g,n}$ is
evidently the inverse to {\sl A)}.

To invert {\sl B)} and {\sl C')}, define a map $q : \R'' \to \R$ that
operates as follows:
\begin{itemize}
\item Given $(G, \bar{x}, \bar{y})$ with $\bar{x} \not= \bar{y}$, $q$
  attaches a new edge to the midpoints of $x$ and $y$; again the
  cyclic order on the new midpoint vertices is chosen such that the
  two halves of $x$ and $y$ appear in the order induced by the
  orientations $\bar x$, $\bar y$.
\item When $\bar{x} = \bar{y}$, let us further stipulate that the
  construction of $q'(G, \bar{x}, \bar{x})$ happens in two steps:
  \begin{enumerate}
  \item a new trivalent vertex is created in the midpoint of $x \in
    E(G)$ and a new edge $\xi$ is attached to it,
  \item map $x$ to the one of the two halves that comes first in the
    ordering induced by the orientation $\bar{x}$: create a new
    trivalent vertex in the middle of it, and attach the loose end of
    the new edge $\xi$.
  \end{enumerate}
  It is clear that the above steps give an unambiguous definition of
  $q$ in all cases where $\bar{x}$ and $\bar{y}$ are orientations of
  the same edge of $G$, that is, $(G, \bar{x}, \bar{x})$, $(G,
  \bar{x}, \underline{x})$, $(G, \underline{x}, \bar{x})$, and $(G,
  \underline{x}, \underline{x})$.
\end{itemize}
Ostensibly, $q$ inverts the edge removal in cases {\sl B)} and {\sl
  C')}: the former applies when a graph $G \in \R_{g,n}$ is sent to
$q(G) \in \R_{g,n+1}$, the latter when $G \in \R_{g,n}$ is sent to
$q(G) \in \R_{g+1,n-1}$.

Finally, to invert {\sl C'')}, let us define
\begin{equation*}
r_{g,n}: \bigoplus_{\substack{g'_1+g'_2=g \\ n'_1+n'_2=n}} 
\R'_{g'_1, n'_1} \times \R'_{g'_2, n'_2} \to \R.
\end{equation*}
From $(G', \bar{x}', G'',
\bar{x}'')$, construct a new fatgraph by bridging $G'$ and $G''$ with
a new edge, whose endpoints are in the midpoints of $x'$ and $x''$;
again, stipulate that the cyclic order on the new vertices is chosen
such that the two halves of $x'$, $x''$ appear in the order induced by
the orientations $\bar{x}'$, $\bar{x}''$.

Summing up, any fatgraph $G \in \R_{g,n}$ belongs to the image of one
of the above maps $p$, $q$, and $r$. There is considerable
overlap among the different image sets: indeed, one can prove that
$r$ is superfluous.
\begin{lemma}\label{lemma:no-c2}
  Any fatgraph obtained by inverting construction {\sl C'')} lies in
  the image of maps $p$ and $q$.
\end{lemma}
\begin{proof}
  Assume, on the contrary, that $G$ lies in the image of $r$ only.
  Then, deletion of any edge $x$ from $G$ yields a disconnected graph
  $G' \otimes G''$.  Both subgraphs $G'$ and $G''$ enjoy the same
  property, namely, that deletion of any edge disconnects: otherwise,
  if the removal of $y \in E(G')$ does not disconnect $G'$, then
  neither does it disconnect $G = G' \sqcup x \sqcup G''$, contrary to
  the assumption. As long as $G'$ or $G''$ has more than 3 edges, we
  can delete another edge; by recursively repeating the process, we
  end up with a fatgraph $G^*$ with $\leq 3$ edges.  For trivalent
  graphs, $3 \cdot E = 2 \cdot V$, therefore $G^*$ must have 3 edges
  and 2 vertices. But all such fatgraphs belong in $\R_{g,n}$, and it
  is readily checked that there is no way to add an edge such that the
  required property holds, that any deletion disconnects.
\end{proof}

\subsubsection{The \l{MgnTrivalentGraphs} algorithm}
\label{sec:MgnTrivalentGraphs}

The stage is now set for implementing the recursive generation of
trivalent graphs.
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=1]
def MgnTrivalentGraphs(g, n):
  """
  Return a list of all connected trivalent fatgraphs with
  prescribed genus `g` and number of boundary cycles `n`.
  """
\end{lstlisting}

A function call \l{MgnTrivalentGraphs(g,n)} recursively calls
\l{MgnTrivalentGraphs} to enumerate trivalent graphs of $\R_{g,n-1}$
and $\R_{g-1,n+1}$; it is cleaner to code the function as to call itself
unconditionally, and to catch the induction base cases at the very
start.  In particular, \l{MgnTrivalentGraphs} must:
\begin{itemize}
\item return the empty set when called with an invalid \l{(g,n)} pair;
\item provide the full set of fatgraphs $\R_{0,3}$ and $\R_{1,1}$ as
  induction base.
\end{itemize}
This is indeed realized in the following lines:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=6]
  # avoid infinite recursion in later statements
  if n==0 or (g,n)<(0,3):
    return [] # return empty list

  # $M_{0,3}$ --- induction base
  if (g,n) == (0,3):
    return [ 
        Fatgraph([Vertex([1, 2, 1]), Vertex([2, 0, 0])]),
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 0, 1])]) 
      ]

  # $M_{1,1}$ --- induction base
  elif (g,n) == (1,1):
    return [ 
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]) 
      ]
\end{lstlisting}

The general case is quite straightforward, if we assume to have
working implementations of the maps $p$ and $q$ defined in the
previous section (a description of the implementation of these maps
falls within the scope of \csref{sec:stage1-fatgraphs}).  The basic
idea is: apply maps $p$, $q$ to every fatgraph in $\R_{g,n-1}$, and
$q'$ to every fatgraph in $\R_{g-1,n+1}$; discard all graphs that do
not belong to $\R_{g,n}$ and take only one graph per isomorphism class
into the result set.

Implementation of the general case starts with creating an empty list
for accumulating the results.  An helper function
\l{add_if_admissible} is defined, to store only fatgraphs belonging in
$\R_{g,n}$ into \l{result}, and only one fatgraph per isomorphism
class (the `\l{G not in result}' clause):
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=22]
  # general case
  else:
    result = [] # start with empty list

    def add_if_admissible(G):
      if (G.genus, G.num_boundary_cycles) == (g,n) \
          and (G not in result):
        result.append(G)
      
\end{lstlisting}

To invert construction {\sl A)}, apply map $p$ to all fatgraphs $G \in
\R_{g,n-1}$; if $a \in \Aut(G)$, then $p(a(G), a(x)) = p(G, x)$,
therefore we may limit ourselves to one pair $(G,x)$ per orbit of the
automorphism group, saving a few computational cycles:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=30]
    # case A: hang a circle to all edges of graphs in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for x in G.edge_orbits():
        add_if_admissible (G.hangcircle(x,0))
        add_if_admissible (G.hangcircle(x,1))

\end{lstlisting}
The `\l{Fatgraph.hangcircle}' function implements the behavior of the
$p$ map: the expression `\l{G.hangcircle(x,0)}' returns a copy of
\l{G}, with a ``slipknot'' attached to edge \l{x}.  The additional
parameter (\l{0} or \l{1}) determines which orientation of \l{x}
should be considered, therefore expressions like `\l{x,0}' and
`\l{x,1}' should really be read as $\bar{x}$ or $\underline{x}$. A
complete explanation and implementation details are given in
\csref{sec:stage1-fatgraphs}.

Similarly, function `\l{Fatgraph.bridge}' implements $q$;
the algorithm used is independent of $g$ and $n$, thus a single
function can serve the whole fatgraph domain $\R = \cup
\R_{g,n}$. Since $q$ is a function of $(G, \bar{x}, \bar{y})$, which
is by construction invariant under $\Aut(G)$, we can again restrict
to considering only one $(G, \bar{x}, \bar{y})$ per $\Aut(G)$-orbit;
this is computed by the \l{G.edge_pair_orbit} function:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=35]
    # case B: bridge all edges of a single graph in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

    # case C': bridge all edges of a single graph in $M_{g-1,n+1}$
    for G in MgnTrivalentGraphs(g-1,n+1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

\end{lstlisting}

Finally, the list of fatgraphs (one fatgraph per isomorphism class) is
returned to the caller:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=50]
    return result
\end{lstlisting}


\subsection{Computer representation of Fatgraphs}
\label{sec:stage1-fatgraphs}



\section[Stage II]{Stage II: compute boundary operator matrices}
\label{sec:stage-ii}

\section[Stage III]{Stage III: compute Betti numbers of $\M_{g,n}$}
\label{sec:stage-iii}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 
