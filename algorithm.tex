
\chapter[An algorithm for graph homology]
  {An algorithm for computing graph homology}
\label{chap:algorithm}

This chapter presents an algorithm to compute homology of the fatgraph
complex $\R_{g,n}$.  By \csref{thm:fatgraph-homology}, this is
tantamount to the (co)homology with rational coefficients of the
moduli spaces $\M_{g,n}$. An effective computer implementation of the
algorithm is presented, which is capable of computing the Betti
numbers of $\M_{g,n}$ for $(2g+n) < 6$ on standard desktop-class
hardware.  The size of the fatgraph complex increases factorially with
$2g+n$, so a parallel algorithm is needed to compute the Betti numbers
of $\M_{g,n}$ for $(2g+n) \geq 6$; this will be the subject of a later
chapter.

Generators of the homology modules could be computed with a little
variant in the last step of the algorithm; however, this is not
interesting in connection with the homology of $\M_{g,n}$, since
expression of a fatgraph homology class in terms of algebro-geometric
classes has proved to be a difficult problem 
\cite{mondello:2004,
  igusa:combinatorial-miller-morita-mumford-classes-and-witten-cycles,
  igusa:graph-cohomology-and-kontsevich-cycles},
and to-date lacks a general solution.

The Python programming language is used in this chapter to articulate
the algorithm.  Python is claimed to be ``executable pseudo-code'',
combining a readable and ``natural'' syntax (that makes it well suited
to teaching programming to novices \cite{georgatos:python}) with the
power of a general-purpose language that is presently in daily use for
several real-world applications (see, e.g., \cite{python:success}).
Therefore, the code listed in this chapter can be copied to a Python
file and actually executed.  For the reader's convenience,
\csref{chap:python} recaps the Python syntax and briefly explains the
constructs and idioms used in programming this algorithm.


\section[Overview]{Overview of the algorithm}
\label{sec:overview}

\csref{thm:fatgraph-homology} provides an effective way to compute the
(co)homology of $\M_{g,n}$.  The Betti numbers of $\M_{g,n}$ can be
computed from the knowledge of the dimension of chain spaces $W_p$of
the fatgraph complex, and the ranks of the boundary operators $D_p$;
this can effectively be accomplished in the following stages:
\begin{enumerate}[I.]
\item Compute the basis set of $W_*$; by definition, the basis set is
  the set of \emph{orientable} fatgraphs indexing
  the cells of $\Mcomb_{g,n}$.
\item Work out the differential $D: W_* \to W_*$ in an
  effectively computable way, i.e., as matrix operators $D_p$ mapping
  coordinates in the fatgraph basis of $W_p$ into coordinates
  w.r.t. the fatgraph basis of $W_{p-1}$.
\item Compute the ranks of the matrices $D_p$.
\end{enumerate}

Stage~I needs just the pair $g,n$ as input; its output is the set of
orientable numbered fatgraphs belonging in $\R_{g,n}$: i.e., Stage~I
is an algorithm to enumerate the fatgraph of given genus and number of
boundary cycles. By definition, numbered fatgraphs are decorated
abstract fatgraphs, and the decoration is a simple combinatorial
datum: therefore, the problem can be reduced to enumerating abstract
fatgraphs.  With a recursive algorithm, one can construct
\emph{trivalent} $\M_{g,n}$-fatgraphs from trivalent graphs in
$\M_{g-1,n}$ and $\M_{g',n'} \times \M_{g'',n''}$ with $g'+g''=g$ and
$n'+n''=n$.  All other graphs in $\M_{g,n}$ are gotten by contraction
of regular edges.

The differential $D$ has a simple geometrical definition: $D(G)$ is a
sum of graphs $G'$ gotten by contracting a non-loop edge of $G$. A
naive implementation of Stage~II would just compare each contraction
of a graph with $k$ edges with any graph with $k-1$ edges, and score a
$\pm 1$ (depending on the orientation) in the corresponding entry of
the matrix $D_k$.  However, this algorithm has quadratic complexity,
and the large number of graphs involved makes it very inefficient
already for $\M_{0,5}$.  The simple observation that contraction of
edges is defined on the topological fatgraph underlying a numbered
fatgraph allows us to apply the naive algorithm to topological
fatgraphs, which cuts complexity down by a factor~$(n!)^2$.  The
resulting matrix is then extended to numbered fatgraphs by the action
of graph automorphism groups on the numberings of boundary cycles.
This is the variant detailed in \csref{sec:stage-ii}.

Stage~III is the simplest: by elementary linear algebra, the Betti
numbers can be computed from the rank of matrices $D_k$ and the
dimension of their domain space.  The computational problem of
determining the rank of a matrix has been extensively studied, and
several implementations of linear algebra algorithms are already
available in the form of function libraries, ready for use. It should
be noted, however, that this is the step that consumes more computer
time (except for the very simple cases $2g+n<5$).

\section[Stage I]{Stage I: generate the fatgraphs complex}
\label{sec:stage-i}

Exposition of the Stage~I code will proceed in a \emph{top-down}
fashion: we shall work our way from the topmost function, which
returns the collection of all fatgraphs in $\R_{g,n}$, down to the
computer representation of a fatgraph.  This way, requirements that
functions and objects must satisfy become evident during the analysis,
and implementation details are introduced only when needed.

\subsection{Generation of all Fatgraphs in $\R_{g,n}$}
\label{sec:stage1-all}

Computations in Stage~I output the set of orientable fatgraphs
$\R_{g,n}$ from the input pair $g, n$, with $2g +n - 2 > 0$.  The
numbering will be added in Stage~II of the algorithm, so just the set
of undecorated fatgraphs is output here.

Let "MgnGraphs" be the function which, given the two integers $g$,
$n$ as input, and returns the collection of $\R_{g,n}$ graphs.  Let us
further stipulate that the output result will be represented as a
Python "list": the $0$-th item in this list is the list of graphs
with the maximal number $m$ of edges; the $k$-th item in the list is
the list of graphs having $m - k$ edges.  There are algorithmic
advantages in this subdivision, which are explained below.

The Python implementation of the "MgnGraphs" function is as follows:
\begin{lstlisting}[name=MgnGraphs,firstnumber=1]
def MgnGraphs(g,n):
  """
  Return all connected fatgraphs having prescribed
  genus `g` and number of boundary cycles `n`.
  """
  # "graphs" is the function output; start with an empty list
  graphs = []

  # maximum number of edges
  m = 4*g + 2*n - 5
\end{lstlisting}
Graphs with the maximal number of edges are trivalent graphs; they are
computed by a separate function "MgnTrivalentGraphs", described in
\csref{sec:stage1-trivalent}.
\begin{lstlisting}[name=MgnGraphs,firstnumber=11]
  # first item `graphs[0]` contains all 3-valent graphs
  graphs.append(list(MgnTrivalentGraphs(g,n)))
\end{lstlisting}
We can then proceed to generating all graphs in $\R_{g,n}$ by
contraction of regular edges: by contracting one edge in
trivalent graphs we get the list "graphs[1]" of all graphs with
$m-1$ edges; contracting one edge in $G \in $"graphs[1]", we
get $F \in $"graphs[2]" with $m-2$ edges; and so on:
\begin{lstlisting}[name=MgnGraphs,firstnumber=13]
  for k in range(1,m):
    graphs.append([]) # "graph[k]" starts as empty list
    for G in graphs[k-1]:
      for e in G.edge_orbits():
        if not e.is_loop():
          F = G.contract(e)
          if F not in graphs[k]:
            graphs[k].append(F)
\end{lstlisting}
A line-by-line explanation follows.

At line 13, the "range(1,m)" function sequentially generates all
integers in the half-open range $[1, m)$; therefore, the "for"-loop
body in lines 14--20 is executed $m-1$ times, with $k$ orderly taking
the values $1$, ..., $m-1$.  Note that, by Python syntax, the loop
body is indented w.r.t the loop head line.

At line 14, "graph[k]" is initialized to an empty list: at the start
of the loop body, the "graphs" list only has items "graphs[0]"
through "graphs[k-1]".

Line 15 introduces a new loop: code in lines 16--20 will be executed
once for each fatgraph "G" in "graphs[k-1]".

Line 16 starts the core of the function: contract edges of the
fatgraph "G" to generate new fatgraphs with $m-k$ edges.  However,
we need not contract every edge of a fatgraph: if $a \in \Aut(G)$ is
an automorphism and $x \in E(G)$ is an edge, then the contracted
graphs $G' = G/x$ and $G'' = G/a(x)$ are isomorphic.  Hence, we can
restrict the computation to consider only one edge per orbit of the
action induced by $\Aut(G)$ on the set $E(G)$. This is what the method
call "G.edge_orbits()" provides: for each graph "G", it partitions
the set of edges of "G" into orbits and returns one representative
edge "e" for each one.

Line 17 skips non-regular edges: the following code is executed if and
only if "e" is not a loop.

Line 18 computes the fatgraph "F" obtained by contracting the
current edge "e" in "G": the "Fatgraph.contract(G,e)" invocation
returns a \emph{new} fatgraph instance obtained by applying
topological contraction.

Lines 19--20 add "F" to "graphs[k]" \emph{only if it is not
  already there}.  This is actually very concise syntax for the most
computationally expensive part of the "MgnGraphs" function: Python
performs a comparison between "F" and each element in "graphs[k]";
each comparison invokes the "Fatgraph.__eq__" method, which in turn
invokes "Fatgraph.isomorphism".

If $N_k = \text{\l{len(graph[k])}}$ is the number of elements in
"graph[k]" and $T_\text{iso}$ is the average time needed to
determine if two graphs are isomorphic, then evaluating the expression
``"F in graphs[k]"'' takes $O(N_k \cdot T_\text{iso})$ time: thus, the
subdivision of "graphs" into lists, each one holding graphs with a
specific number of edges, reduces the number of fatgraph comparisons
done in the innermost loop of "MgnGraphs".  (Although graphs with a
different number of edges are readily seen not to be isomorphic, the
isomorphism test is performed in the innermost loop, so it is executed
nonetheless a considerable number of times, and each saving, albeit
small, can result in a substantial shortening of the total running
time.)

Finally, the function "MgnGraphs" exits and returns the list "graphs"
to the caller:
\begin{lstlisting}[name=MgnGraphs,firstnumber=21]
  # the list "graphs" is the final output of this function
  return graphs
\end{lstlisting}

Note that the top-level function "MgnGraphs" is quite independent of
the actual Python implementation of the "Fatgraph" type of objects:
all is needed here, is that a "Fatgraph" instance has methods for
enumerating edges, contracting an edge, and testing two graphs for
isomorphism.

\begin{lemma}
  If "MgnTrivalentGraphs(g,n)" returns the complete list of
  \emph{trivalent} fatgraphs in $\R_{g,n}$, then the function
  "MgnGraphs" defined above returns the complete set of fatgraphs
  $\R_{g,n}$.
\end{lemma}
\begin{proof}
  By the above dissection of the algorithm, all we need to prove is
  that any fatgraph in $\R_{g,n}$ can be obtained by a chain of edge
  contractions from a trivalent fatgraph.  This follows immediately
  from the fact that any fatgraph vertex $V$ of valence $v \geq 3$ can
  be expanded (in several ways) into vertices $V_1$, $V_2$ of valences
  $v_1$, $v_2$ such that $v = (v_1 -1) + (v_2 -1)$, plus a connecting
  edge.
\end{proof}


\subsection{Generation of Trivalent Fatgraphs}
\label{sec:stage1-trivalent}

The generation of trivalent graphs can be tackled by an inductive
procedure: given a trivalent graph, a new edge is added, which joins
the midpoints of two existing edges.  
In order to determine which graphs should be input to the ``edge
addition'' procedure, one can instead follow the reverse route, and
ascertain how a trivalent graph is transformed by \emph{deletion} of
an edge.

Throughout this section, $V$ and $E$ stand for the number of vertices
(resp.~edges) of a graph; it will be clear from the context, which
exact graph they are invariants of.

\subsubsection{Removal of edges}
\label{sec:removal}

Let $G \in \R_{g,n}$ be a \emph{connected} trivalent graph. Each edge
$x \in E(G)$ falls into one of the following categories:
\begin{enumerate}[\slshape A)]
\item $x$ is a loop: both endpoints of $x$ are
  attached to a single vertex $v$; another edge $x'$ joins $v$ with a
  distinct vertex $v'$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ and separates two distinct boundary cycles $\beta, \beta'
  \in B(G)$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ but belongs to only one boundary cycle $\beta \in B(G)$,
  within which it occurs twice, once for each orientation.
\end{enumerate}
Deletion of edge $x$ requires different adjustments in order to get a
trivalent graph again in each of the three cases above; it also yields
a different result in each case.
\begin{figure}
  \centering
  % rubber: make removal.eps from removal.fig
  % rubber: make removal.pdf from removal.fig
  \includegraphics{removal}
  \caption{Graphical illustration of fatgraph edge removal.  Top row: a regular edge is removed from an $\R_{0,4}$ graph; its endpoints are further removed; the remaining edges are joined and the resulting graph is a trivalent fatgraph in $\R_{0,3}$.  Bottom row: a loop is removed from a trivalent $\R_{0,4}$ graph; the stem together with its endpoints has to be removed as well; the remaining edges are joined, and we end up with a trivalent fatgraph in $\R_{0,3}$.}
  \label{fig:removal}
\end{figure}

Case {\slshape A)}: If $x$ is a loop attached to $v$, then, after deletion
of $x$, one needs to also delete the loose edge $x'$ and the
vertex $v'$ (that is, join the two other edges attached to $v'$; see
\csref{fig:removal}, bottom row).  The resulting fatgraph $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$, $x'$ have been deleted and two other
  edges merged into one;
\item one boundary cycle less: the boundary cycle totally bounded by
  $x$ has been removed.
\end{itemize}
Therefore:
\begin{align*}
  2 - 2g' &= \chi(G') = V' - E' + n' 
  \\
  &= (V-2) -(E-3) + (n-1)
  \\
  &= V - E + n = \chi(G) = 2 - 2g,
\end{align*}
hence $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:A}\tag{A}
\end{equation}

In case {\slshape B)}, $x$ joins distinct vertices $v$,
$v'$ and separates distinct boundary cycles (see \csref{fig:removal},
top row).  Delete $x$ and merge the two edges attached to each of
the two vertices $v$ and $v'$; in the process, the two boundary cycles
$\beta, \beta'$ also merge into one. The resulting fatgraph $G'$ is
connected. Indeed, given any two vertices $u, u' \in V(G')$, there is
a path $(x_1, \ldots, x_k)$ connecting $u$ with $u'$ in $G$; if this
path passes through $x$, one can replace the occurrence of $x$ with
the perimeter ---excluding $x$--- of one of the two boundary cycles
$\beta, \beta'$ to get a path joining $v$ and $v'$ which avoids $x$,
and thus projects to a path in $G'$.  Again we see that $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle less: the boundary cycles $\beta$, $\beta'$
  have been merged into one.
\end{itemize}
Therefore $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:B}\tag{B}
\end{equation}

In case {\slshape C)}, $x$ joins distinct vertices $v$,
$v'$ but belongs into \emph{one} boundary cycle $\beta \in B(G)$ only.
Delete edge $x$ and the two vertices $v$, $v'$, joining the attached
edges two by two as in case {\slshape B)}.  We distinguish two
cases, depending whether the resulting fatgraph is connected.
\begin{enumerate}
\item[\slshape C')] If the resulting fatgraph $G'$ is connected, then
  $\beta \in B(G)$ has been split into two distinct boundary cycles
  $\beta', \beta'' \in B(G')$.  Indeed, write the boundary cycle
  $\beta$ as an ordered sequence of oriented edges: $y_0 \to y_1 \to
  \ldots \to y_l \to y_0$; assume the $y_*$ appear in this sequence in the
  exact order they are encountered when walking along $\beta$ in the
  sense given by the fatgraph orientation. The oriented edges $y_j$
  are pairwise distinct: if $y_i$ and $y_k$ share the same supporting
  edge, then $y_i$ and $y_k$ have opposite orientations. By the
  initial assumption of case~{\slshape C)}, edge $x$
  must appear \emph{twice} in the list: if $\bar x$ and $\underline x$
  denote the two orientations of $x$, then $y_i = \bar x$ and $y_k =
  \underline x$.  Deleting $x$ from $\beta$ is (from a homotopy point
  of view) the same as replacing $y_i = \bar x$ with $\bar x \to
  \underline x$, and $y_k = \underline x$ with $\underline x \to \bar
  x$ when walking a boundary cycle. Then we see that $\beta$ splits
  into two disjoint cycles:
\begin{align*}
  \beta' &= y_0 \to y_1 \to \cdots \to y_{i-1} \to \bar{x} \to
  \underline{x} \to y_{k+1} \to \cdots \to y_l \to y_0,
  \\
  \beta'' &= y_{i+1} \to \cdots \to y_{k-1} \to \underline{x} \to
  \bar{x} \to y_{i+1}.
\end{align*}
In this case, $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle \emph{more}: the boundary cycle $\beta$ has
  been split in the pair $\beta'$, $\beta''$.
\end{itemize}
Therefore $g'=g-1$ and $n'=n+1$, so:
\begin{equation}
G' \in \R_{g-1,n+1}.
\label{eq:C'}\tag{C'}
\end{equation}

\item[\slshape C'')] $G'$ is a disconnected union of fatgraphs $G'_1$ and
  $G'_2$; for this statement to hold unconditionally, we temporarily allow a
  single circle into the set of connected fatgraphs (consider it a fatgraph
  with one closed edge and no vertices) as the one and only element of
  $\R_{0,2}$.  As will be shown in \csref{lemma:no-c2}, this is
  irrelevant for the algorithm.  Now:
  \begin{equation*} V'_1 + V'_2 = V -2, 
    \qquad E'_1 + E'_2 = E - 3,
    \qquad n'_1 + n'_2 = n + 1,
  \end{equation*} hence:
\begin{align*} 
  (2- 2g'_1) + (2-2g'_2) &= (V-2) - (E-3) + (n+1) 
  \\ 
  &= (V-E+n) + 2 = 4 - 2g
\end{align*} 
So that $g'_1 + g'_2 = g + 2$, $n'_1 + n'_2 = n+1$ and
\begin{equation} 
  G'= G'_1 \otimes G'_2 \in \R_{g'_1, n'_1} \otimes \R_{g'_2, n'_2}.
  \label{eq:C''}\tag{C''}
\end{equation}
\end{enumerate}

\subsubsection{Inverse construction}
\label{sec:addition}

If $x \in E(G)$ is an edge of fatgraph $G$, denote $\bar{x}$ and
$\underline{x}$ the two opposite orientations of $x$.

In the following, let $\R'_{g,n}$ be the set of fatgraphs with a
selected oriented edge:
\begin{equation*}
  \R'_{g,n} := \{ (G,\bar x) : G \in \R_{g,n}, \bar{x} \in L(G)\}.
\end{equation*}
Similarly, let $\R''_{g,n}$ be the set of fatgraphs with two
chosen oriented edges:
\begin{equation*}
  \R''_{g,n} := \{ (G, \bar x, \bar y) : G \in \R_{g,n}, 
                   \bar{x}, \bar{y} \in L(G) \}.
\end{equation*}
The following abbreviations come in handy: let $\R = \cup \R_{g,n}$,
$\R' = \cup \R'_{g,n}$, and $\R'' = \cup \R''_{g,n}$.

Define the attachment of a new edge to a fatgraph in the following
way.  Given a fatgraph $G$ and an \emph{oriented} edge $\bar{x}$, we
can create a new trivalent vertex $v$ in the midpoint of $x$, and
attach a new edge to it, in such a way that the two halves of $x$
appear, in the cyclic order at $v$, in the same order induced by the
by the orientation of $\bar{x}$.  \csref{fig:adding} depicts the process.
\begin{figure}
  \centering
  % rubber: make adding.eps from adding.fig
  % rubber: make adding.pdf from adding.fig
  \includegraphics{adding}
  \caption{When adding a new vertex in the middle of an edge $x$, the cyclic order depends on the oriented edge: the two orientations $\bar{x}$ and $\underline{x}$ get two inequivalent cyclic orders.}
  \label{fig:adding}
\end{figure}

We can now define maps that invert the constructions {\slshape A)}, {\slshape B)},
{\slshape C')} and {\slshape C'')} defined in the previous section.
\begin{figure}
  \centering
  % rubber: make pqr.eps from pqr.fig
  % rubber: make pqr.pdf from pqr.fig
  \includegraphics{pqr}
  \caption{Graphical illustration of maps $p$, $q$, $r_{g,n}$.  Top left: $p(G,\bar{x})$ attaches a ``slipknot'' to edge $\bar{x}$.  Top right: $r_{2,5}(G_1, \bar{x}, G_2, \bar{y})$ joins fatgraphs $G_1$ and $G_2$ with a new edge. Bottom: $q(G,\bar{x}, \bar{y})$ (left) and $p(G, \underline{x}, \bar{y})$ (right); it is shown how changing the orientation of an edge can lead to different results.}
  \label{fig:pqr}
\end{figure}

Let $p_{g,n} : \R'_{g,n-1} \to \R_{g,n}$ be the map that creates a
fatgraph $p(G,\bar{x})$ from a pair $(G, \bar{x})$ by attaching the
loose end of a ``slip knot''\footnote{A single 3-valent vertex with
  one loop attached and a regular edge with one loose end.} to the
midpoint of $x$.The map $p: \R' \to \R$, $p|_{\R'_{g,n}} := p_{g,n}$
is ostensibly inverse to {\slshape A)}.

To invert {\slshape B)} and {\slshape C')}, define a map $q : \R'' \to \R$ that
operates as follows:
\begin{itemize}
\item Given $(G, \bar{x}, \bar{y})$ with $\bar{x} \not= \bar{y}$, $q$
  attaches a new edge to the midpoints of $x$ and $y$; again the
  cyclic order on the new midpoint vertices is chosen such that the
  two halves of $x$ and $y$ appear in the order induced by the
  orientations $\bar x$, $\bar y$.
\item When $\bar{x} = \bar{y}$, let us further stipulate that the
  construction of $q(G, \bar{x}, \bar{x})$ happens in two steps:
  \begin{enumerate}
  \item a new trivalent vertex is created in the midpoint of $x \in
    E(G)$ and a new edge $\xi$ is attached to it,
  \item create a new trivalent vertex in the middle of the one of the
    two halves which comes first in the ordering induced by the
    orientation $\bar{x}$; attach the loose end of the new edge $\xi$
    to this new vertex.
  \end{enumerate}
  It is clear that the above steps give an unambiguous definition of
  $q$ in all cases where $\bar{x}$ and $\bar{y}$ are orientations of
  the same edge of $G$, that is, $(G, \bar{x}, \bar{x})$, $(G,
  \bar{x}, \underline{x})$, $(G, \underline{x}, \bar{x})$, and $(G,
  \underline{x}, \underline{x})$.
\end{itemize}
Ostensibly, $q$ inverts the edge removal in cases {\slshape B)} and
{\slshape C')}: the former applies when a graph $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g,n+1}$, the latter when $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g+1,n-1}$.

Finally, to invert {\slshape C'')}, let us define
\begin{equation*}
r_{g,n}: \bigoplus_{\substack{g'_1+g'_2=g+2 \\ n'_1+n'_2=n}} 
\R'_{g'_1, n'_1} \times \R'_{g'_2, n'_2} \to \R.
\end{equation*}
From $(G', \bar{x}', G'',
\bar{x}'')$, construct a new fatgraph by bridging $G'$ and $G''$ with
a new edge, whose endpoints are in the midpoints of $x'$ and $x''$;
again, stipulate that the cyclic order on the new vertices is chosen
such that the two halves of $x'$, $x''$ appear in the order induced by
the orientations $\bar{x}'$, $\bar{x}''$.

Summing up, any fatgraph $G \in \R_{g,n}$ belongs to the image of one
of the above maps $p$, $q$, and $r$. There is considerable
overlap among the different image sets: indeed, one can prove that
$r$ is superfluous.
\begin{lemma}\label{lemma:no-c2}
  Any fatgraph obtained by inverting construction {\slshape C'')} lies in
  the image of maps $p$ and $q$.
\end{lemma}
\begin{proof}
  Assume, on the contrary, that $G$ lies in the image of $r$ only.
  Then, deletion of any edge $x$ from $G$ yields a disconnected graph
  $G' \otimes G''$.  Both subgraphs $G'$ and $G''$ enjoy the same
  property, namely, that deletion of any edge disconnects: otherwise,
  if the removal of $y \in E(G')$ does not disconnect $G'$, then
  neither does it disconnect $G = r_{g,n}(G', G'')$, contrary to the
  assumption. As long as $G'$ or $G''$ has more than 3 edges, we can
  delete another edge; by recursively repeating the process, we end up
  with a fatgraph $G^*$ with $\leq 3$ edges, which is again
  disconnected by removal of any edge.  Since $G^*$ is trivalent, $3
  \cdot E^* = 2 \cdot V^*$, therefore $G^*$ must have exactly 3 edges
  and 2 vertices. But all such fatgraphs belong in $\R_{0,3}$ or
  $\R_{1,1}$, and it is readily checked that there is no way to add an
  edge such that the required property holds, that any deletion
  disconnects.
\end{proof}

\subsubsection{The \protect\Verb`MgnTrivalentGraphs` algorithm}
\label{sec:MgnTrivalentGraphs}

The stage is now set for implementing the recursive generation of
trivalent graphs.
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=1]
def MgnTrivalentGraphs(g, n):
  """
  Return a list of all connected trivalent fatgraphs with
  prescribed genus `g` and number of boundary cycles `n`.
  """
\end{lstlisting}

A function call "MgnTrivalentGraphs(g,n)" recursively calls
"MgnTrivalentGraphs" to enumerate trivalent graphs of $\R_{g,n-1}$
and $\R_{g-1,n+1}$; it is cleaner to program the function as to call itself
unconditionally, and to catch the induction base cases at the very
start.  In particular, "MgnTrivalentGraphs" must:
\begin{itemize}
\item return the empty set when called with an invalid "(g,n)" pair;
\item provide the full set of fatgraphs $\R_{0,3}$ and $\R_{1,1}$ as
  induction base.
\end{itemize}
This is indeed realized in the following lines (the fatgraph
representation as a Python ``"Fatgraph"'' object is discussed in
\csref{sec:stage1-fatgraphs}):
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=6]
  # avoid infinite recursion in later statements
  if n==0 or (g,n)<(0,3):
    return [] # return empty list

  # $M_{0,3}$ --- induction base
  if (g,n) == (0,3):
    return [ 
        Fatgraph([Vertex([1, 2, 1]), Vertex([2, 0, 0])]),
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 0, 1])]) 
      ]

  # $M_{1,1}$ --- induction base
  elif (g,n) == (1,1):
    return [ 
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]) 
      ]
\end{lstlisting}

The general case is quite straightforward, if we assume to have
working implementations of the maps $p$ and $q$ defined in the
previous section (a description of the implementation of these maps
falls within the scope of \csref{sec:stage1-fatgraphs}).  The basic
idea is: apply maps $p$, $q$ to every fatgraph in $\R_{g,n-1}$, and
$q$ to every fatgraph in $\R_{g-1,n+1}$; discard all graphs that do
not belong to $\R_{g,n}$ and take only one graph per isomorphism class
into the result set.

Implementation of the general case starts with creating an empty list
for accumulating the results.  An helper function
"add_if_admissible" is defined, to store only fatgraphs belonging in
$\R_{g,n}$ into "result", and only one fatgraph per isomorphism
class (the ``"G not in result"'' clause):
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=22]
  # general case
  else:
    result = [] # start with empty list

    def add_if_admissible(G):
      if (G.genus, G.num_boundary_cycles) == (g,n) \
          and (G not in result):
        result.append(G)
      
\end{lstlisting}

To invert construction {\slshape A)}, apply map $p$ to all fatgraphs $G \in
\R_{g,n-1}$; if $a \in \Aut(G)$, then $p(a(G), a(x)) = p(G, x)$,
therefore we may limit ourselves to one pair $(G,x)$ per orbit of the
automorphism group, saving a few computational cycles:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=30]
    # case A: hang a circle to all edges of graphs in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for x in G.edge_orbits():
        add_if_admissible (G.hangcircle(x,0))
        add_if_admissible (G.hangcircle(x,1))

\end{lstlisting}
The ``"Fatgraph.hangcircle"'' function implements the behavior of the
$p$ map: the expression ``"G.hangcircle(x,0)"'' returns a copy of
"G", with a ``slipknot'' attached to edge "x".  The additional
parameter ("0" or "1") determines which orientation of "x"
should be considered, therefore expressions like ``"x,0"'' and
``"x,1"'' should really be read as $\bar{x}$ or $\underline{x}$. A
complete explanation and implementation details are given in
\csref{sec:stage1-fatgraphs}.

Similarly, function ``"Fatgraph.bridge"'' implements $q$;
the algorithm used is independent of $g$ and $n$, thus a single
function can serve the whole fatgraph domain $\R = \cup
\R_{g,n}$. Since $q$ is a function of $(G, \bar{x}, \bar{y})$, which
is by construction invariant under $\Aut(G)$, we can again restrict
to considering only one $(G, \bar{x}, \bar{y})$ per $\Aut(G)$-orbit;
this is computed by the "G.edge_pair_orbits" function:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=35]
    # case B: bridge all edges of a single graph in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

    # case C': bridge all edges of a single graph in $M_{g-1,n+1}$
    for G in MgnTrivalentGraphs(g-1,n+1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

\end{lstlisting}

Finally, the list of fatgraphs (one fatgraph per isomorphism class) is
returned to the caller:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=50]
    return result
\end{lstlisting}
\FIXME{Serve qui un'analisi della complessit\`a dell'algoritmo?  In
  realt\`a non si pu\`o concludere molto, perch\'e dipende in modo
  essenziale dal numero totale dei grafi e dal numero dei duplicati:
  nessuno di questi \'e noto in anticipo.}


\subsection{Computer representation of Fatgraphs}
\label{sec:stage1-fatgraphs}

The core of the computation lies in the representation of a fatgraph
as an object in the programming language Python: according to the
analysis of the graph generation algorithms in
Sections \ref{sec:stage1-all}--\ref{sec:stage1-trivalent}, a
``"Fatgraph"'' class is needed, together with functions to contract an
edge ("Fatgraph.contract"), compute orbits of edges under the action
of fatgraph automorphisms ("Fatgraph.edge_orbits" and
"Fatgraph.edge_pair_orbits"), implement maps $p$ and $q$
("Fatgraph.hangcircle" and "Fatgraph.bridge"), and, last but not
least, check two graphs for isomorphism.\FIXME{Rimuovere i nomi delle
  funzioni da questo paragrafo introduttivo?}

Although the combinatorial definition of a fatgraph
(cf.~\csref{sec:fatgraphs}) might suggest a computer representation as
a triple of permutations ---as used, e.g., in \cite[Section
2.4]{arXiv:0902.1025}---, the functions that are needed by the above
generation algorithms are rather topological in nature and thus
suggest an approach more directly related to the concrete realization
of a fatgraph.

\subsubsection{Vertices}
\label{sec:vertices}

Let $G$ be a fatgraph; assuming $G$ has $E = l+1$ edges, arbitrarily
assign to each edge an integer in the range $[0, E)$, that is, pick a
bijective map $e: E(G) \to \{0, \dots, l\}$.  Each vertex $v \in V(G)$
is thus decorated with a cyclic sequence of edge labels.  Conversely,
given just the set of such decorations, one can reconstruct the
fatgraph $G$: indeed, given cyclic sequences $v_0 = (e_0^0,
e^0_1, \ldots, e^0_{i_0})$, \ldots, $v_k = (e^k_0, \ldots,
e^k_{i_k})$, such that $\{e^0_0, \ldots, e^0_{i_0}, e^1_0, \ldots,
e^{k-1}_{i_{k-1}}, e^k_0, \ldots, e^k_{i_k}\} = \{0, \ldots, l\}$,
we can set
\begin{equation*}
  X := \{ (e, v) : e \in v, v\in \{v_0, \ldots, v_k\} \},
\end{equation*}
and define maps $\sigma_0, \sigma_1, \sigma_2: X \to X$ as follows:
$\sigma_0$ sends $(e, v)$ to $(e', v)$ where $e'$ is the successor of
$e$ in the cyclic order at $v$; $\sigma_1$ maps $(e, v)$ to the unique
other pair $(e', v') \in X$ such that $e = e'$; finally, $\sigma_2$ is
determined by the constraint $\sigma_0\sigma_1\sigma_2 = \id_X$.  Then
$G = (X, \sigma_0, \sigma_1, \sigma_2)$ is a fatgraph; by applying the
procedure described at the beginning of this paragraph, we recover
$v_0$, \ldots, $v_k$ up to a permutation of the edge labels.
\begin{figure}
  \centering
  % rubber: make vertex.pdf from vertex.fig
  % rubber: make vertex.eps from vertex.fig
  \includegraphics{vertex}
  \caption{Representation of vertices as (cyclic) lists of edge
    labels.  (Edge labels are depicted as numbers on a yellow square
    background, sitting over the edge they label.)  Representation of
    a vertex as a list is implicitly ciliated: we use the convention
    that the edge closest to the vertical ``upwards'' line is the
    ciliated one.}
  \label{fig:vertex}
\end{figure}

Therefore, we can represent a fatgraph vertex by the cyclically
ordered list of its edge labels.  Figure~\ref{fig:vertex} gives an
illustration. 

The "CyclicList" base class provides all the functionality needed by
such a "Vertex" class: if "v" is a "Vertex" instance, then the
Python expression "v[i]" returns the edge label stored at
position "i", furthermore, "v[i]==v[i+L]" when "L=len(v)".
The length "len(v)" of a "Vertex" instance is the number of edges attached
to the vertex.  

Thus, in the definition of the "Vertex" class we only override the
initialization method to record some additional information:
\begin{lstlisting}
class Vertex(CyclicList):
  """
  A (representation of a) vertex of a ribbon graph.
  """
  def __init__(self, seq):
    # initialize base class
    CyclicList.__init__(self, seq)
    # store number of loops (top. invariant) for later reference
    self.num_loops = len(self) - len(set(self))

\end{lstlisting}
During a "Vertex" object creation, the number of loops attached to
this vertex is computed and stored in the "num_loops" attribute: the
number of loops is a vertex invariant and will be used in the
computation of fatgraph isomorphisms.  The number of loops is computed
as the difference between "len(self)", the number of attached edges,
and "len(set(self))", the number of (unique) labels of attached
edges.\footnote{Python's expression \l{set(self)} builds a \l{set}
  object from the list of integers \l{self}, i.e., it removes multiple
  occurrences of the same number from the list.  Therefore
  \l{len(set(self))} is the number of elements in \l{set(self)}, that
  is, the number of unique edge colorings at the vertex represented by
  \l{self}.}

\begin{definition}
  A fatgraph vertex together with a choice of an attached edge is
  called a \emph{ciliated} vertex.  The chosen edge is called the
  \emph{cilium}.
\end{definition}
Note that "Vertex" objects actually represent \emph{ciliated} vertices.
Since we need to implement the cyclic behavior of fatgraph vertices,
two "Vertex" instances must be declared equal if one is equal (as a
sequence) to the other rotated by a certain amount.  This behavior is
again implemented in the "CyclicList" class: comparing two
"CyclicSequence" instances has linear complexity in the length of
the sequence, as all the rotations have to be tried out in the worst
case.\FIXME{Inserire qui il codice relativo e il commento?}

The following definition will often be referred to, in the remainder
of this section:
\begin{definition}
  If $v$ is a ciliated vertex and $e$ is a half-edge attached to it, define
  the \emph{attachment index} of $e$ at $v$ as the index of edge $e$ relative
  to the cilium at $v$: if $\alpha$ is the attachment index of $e$ at
  $v$, then $\sigma_1^\alpha$ takes the cilium at $v$ onto $e$.
\end{definition}
The attachement index is unambiguously defined for all edges which are
not loops; therefore, in the following we shall slightly abuse the
definition and speak of the attachment index of an edge at a vertex.


\subsubsection{Edges}
\label{sec:edges}

An edge is represented by its two endpoints; each endpoint has the
form "(v, a)", where "v" is the index of the endpoint vertex
(within the fatgraph), and "a" is the index at which this edge
appears within vertex "v" (the attachment index).
\begin{lstlisting}
class Edge(object):
  """An edge of a fatgraph."""

  def __init__(self, va1, va2):
    if va1[0] < va2[0]:
      self.endpoints = (va1, va2)
    else:
      self.endpoints = (va2, va1)

\end{lstlisting}
Note that the "Edge.__init__" constructor requires the two
endpoints, that is, it should be invoked like: 
"e = Edge((0,1),(1,3))", passing the endpoints already as a Python tuple 
"(v,a)".  Also, "Edge" objects guarantee that endpoints are stored in
increasing vertex index order (line~63): therefore, if "e" is an "Edge"
object, then "e.endpoints[0] < e.endpoints[1]".

"Edge" objects bear no reference to a particular "Fatgraph" instance,
to allow sharing the same edge instance among "Fatgraph" instances that are
created by contraction or other geometrical operations.  In
particular, this implies that the numerical labels assigned to
edges must be recorded in the object representing the fatgraph, and
not in the "Edge" instance.

A few convenience methods are defined on "Edge" objects, to make for
clearer code.

The "Edge.is_loop" function returns "True" if applied to an
"Edge" object that represents a loop:
\begin{lstlisting}
  def is_loop(self):
    """
    Return `True` if this `Edge` instance 
    represents a looping edge.
    """
    return self.endpoints[0][0] == self.endpoints[1][0]
    
\end{lstlisting}

The "Edge.meets" function takes an "Edge" and a vertex index "v"
as input, and returns "True" if "v" is one of the endpoints:
\begin{lstlisting}
  def meets(self, v):
    """
    Return `True` if vertex `v` is one of the endpoints.
    """
    return (v==self.endpoints[0][0] or v==self.endpoints[1][0])

\end{lstlisting}

The "Edge.other_end" method takes as input an "Edge" instance, a
vertex index "v", and an attachment index "a" --- together, they
form an endpoint "(v, a)"; the function returns the other endpoint
of the given "Edge".  For instance, if "e=Edge((0,1),(1,3))"
then "Edge.other_end(e,0,1)" returns "(1,3)" and
"Edge.other_end(e,1,3)" returns "(0,1)"
\begin{lstlisting}
  def other_end(self, v, a):
    """Return the endpoint opposed to `(v, a)`."""
    if self.endpoints[0] == (v, a):
      return self.endpoints[1]
    else:
      return self.endpoints[0]

\end{lstlisting}




\subsubsection{Boundary Cycles}
\label{sec:boundary-cycles}

Boundary cycles are represented as cyclic sequences of ``corners'': a
corner consists of a vertex "v" and two consecutive indices "i", "j"
(in the cyclic order at "v") --- see Figure~\ref{fig:corners}. 
Although the two corners "(v, i, j)" and "(v, j, i)" are equal, the
Python code described in this section always creates triplets such that
either "j==i+1" or "i" and "j" are the ending and starting indices.
\begin{figure}
  \centering
  % rubber: make corners.pdf from corners.fig
  % rubber: make corners.eps from corners.fig
  \includegraphics{corners}
  \caption{Representation of fatgraph boundary cycles. \emph{Left:}
    corners around a vertex $a$. Note that the indices in the triple
    are attachment indices, i.e., displacement relative from the
    ciliated edge (the vertical one in this picture), thus they bear
    no relation to the labels on the edges (numbers on the light
    yellow background). \emph{Right:} How the boundary cycles are
    represented with corners: each boundary component is identified
    with the set of triples it encloses. Therefore the boundary cycles
    for the graph on the right are represented by the sets $\{(a,0,1),
    (b,2,0)\}$, $\{(a,1,2), (b,1,2)\}$, and $\{(a,2,0), (b,0,1)\}$}
  \label{fig:corners}
\end{figure}
It is easy to convince oneself that this is equivalent to the boundary
cycle definition in \csref{sec:fatgraphs}.  Indeed, if $(X, \sigma_0,
\sigma_1, \sigma_2)$ is a fatgraph, then the boundary cycles are
defined as the orbits of $\sigma_2$ on the set of oriented edges
$X$. We could substitute an \emph{(edge, endpoint vertex)} pair for an
oriented edge, however, this is ill-defined for looping edges; to
distinguish the two endpoints of a loop we need to consider the
attachment index together with the endpoint vertex; but then, the
\emph{(endpoint vertex, attachment index)} pair suffices to completely
determine an oriented edge (given the ambient fatgraph).  The
additional successor index is added in the corner triple "(v,i,j)"
so that the action of $\sigma_2$ can be computed from corner data
alone, without any reference to the ambient fatgraph or the concerned
vertex (for computation efficiency reasons).

In particular, this representation based on ``corners'' allows one to
distinguish the boundary cycles made that comprises the same set of
edges: for instance, the boundary cycles of the fatgraph depicted in
\csref{fig:012012} are represented by the set of corners $\{(0, 2, 3),
(0, 4, 5), (0, 0, 1)\}$ and $\{(0, 1, 2), (0, 3, 4), (0, 5, 0)\}$.
\begin{figure}
  \centering
  % rubber: make 012012.eps from 012012.fig
  % rubber: make 012012.pdf from 012012.fig
  \includegraphics{012012}
  \caption{A ``pathologic'' fatgraph, whose two boundary cycles are
    comprised of exactly the same edges. They give rise to quite
    distinct sets of corners, though: $\{(0, 2, 3), (0, 4, 5), (0, 0,
    1)\}$ versus $\{(0, 1, 2), (0, 3, 4), (0, 5, 0)\}$.}
  \label{fig:012012}
\end{figure}

Two boundary cycles are equal if they comprise the same corners.
Thus, there is no reason to record the order in which the edges are
encountered when walking along a boundary cycles: the "BoundaryCycle"
objects can be just an alias for Python's built-in "frozenset"
class.\footnote{Class \l{frozenset} is the immutable variant of a
  \l{set}: \l{frozenset} objects cannot be modified after creation, on
  the other hand they can be used as keys in \l{dict} objects.  This
  is a feature that will be needed when defining a numbering on a
  fatgraph: the additional structure will be just a dictionary
  associating \l{BoundaryCycles} with an integer.}
\begin{lstlisting}
class BoundaryCycle(frozenset):
  """A boundary cycle of a Fatgraph."""

  # no change to the `frozenset` code
  pass 

\end{lstlisting}
A "BoundaryCycle" instance can thus be constructed by passing a
sequence of corners, represented as Python tuples "(v,i,j)", as in:
"BoundaryCycle([(1,1,2), (2,1,2)])".  Note that the vertex "v" is
referenced in each triplet by its index in the list of the ambient
fatgraph vertices.


\subsubsection{Fatgraphs}
\label{sec:fatgraphs}

The stage is now set for the introduction of a computable
representation of fatgraphs.  The class "Fatgraph" constructor takes a
list of "Vertex" objects; a typical line of code creating a "Fatgraph"
instance would be:
\begin{codexmp}
  g1 = Fatgraph( [ Vertex([2,0,1]), 
                   Vertex([2,1,0]) ] )
\end{codexmp}
Figure~\ref{fig:ctor} shows how a fatgraph is constructed out of the
data above.
\begin{figure}
  \centering
  % rubber: make ctor.eps from ctor.fig
  % rubber: make ctor.pdf from ctor.fig
  \includegraphics{ctor}
  \caption{Construction of a fatgraph out of a set of
    \l{Vertex} instances: half-edges tagged with the same
    (numeric) label are joined together to form an edge.}
  \label{fig:ctor}
\end{figure}

The "Fatgraph.__init__" constructor takes a list of vertices as the
only required parameter and computes data structures describing
the fatgraph.  In particular, for each fatgraph, we need to store:
\begin{itemize}
\item The list of vertices (as "Vertex" objects, therefore ciliated).
\item The adjacency list: for each edge, record the vertices it is
  attached to (this information is embedded in "Edge" objects).
\end{itemize}
Once these two are known, information about a vertex or an edge can be
retrieved just by a lookup in the list of vertices or the list of
edges.  Thus, the code within the "Fatgraph" class will always
identify a vertex with its index in the "self.vertices" list (e.g.,
this is the numeric tag used to identify a vertex in the triplets
representing boundary cycles ``corners''). Similarly, edges are
identified with their numeric label, which is also used as index in
the "self.edges" list.

The adjacency list can be computed from the complete list of "Vertex" objects:
therefore, the constructor of "Fatgraph" objects can take just the
list of vertices as the only needed parameter.  Any other
fatgraph-related data can be derived from the above two.  However, in
different parts of the code, the construction of a fatgraph can take
different routes, as there is different data to start with.
Thus, we allow supplying some of the internal data by means of an
additional "kwargs" argument for efficiency reasons (e.g., when a data
structure is already known to the caller, as is the case in the
"Fatgraph.contract" method).\footnote{This is a
  work-around for Python's lack of multiple constructors: The
  \l{kwargs} parameter is a way to assemble a \l{Fatgraph} object out of
  already-computed data, see, for instance, the \l{contract}
  method.}
\begin{lstlisting}
class Fatgraph(object):
  """A representation of a fatgraph."""

  def __init__(self, vertices, **kwargs):
    """
    Construct a `Fatgraph` instance, 
    taking list of vertices.
    """
\end{lstlisting}
The "self.vertices" instance attribute is initialized with the
"vertices" constructor argument:
\begin{lstlisting}
    # list of vertices
    self.vertices = vertices

\end{lstlisting}
The number of vertices is also recorded (in the "num_vertices"
attribute of each instance), for speed and clarity of coding:
\begin{lstlisting}
    # Number of vertices  
    self.num_vertices = len(vertices)

\end{lstlisting}

\paragraph{Adjacency list.}
The total number of edges (stored in "num_edges") can be computed by
summing the valences of vertices.  It is needed to size the adjacency
list, so must be computed early:
\begin{lstlisting}
    # Number of edge colors
    self.num_edges = sum(len(v) for v in self.vertices) / 2)

\end{lstlisting}
The adjacency list (recorded in the attribute "self.edges") is computed
from the list of vertices as follows.  Note that the "edges" parameter
may be passed via the "kwargs" mechanism, in which case the
computation is skipped and the passed list is used as adjacency list.
\begin{lstlisting}
    if 'edges' in kwargs:
      self.edges = kwargs.get('edges')
    else:
      endpoints = [ [] for x in range(self.num_edges) ]
      for vertex_index in range(self.num_vertices):
        for (edge_index_in_vertex, edge) \
            in enumerate(self.vertices[vertex_index]):
          endpoints[edge].append( (vertex_index, edge_index_in_vertex) )
      # now wrap endpoints into "Edge" objects
      self.edges = [ Edge(*e) for e in endpoints ]

\end{lstlisting}
The code above walks the list of vertices (line~107), and then
iterates over the (half-)edges attached to each vertex (line~108):
each endpoint is recorded in the form of a 2-uple \emph{(index of
  endpoint vertex, attachment index)}. A list is used to temporarily
hold the endpoints (line~106); endpoints of the same edge shall be
kept together, at the same position in the list (line~110). Finally,
the list of endpoints is used to construct a list of "Edge" objects
(line~112).\footnote{The Python syntax \l{Edge(*e)} allows calling a
  function with a list of arguments only known at runtime; it is
  briefly explained in \csref{sec:fn-special-syntax}.}

The algorithm to compute boundary cycles is complex enough to warrant
its own method "Fatgraph.compute_boundary_cycles()":
\begin{lstlisting}
    self.boundary_cycles = self.compute_boundary_cycles()
    self.num_boundary_cycles = len(self.boundary_cycles)

\end{lstlisting}

The fatgraph's genus is computed using Euler's formula $V-E+n = 2-2g$:
\begin{lstlisting}
    self.genus = (self.num_edges - self.num_vertices
          - self.num_boundary_cycles + 2) / 2

\end{lstlisting}
Finally, a few graph invariants are recorded, for quickly
checking when two graphs are not isomorphic: the (computationally
heavy) fatgraph isomorphism algorithm will only be run if all primary
invariants are equal.
\begin{lstlisting}
    # used for isomorphism testing
    self.invariants = (
        self.num_vertices,
        self.num_edges,
        self.num_boundary_cycles,
        )

\end{lstlisting}


\paragraph{Orientation.}
According to \csref{dfn:orientation}, orientation is given by an
ordering of the edges (which directly translates into an orientation
of the associated orbifold cell).

We can keep track of the orientation by mapping edges into natural
numbers in the range $[0, E)$ (where $E$ is the total number of edges
in the graph).  Since edges are represented within the "Fatgraph"
class as natural numbers in the range $[0, E)$, we need just to create
a list, indexed by edge number, that associates each edge with its
position according to the order given by the orientation.  Two such
lists need to compare equal if they differ by an even permutation.

The "orientation" attribute must be overridden each time a "Fatgraph"
object is derived from another "Fatgraph" instance (lines~123--124): e.g., when an edge
is contracted, the resulting graphs must derive its orientation from
the ``parent'' graph, if we want the edge contraction to correspond to
taking cell boundary in the orbifold model.  When no previous
orientation is given, the easiest one is chosen: the order on the set
of edges is the one induced by the (numeric) edge labels (line~126).
\begin{lstlisting}
    if 'orientation' in kwargs:
      self.edge_numbering = kwargs.get('orientation')
    else:
      self.edge_numbering = list(range(self.num_edges))

\end{lstlisting}

The above code snippet concludes the "Fatgraph.__init__" constructor
code.

According to \csref{dfn:orientable}, a fatgraph is orientable iff it
has no orientation-reversing automorphism.  There is no
way to practically ascertain if a fatgraph is orientable other than
enumerating all automorphims:
\begin{lstlisting}
  def is_oriented(self):
    """Return `True` iff `Fatgraph` is orientable."""

    for a in self.automorphisms():
      if a.is_orientation_reversing():
        return False
    # no orientation-reversing automorphism found
    return True

\end{lstlisting}


\subsubsection{Computation of boundary cycles}
\label{sec:compute-boundary-cycles}

The computation of boundary cycles is separated from the object
initialization code for clarity and to make it easier to test the
algorithm.\footnote{Python features ``doctest'' (see
  \ref{sec:doctests}): one can embed short snippets of Python code in
  the docstring of a function, to check the output of the function
  against predefined inputs.  The test cases have been expunged from
  the listing presented here.}
\begin{lstlisting}
  def compute_boundary_cycles(self):
    """
    Return a list of boundary cycles of this `Fatgraph` object.
    """
    
\end{lstlisting}
First, build the collection of ``corners'' of "graph", structuring it
like the set of vertices: the "corners" variable is a list, the $n$-th
item of which is (again) a list holding the corners around the $n$-th
vertex (i.e., "self.vertices[n]"), in the order they are encountered
when winding around the vertex.  By construction, `corners[v][i]` has
the the form "(v,i,j)" where "j" is the index following "i" in the
cyclic order, i.e., it represents the corner formed by the
``incoming'' $i$-th edge and the ``outgoing'' $j$-th edge.
%\footnote{for this we rely on the properties of Python's
%  `{\protect\Verb|%|}' (modulus) operator: for positive $n$, 
%  $k${\protect\Verb|%|}$n$ evaluates to the smallest non-negative 
%  residue of $k \text{mod} n$.}
\begin{lstlisting}
    corners = [ [ (v, i, (i+1)%len(self.vertices[v]))
                  for i in range(len(self.vertices[v])) ]
                for v in range(self.num_vertices) ]

\end{lstlisting}

The algorithm closely follows a geometrical procedure: starting with
any one corner, follow its ``outgoing'' edge to its other endpoint,
and repeat until we come back to the starting corner.  The list of
corners so gathered is a boundary cycle.  At each iteration, the used
corners are cleared out of the "corners" list by replacing them with
the special value "None", so that we won't pick them up again in
susequent iterations.

An auxiliary function is needed, to find the smallest index in a list
"L" which is associated with a non-"None" value. 
\begin{lstlisting}
    def first_index_not_none(L):
        for index, item in enumerate(L):
            if item is not None:
                return index
        return None
    
\end{lstlisting}
Note the return value of "first_index_not_none" is "None" is all
elements in list "L" are "None".

To build all boundary cycles, we loop over the list of corners (line~148).

First, scan the "corners" list to find an index pair "(v,i)" pointing
to a valid corner triple (meaning an ``unused'' corner). The trick is
to loop over all indexes in the "corners" list, and quit looping as
soon as "corners[v][i]" is not "None" (line~\nr{bcy-quit-ffwd});
Python retains the value of "v" and "i" outside the loop.
\begin{lstlisting}
    result = []
    while True:                                 |\n{bcy-main-loop}|
      # fast-forward to the first unused corner
      for v in xrange(self.num_vertices):
        i = first_index_not_none(corners[v])
        if i is not None:
          break                                 |\n{bcy-quit-ffwd}|

\end{lstlisting}
Exit loop if all corners in the list are "None": if the above loop
could not find any corner, then "v" will be the last valid index of
the "corners" list (i.e., "len(corners)-1") and "i" will be "None" (by
definition of the "first_index_not_none" function):
\begin{lstlisting}
      if v == len(corners)-1 and i is None:
        break

\end{lstlisting}
Now build a list of corners comprising the same boundary cycle: start
with the the corner "corners[v][i]", follow the edge starting at the
second delimiter of the corner to its other endpoint
(lines~\nr{bcy-follow1}--\nr{bcy-follow2} and~\nr{bcy-follow3}), and
repeat until we come back to the starting corner
(line~\nr{bcy-loop2}). At each iteration, the used corners are cleared
out of the "corners" list by replacing them with the special value
"None" (line~\nr{bcy-mark-used}).
\begin{lstlisting}
      start = (v,i)
      triples = []
      while (v,i) != start or len(triples) == 0:         |\n{bcy-loop2}|
        triples.append(corners[v][i])
        j = corners[v][i][2]                           |\n{bcy-follow1}|
        next_edge = self.vertices[v][j]                |\n{bcy-follow2}|
        corners[v][i] = None                         |\n{bcy-mark-used}|
        (v,i) = self.edges[next_edge].other_end(v, j)  |\n{bcy-follow3}|
\end{lstlisting}
The list of such corners, accumulated into the "triples" variable, is
turned into a "BoundaryCycle" object:
\begin{lstlisting}
      result.append(BoundaryCycle(triples))

\end{lstlisting}
Once we're out of the `"while True"' loop (started at
line~\nr{bcy-main-loop}), the list of all "BoundaryCycle" objects
is returned to the caller:
\begin{lstlisting}
    return result
    
\end{lstlisting}


\subsection{Construction of new fatgraphs}
\label{sec:construction}

This section lists the methods implemented in the "Fatgraph" class to
create new graphs out of existing ones by applying concrete
topological constructions.

\subsubsection{Contraction of an edge}
\label{sec:contract}

Recall from the definition in \csref{sec:contractions}) that
contraction produces a ``child'' fatgraph from a ``parent'' fatgraph
and a chosen regular (i.e., non-looping) edge. 

The "Fatgraph.contract" method thus needs only take as input the ``parent''
graph and the (label of) the edge to contract:
\begin{lstlisting}
  def contract(self, edge):
    """
    Return new `Fatgraph` obtained by contracting the specified edge.
    """

\end{lstlisting}

On the concrete fatgraph representations, the contraction algorithm
proceeds in the following way:
\begin{itemize}
\item Two vertices are merged into one. Thus the list of vertices of
  the ``child'' fatgraph (stored in the "new_vertices" variable) has
  one item less than the "self.vertices" list; we choose always to
  plug the higher-numbered vertex into the lower-numbered one, and to
  delete the higher-numbered one from the list.
\item Deletion of an edge also affects the orientation: the canonical
  orientation on the ``child'' fatgraph keeps the edges in the same
  order as they are in the parent fatgraph.  However, since
  "edge_numbering" must be a permutation of the edge indices, we need
  to renumber the edges and shift the higher-numbered edges down one
  place.
\item The new graph is constructed with the new vertices list and the
  derived orientation; the "Fatgraph" class constructor has the
  responsibility of computing the new adjacency list. 
\end{itemize}

The list of vertices of the ``child'' fatgraph is built by removing
the contracted edge and shifting all indices above:
\begin{itemize}
\item edges labeled 0 to "edge-1" are unchanged;
\item edge "edge" is temporarily kept intact, it will be
  removed by mating operation (see below);
\item edges labeled "edge+1" and above are renumbered, 
  shifting the number down one position.
\end{itemize}
This prescription is implemented through applying a mapping to every
element in the cyclic list representing a vertex.  Assuming $l$ is the
value of "edge", we make "renumber_edges" into a dictionary which
maps $i$ to $i$ for $i \leq l$, and $i$ to $i-1$ for $i > l$:
\begin{lstlisting}
    renumber_edges = { i:i 
                       for i in range(0, edge+1) }
    renumber_edges.update({ i:(i-1)
          for i in range(edge+1, self.num_edges) })
\end{lstlisting}
The above pattern will often be applied when constructing Python
"dict" objects: the dictionary is first constructed with one set of
mappings ($i \mapsto i$ for $0 \leq i < l$) and then another set of
mappings are added with the "update" method ($i \mapsto i-1$ for $l <
i < E$).

Then apply this transformation to the edge labels in each vertex, to
get the vertices of the ``child'' fatgraph. (This yields incorrect
values on the endpoints of "edge": they will be replaced shortly.)
\begin{lstlisting}
    new_vertices = [ Vertex([ renumber_edges[e] 
                              for e in V ])
                     for V in self.vertices ]

\end{lstlisting}

Assume "v1" and "v2" are the indices of the endpoint vertices of the
contracted edge, and that it appears at position "pos1" in the first
vertex and at "pos2" in the second (line~\nr{contract-1}).  Now mate
endpoints of the contracted edge:
\begin{enumerate}
\item Rotate endpoints "v1", "v2" so that the given edge "edge" would
  appear \emph{last} in "v1" and \emph{first} in "v2". (Note that, by
  construction of the "Edge" objects (\csref{sec:edges}), we have 
  "v1 < v2".) This can be accomplished by operating on the list:
\begin{lstlisting}
    def rotated(L, p):
      # return a copy of list `L`, rotated rightwards `p` places.
      return L[p+1:] + L[:p]
\end{lstlisting}
  Since "v1", "v2" are \emph{cyclic}, we can rotate "v1" and "v2" in
  the same direction (lines~\nr{contract-2a} and~\nr{contract-2b}).
\item Join vertices by concatenating the list of incident
  edges (line~\nr{contract-3}).
\item Set the newly-constructed vertex in the place of old first
  endpoint within list "new_vertices" (line~\nr{contract-4}).
\item Remove the second endpoint from the list of new vertices
  (line~\nr{contract-5}).
\end{enumerate}
\begin{lstlisting}
    # get endpoints of the contracted edge
    ((v1,pos1), (v2,pos2)) = self.edges[edge].endpoints |\n{contract-1}|

    # the mated vertex is placed at index "v1"
    new_vertices[v1] = Vertex(                          |\n{contract-4}|
      rotated(new_vertices[v1], pos1)                   |\n{contract-2a}|
      +                                                 |\n{contract-3}|
      rotated(new_vertices[v2], pos2)                   |\n{contract-2b}|
      )

    # the old vertex at index "v2" is removed
    del new_vertices[v2]                                |\n{contract-5}|

\end{lstlisting}

The list of new vertices is all that is needed to form the new
``child'' fatgraph.  However, the ``child'' fatgraph inherits an
orientation from the ``parent'' fatgraph, which might differ from the
default orientation.  Therefore, an orientation has to be derived for
the ``child'' fatgraph: let $G$ be the ``parent'' fatgraph and
$\alpha_1, \ldots, \alpha_k, \ldots, \alpha_l$ its edges, with
$\alpha_k$ being contracted to create the ``child'' graph $G'$; if
$\alpha_{m(1)} < \alpha_{m(2)} < \ldots < \alpha_{m(l)}$ (with $m(j) = k$)
is the ordering on $E(G)$ that induces the orientation on $G$, then
$\alpha_{m(1)} < \ldots < \alpha_{m(j-1)} < \alpha_{m(j+1)} < \ldots
< \alpha_{m(l)}$ descends to a total order on the edges of $G'$ and
induces the correct orientation. (I.e., the orientation that
corresponds to the orientation induced on the cell $\Delta(G')$ as a
face of $\Delta(G)$.)

Orientation is represented in a "Fatgraph" instance as a list, mapping
edge labels to a position in the total order; using the notation
above, the orientation of $G$ would be represented by the map
$n := m^{-1}$.  The orientation on $G'$ is represented by $n'$ defined
as:
\begin{equation*}
  n'(i) :=
  \begin{cases}
    n(i)    &\text{if $n(i)<k$,} 
    \\
    n(i)-1  &\text{if $n(i)>k$.}
  \end{cases}
\end{equation*}
Correspondingly, the "new_edge_numbering" is built by shifting values
in the ``parent'' fatgraph's "edge_numbering" down one position if
they are follow the contracted edge in the orientation order:
\begin{lstlisting}
    k = self.edge_numbering[edge]

    # edges with index below the contracted one are untouched
    renumber_edge_numbering = { n:n for n in range(0,k) }
    # edges with index above the contracted one are shifted down
    # one position
    renumber_edge_numbering.update({ 
        (n+1):n for n in range(k, self.num_edges) 
    })

    new_edge_numbering = [ 
        renumber_edge_numbering[self.edge_numbering[n]]
            for n in range(0,self.num_edges)
            if n != edge 
    ]
    
\end{lstlisting}

The ``child'' fatgraph can finally be constructed, overriding the
default orientation:
\begin{lstlisting}
    return Fatgraph(new_vertices, 
                    orientation=new_edge_numbering)

\end{lstlisting}


\subsubsection{The map $q(G,x,y)$: bridging two edges of a fatgraph}
\label{sec:bridge}

The method "Fatgraph.bridge" implements the construction $q(G,x,y)$
described in \csref{sec:addition}:
\begin{lstlisting}
  def bridge(self, edge1, side1, edge2, side2):
    """
    Return a new `Fatgraph`, formed by inserting trivalent
    vertices in the middle of edges `edge1` and `edge2` and
    connecting them with a new edge.
    """
\end{lstlisting}
This function must be symmetric: the pairs "edge1", "side1" and
"edge2", "side2" can be swapped and the result stays the same.

Arguments "side1" and "side2" control which side the new edge is
attached to (valid values are 0 or 1), i.e., which of the two
inequivalent cyclic orders the new trivalent vertices will be given.
In more detail: let "0", "1", "2" be the indices of the edges attached
to the new vertex in the middle of "edge1", where "0","1" denote the
labels assigned to the two halves of "edge1".  If "side1" is "0", then
the new trivalent vertex will have the cyclic order "[0,1,2]"; if
"side1" is "1", then the labels "0","1" are swapped and the new
trivalent vertex gets the cyclic order "[1,0,2]".

The construction involves 5 edges in total, 3 of which need new
labels. They will be stored in variables "connecting_edge",
"one_half1", "other_half1", "one_half2" and "other_half2".
\begin{lstlisting}
    # assign new edge indices
    connecting_edge = self.num_edges
\end{lstlisting}
Break "edge1" in two halves: one of them (see below for a precise
account) gets the old "edge1" label, the other needs a new one.
\begin{lstlisting}
    one_half1 = edge1
    other_half1 = self.num_edges + 1
\end{lstlisting}
Break "edge2" in two halves as well; if "edge2" is the same edge as
"edge1", then we are breaking the second half of "edge1" in
two parts.  Otherwise, proceed as above.  In any case, the
"other half" of "edge2" needs a new edge label.
\begin{lstlisting}
    if edge2 == edge1:
      one_half2 = other_half1
    else:
      one_half2 = edge2
    other_half2 = self.num_edges + 2

\end{lstlisting}
The list of edges for the new fatgraph can now be constructed, but the
endpoints for the new edges have to be filled in
later.\footnote{There's a ``chicken and egg'' issue: we need the
  new vertices to construct the endpoints, but we need the edge labels
  to construct the vertices.  So, the edge labels are assigned first,
  then vertices are constructed and then finally the new edge
  endpoints are created.\label{fn:chicken-and-egg}}
\begin{lstlisting}
    # three new edges are added (constructed below)
    new_edges = self.edges + [
      None, # new edge: "connecting_edge"
      None, # new edge: "other_half1"
      None, # new edge: "other_half2"
      ]
\end{lstlisting}

Two new vertices are also created: the mid-points of the connected
edges. Depending on the value of "side1" (resp.~"side2"), one of the
two inequivalent cyclic orders is chosen on the new vertex "midpoint1"
(resp.~"midpoint2").
\begin{lstlisting}
    # assign new vertex indices
    midpoint1_index = self.num_vertices
    midpoint2_index = self.num_vertices + 1

    if side1 == 1:                                   |\n{bridge-midpoints-1}|
      midpoint1 = Vertex([other_half1, one_half1, connecting_edge])
    else: # side2 == 0
      midpoint1 = Vertex([one_half1, other_half1, connecting_edge])

    if side2 == 1:
      midpoint2 = Vertex([other_half2, one_half2, connecting_edge])
    else: # side2 == 0
      midpoint2 = Vertex([one_half2, other_half2, connecting_edge])

    # two new vertices are added: the mid-points of the connected edges.
    new_vertices = self.vertices + [midpoint1, midpoint2]

\end{lstlisting}
Once the new vertices have been constructed, the "Edge" objects can
also.

The connecting edge has endpoints in the mid-points of
"edge1" and "edge2", and is always in third position.
\begin{lstlisting}
    new_edges[connecting_edge] = Edge((midpoint1_index, 2), (midpoint2_index, 2))

\end{lstlisting}
A couple of shortcut variables are introduced to make the code cleaner:
\begin{lstlisting}
    opposite_side1 = 0 if (side1==1) else 1
    opposite_side2 = 0 if (side2==1) else 1

\end{lstlisting}

Construct the two halves of "edge1": if "v1a" and "v1b" are the
endpoints of "edge1", then the "one_half" edge extends from the "v1a"
endpoint of "edge1" to the new vertex "midpoint1".  The "other_half"
edge extends from the "midpoint1" new vertex to "v1b"; if we are
bridging an edge with itself ("edge1 == edge2") then "other_half"
ends in "midpoint2" instead.
\begin{lstlisting}
    ((v1a, pos1a), (v1b, pos1b)) = self.edges[edge1].endpoints

    new_edges[one_half1] = Edge((v1a, pos1a), 
                                (midpoint1_index, side1))
    if edge1 != edge2:
      # replace "edge1" with new "other_half1" in the second endpoint
      new_vertices[v1b] = Vertex(new_vertices[v1b][:pos1b]
                         + [other_half1]
                         + new_vertices[v1b][pos1b+1:])
      new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), 
                                    (v1b, pos1b))
    else:                                                        |\n{bridge-other-half1-1}|
      # same edge, the `other half' ends at the second endpoint
      new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), 
                                    (midpoint2_index, side2))    |\n{bridge-other-half1-2}|

\end{lstlisting}
Note that, when replacing the second endpoint in vertex "v1b", we need
to construct a new "Vertex" object, since "Vertex" instances can be
shared among different "Fatgraph" instances.

Also note that "side1" and "side2" are used as attachment indices in
the code snippet above; this is due to the choice of the cyclic list
representatives when defining "midpoint1" and "midpoint2"
(line~\nr{bridge-midpoints-1} and following ones).

A similar construction is applied to "edge2": again we need to distinguish the special case when
"edge1" and "edge2" are the same edge.  When the two bridged edges are
different, then "one_half2" extends from
"v2a" to "midpoint2"; otherwise, "one_half2" and "other_half1" hold
the the same edge, and the endpoints of "other_half1" have already
been correctly set in lines~\nr{bridge-other-half1-1} to~\nr{bridge-other-half1-2}.
\begin{lstlisting}
    ((v2a, pos2a), (v2b, pos2b)) = self.edges[edge2].endpoints

    if edge1 != edge2:
      new_edges[one_half2] = Edge((v2a, pos2a), (midpoint2_index, side2))
    else:
      # "edge1 == edge2", so "one_half2" == "other_half1"
      pass # that is: "new_edges[one_half2] = new_edges[other_half1]"
\end{lstlisting}
The "other_half2", instead, always ends at the endpoint "v2b", so we
can unconditionally replace "edge2" for "other_half2" in "v2b".
\begin{lstlisting}
    new_vertices[v2b] = Vertex(new_vertices[v2b][:pos2b]
                       + [other_half2]
                       + new_vertices[v2b][pos2b+1:])
    new_edges[other_half2] = Edge((midpoint2_index, opposite_side2), (v2b, pos2b))

\end{lstlisting}

Orientation is inherited from the ``parent'' graph, adding the three
new edge labels in the order they were created:
\begin{lstlisting}
    new_edge_numbering = self.edge_numbering + \
               [connecting_edge, other_half1, other_half2]

\end{lstlisting}
Finally, the ``child'' graph can be built, overriding the default
orientation and the construction of the adjacency list (for
computational efficiency):
\begin{lstlisting}
    return Fatgraph(new_vertices,
            edges = new_edges,
            num_edges = self.num_edges + 3,
            orientation = new_edge_numbering,
            )

\end{lstlisting}


\subsubsection{The map $p(G,x)$: add a simple boundary cycle}
\label{sec:hangcircle}

The method "Fatgraph.bridge" implements the construction $q(G,x,y)$
described in \csref{sec:addition}:
\begin{lstlisting}
  def hangcircle(self, edge, side):
    """
    Return a new `Fatgraph`, formed by attaching a circle with
    a new edge to a new trivalent vertex in the middle of `edge`.
    """
\end{lstlisting}
The implementation of "Fatgraph.hangcircle" is closely related to
"Fatgraph.bridge" (see \csref{sec:bridge}): break "edge" in two
halves: if "v1" and "v2" are the endpoints of "edge", then the
"one_half" edge extends from "v1" to the new vertex "midpoint"; the
"other_half" edge extends from the new "midpoint" vertex to "v2".

In particular, argument `side` controls which side of "edge" the
circle is hung to (valid values are "0" or "1"), i.e., which of the
two inequivalent cyclic orders the new "midpoint" vertex will be
given.

The new graph will have 3 edges more than the original one, all of
which need new edge labels:
\begin{lstlisting}
    one_half = edge
    other_half = self.num_edges
    connecting_edge = self.num_edges + 1
    circling_edge = self.num_edges + 2
    
    new_edges = self.edges + [
      None, # new edge: "other_half"
      None, # new edge: "connecting_edge"
      None, # new edge: "circling_edge"
      ]
\end{lstlisting}
Endpoint data for the new edges can only be filled once the new
vertices have been constructed (see note~\ref{fn:chicken-and-egg} on
page~\pageref{fn:chicken-and-egg}).% or \thefootnote
%  http://anthony.liekens.net/index.php/LaTeX/MultipleFootnoteReferences

Two new vertices are added: the mid-point of "edge", and
the vertex "T" lying on the circle.
\begin{lstlisting}
    midpoint_index = self.num_vertices
    T_index = self.num_vertices + 1

    if side == 1:
      midpoint = Vertex([other_half, one_half, connecting_edge])
    else: # side == 0
      midpoint = Vertex([one_half, other_half, connecting_edge])

    T = Vertex([circling_edge, circling_edge, connecting_edge])
    new_vertices = self.vertices + [midpoint, T]

\end{lstlisting}

Break "edge" into two edges "one_half" and "other_half": we set the
new endpoints in the corresponding entries in "new_edges" and then
replace "edge" with "other_half" in the endpoint "v2":
\begin{lstlisting}
    ((v1, pos1), (v2, pos2)) = self.edges[edge].endpoints

    opposite_side = 0 if side else 1

    new_edges[one_half] = Edge((v1, pos1), 
                               (midpoint_index, side))
    new_edges[other_half] = Edge((midpoint_index, opposite_side), 
                                 (v2, pos2))

    new_vertices[v2] = Vertex(new_vertices[v2][:pos2]
                       + [ other_half ]
                       + new_vertices[v2][pos2+1:])

\end{lstlisting}

The connecting edge has endpoints in the mid-point of
"edge" and in "T", and is always in third position:
\begin{lstlisting}
    new_edges[connecting_edge] = Edge((midpoint_index, 2), 
                                      (T_index, 2))

\end{lstlisting}

The circling edge is a loop with vertex "T":
\begin{lstlisting}
    new_edges[circling_edge] = Edge((T_index, 0), 
                                    (T_index, 1))

\end{lstlisting}

Orientation is inherited from the ``parent'' graph, adding the three
new edge labels in the order they were created:
\begin{lstlisting}
    new_edge_numbering = self.edge_numbering + \
               [other_half, connecting_edge, circling_edge]

\end{lstlisting}

Finally, the ``child'' graph can be built, overriding the default
orientation and the construction of the adjacency list (for
computational efficiency):
\begin{lstlisting}
    return Fatgraph(new_vertices,
            edges = new_edges,
            num_edges = self.num_edges + 3,
            orientation = new_edge_numbering,
            )
\end{lstlisting}


\subsubsection{Fatgraphs isomorphism and equality testing}
\label{sec:isomorphism}


\begin{lstlisting}
  def isomorphisms(G1, G2):
    """Iterate over `Fatgraph` isomorphisms from `G1` to `G2`.

    An isomorphism is represented by a tuple `(pv, rot, pe)` where:

      - `pv` is a permutation of ther vertices: the `i`-th vertex
      of `G1` is sent to the `pv[i]`-th vertex of `G2`, rotated
      by `rot[i]` places leftwards;

      - `pe` is a permutation of the edges: edge `i` in `G1` is
      mapped to edge `pe[i]` in `G2`.

    This method can iterate over the automorphism group of a
    graph::

      >>> G1 = Fatgraph([Vertex([2, 1, 1]), Vertex([2, 0, 0])])
      >>> for f in G1.isomorphisms(G1): print f
      ({0: 0, 1: 1}, [0, 0], {0: 0, 1: 1, 2: 2})
      ({0: 1, 1: 0}, [0, 0], {0: 1, 1: 0, 2: 2})

    Or it can find the isomorphisms between two given graphs::

      >>> G2 = Fatgraph([Vertex([2, 2, 0]), Vertex([1, 1, 0])])
      >>> for f in G1.isomorphisms(G2): print f
      ({0: 0, 1: 1}, [2, 2], {0: 1, 1: 2, 2: 0})
      ({0: 1, 1: 0}, [2, 2], {0: 2, 1: 1, 2: 0})

    If there are no isomorphisms connecting the two graphs, then no
    item is returned by the iterator::

      >>> g3 = Fatgraph([Vertex([2, 1, 0]), Vertex([2, 0, 1])])
      >>> list(G1.isomorphisms(g3))
      []
    """
    
    # As this procedure is quite complex, we break it into a
    # number of auxiliary functions.
    
    def starting_vertices(graph):
      """
      Return the pair `(valence, vertices)`, which minimizes the
      product of valence with the number of vertices of that
      valence.

      Examples::

        >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,3]), Vertex([3,4,4,5,5])])
        >>> g.starting_vertices()
        (5, [Vertex([3, 4, 4, 5, 5])])
      """
      val = max(graph.vertex_valences())
      vs = None
      n = len(graph.vertices)+1
      for (val_, vs_) in graph.valence_spectrum().iteritems():
        n_ = len(vs_)
        if (n_*val_ < n*val) \
             or (n_*val_ == n*val and val_<val):
          val = val_
          vs = vs_
          n = n_
      return (val, vs)

    def compatible(v1, v2):
      """Return `True` if vertices `v1` and `v2` are compatible.
      (i.e., same valence and number of loops - one *could* be
      mapped onto the other.)
      """
      if len(v1) == len(v2) and v1.num_loops == v2.num_loops:
        return True
      else:
        return False
        
    def admissible_vertex_mappings(v, g, ixs):
      """Iterate over all (indices of) vertices in `g`, which
      `v` *could* be mapped to (that is, the destination vertex
      matches `v` in valence and number of loops.

      Third argument `ixs` restricts the search to the given
      subset of vertex indices in `g`.
      """
      for i in ixs:
        if compatible(v, g.vertices[i]):
          yield i

    class CannotExtendMap(Exception):
      """Exception raised by `extend_map` on failure to extend a
      partial map.
      """
      pass

    def extend_map(pv, rots, pe, G1, i1, r, G2, i2):
      """Extend map `(pv, rots, pe)` by mapping the `i1`-th
      vertex in `G1` to the `i2`-th vertex in `G2` (and rotating
      the source vertex by `r` places leftwards).  Return the
      extended map `(pv, rot, pe)`.

      The partial map is a triple `(pv, rot, pe)` as in
      `Fatgraph.isomorphism` (which see), with the additional
      proviso that unassigned items in `rot` are represented by
      `None`.
      """
      v1 = G1.vertices[i1]
      v2 = G2.vertices[i2]
      if not compatible(v1, v2):
        raise CannotExtendMap

      # XXX: rotation has to be >=0 for the [r:r+..] shift below to work
      if r < 0:
        r += len(v2)

      if pv.has_key(i1):
        if pv[i1] != i2 or (rots[i1] - r) % len(v2) != 0:
          raise CannotExtendMap
        else:
          # this pair has already been added
          return (pv, rots, pe)

      pv[i1] = i2
      rots[i1] = r

      # rotating "v1" leftwards is equivalent to rotating "v2" rightwards...
      v2 = v2[r:r+len(v2)]
      if not pe.extend(v1, v2):
        raise CannotExtendMap

      return (pv, rots, pe)

    def neighbors(pv, pe, G1, v1, G2, v2):
      """List of vertex-to-vertex mappings that extend map `pv`
      in the neighborhood of vertices `v1` (in the domain) and
      `v2` (in the codomain).

      Return a list of triplets `(src, dst, rot)`, where:
         * `src` is the index of a vertex in `G1`,
         connected to `v1` by an edge `x`;
         * `dst` is the index of a vertex in `G2`,
         connected to `v2` by the image (according to `pe`)
         of edge `x`;
         * `rot` is the rotation to be applied to `G1[src]`
         so that edge `x` and its image appear
         at the same index position;
      """
      result = []
      for x in G1.vertices[v1]:
        if G1.edges[x].is_loop():
          continue # with next edge `x`
        ((s1, a1), (s2, a2)) = G1.edges[x].endpoints
        src_v = s2 if (s1 == v1) else s1
        # ignore vertices that are already in the domain of `m`
        if src_v in pv:
          continue # to next `x`
        src_i = a2 if (s1 == v1) else a1
        ((d1, b1), (d2, b2)) = G2.edges[pe[x]].endpoints
        dst_v, dst_i = (d2,b2) if (d1 == v2) else (d1,b1)
        # array of (source vertex index, dest vertex index, rotation)
        result.append((src_v, dst_v, dst_i-src_i))
      return result
      
    # if graphs differ in vertex valences, no isomorphisms
    vs1 = G1.valence_spectrum()
    vs2 = G2.valence_spectrum()
    if not set(vs1.keys()) == set(vs2.keys()):
      return # StopIteration
    # if graphs have unequal vertex distribution by valence, no isomorphisms
    for val in G1.vertex_valences():
      if len(vs1[val]) != len(vs2[val]):
        return # StopIteration

    (val, vs) = starting_vertices(G1)
    src0 = vs[0]
    V1 = G1.vertices[src0]
    for dst0 in admissible_vertex_mappings(V1, G2, vs2[val]):
      for rot0 in range(val):
        try:
          # pass 0: init new (pv, rots, pe) triple
          pv = Permutation()
          rots = [ None for x in range(G1.num_vertices) ]
          pe = Permutation()

          # pass 1: map `V1` to "v2" and build map
          # of neighboring vertices for next pass
          pv[src0] = dst0
          rots[src0] = rot0
          if not pe.extend(V1, G2.vertices[dst0][rot0:rot0+val]):
            continue # to next `rot0`

          # pass 2: extend map to neighboring vertices
          nexts = neighbors(pv, pe, G1, src0, G2, dst0)
          while len(pv) < G1.num_vertices:
            neighborhood = []
            for (i1, i2, r) in nexts:
              (pv, rots, pe) = extend_map(pv, rots, pe, G1, i1, r, G2, i2)
              neighborhood += neighbors(pv, pe, G1, i1, G2, i2)
            nexts = neighborhood

        # extension failed in the above block, continue with next candidate
        except CannotExtendMap:
          continue # to next "rot0"

        # finally
        yield Isomorphism(G1, G2, pv, rots, pe)


  # Instances of this class will compare equal if there is an
  # isomorphism mapping one to the other.
  def __eq__(self, other):
    """Return `True` if `self` and `other` are isomorphic."""

    # shortcuts
    if self is other:
      return True
    if self.invariants != other.invariants:
      return False

    # go the long way: try to find an explicit isomorphims
    # between "self" and "other"
    try:
      # if there is any morphism, then return "True"
      self.isomorphisms(other).next()
      return True
    except StopIteration:
      # list of morphisms is empty, objects are not equal.
      return False


  # both "__eq__" and "__ne__" are needed 
  # for testing equality of Python objects
  def __ne__(self, other):
    """The opposite of `__eq__` (which see)."""
    return not self.__eq__(other)


  def automorphisms(self):
    """Enumerate automorphisms of this `Fatgraph` object.

    See `.isomorphisms()` for details of how a `Fatgraph`
    isomorphism is represented.
    """
    return self.isomorphisms(self)


  def num_automorphisms(self):
    """Return the cardinality of the automorphism group of this
    `Fatgraph` object.

    Examples::

      >>> Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])]).num_automorphisms()
      6
      >>> Fatgraph([Vertex([0,1,1]), Vertex([0,2,2])]).num_automorphisms()
      2
    """
    return len(list(self.automorphisms()))
  

  def valence_spectrum(self):
    """Return a dictionary mapping valences into vertex indices.

    Examples::

       >>> Fatgraph([Vertex([1,1,0,0])]).valence_spectrum()
       {4: [0]}

       >>> Fatgraph([Vertex([1,1,0]), Vertex([2,2,0])]).valence_spectrum()
       {3: [0, 1]}

       >>> Fatgraph([Vertex([3, 1, 0, 1]), \
            Vertex([4, 4, 0]), Vertex([3, 2, 2])]).valence_spectrum()
       {3: [1, 2], 4: [0]}
    """
    result = {}
    for (index, vertex) in enumerate(self.vertices):
      l = len(vertex)
      if l in result:
        result[l].append(index)
      else:
        result[l] = [index]
    return result

  def vertex_valences(self):
    return frozenset(len(v) for v in self.vertices)

  def vertex_valence_distribution(self):
    spec = self.valence_spectrum()
    return dict((v, len(spec[v]))
                for v in spec.iterkeys())
\end{lstlisting}


\begin{lstlisting}
class Isomorphism(object):
  """
  An isomorphism of `Fatgraphs`.
  """

  def __init__(self, source, target, pv, rot, pe):
    self.source = source
    self.target = target
    self.pe = pe
    self.rot = rot
    self.pv = pv

  def __str__(self):
    return "(%s, %s, %s)" % (self.pv, self.rot, self.pe)

  def compare_orientations(self):
    """
    Return +1 or -1 depending on whether the 
    orientations of the target Fatgraph pulls 
    back to the orientation of the source 
    `Fatgraph` via this `Isomorphism`.
    """
    image_edge_numbering = Permutation((self.source.edge_numbering[x],
                                        self.target.edge_numbering[self.pe[x]])
                                       for x in range(self.source.num_edges))
    return image_edge_numbering.sign()

  def is_orientation_reversing(self):
    """Return `True` if this `Isomorphism` reverses orientation on
    the source and target `Fatgraph` instances."""
    return (-1 == self.compare_orientations())

  def transform_boundary_cycle(self, bcy):
    """Return a new `BoundaryCycle` instance, obtained by
    transforming each corner according to a graph isomorphism.
    """
    triples = []
    for (v, i, j) in bcy:
      l = len(self.source.vertices[v])
      # create transformed triple 
      v_ = self.pv[v]
      i_ = (i + self.rot[v]) % l
      j_ = (j + self.rot[v]) % l
      # ensure the contract is honored, that `j` is the
      # index following `i` in the cyclic order
      if i_ == 0 and j_ == l:
        i_, j_ = j_, i_
      triples.append((v_, i_, j_))
    return BoundaryCycle(triples, self.target)
\end{lstlisting}

\subsubsection{Complementary methods}
\label{sec:complementary}

This section briefly lists those methods of the "Fatgraph" class that
are needed for proper working of the class, but do not have any
special interest.

\begin{lstlisting}
  def assimilate(self, other):
    """
    Copy-constructor: make `self` equal to `other`.

    The modified `Fatgraph` instance *shares* all attributes
    with the instance given as argument::

      >>> g2.vertices is g1.vertices
      True
      >>> g2.edge_numbering is g1.edge_numbering
      True
      >>> g2.edges is g1.edges
      True
    """
    self.boundary_cycles = other.boundary_cycles
    self.edges = other.edges
    self.edge_numbering = other.edge_numbering
    self.genus = other.genus
    self.num_boundary_cycles = other.num_boundary_cycles
    self.num_edges = other.num_edges
    self.num_vertices = other.num_vertices
    self.vertices = other.vertices
    self.invariants = (
        self.num_vertices,
        self.num_edges,
        self.num_boundary_cycles,
        )


  def edge_orbits(self):
    """Compute orbits of the edges under the action of graph
    automorphism group, and a representative for each orbit.
    
    Returns a dictionary, whose keys are the representatives, and
    whose values are the orbits.  Orbits are represented as Python
    `set` objects.

    Examples::

      >>> Fatgraph([Vertex([0,1,2]), Vertex([0,1,2])]).edge_orbits()
      {0: set([0, 1, 2])}

      >>> Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]).edge_orbits()
      {0: set([0, 1, 2])}
      
    """
    orbits = dict( (x, set([x])) for x in range(self.num_edges) )
    for a in self.automorphisms():
      for x in range(self.num_edges):
        if x not in orbits:
          continue
        y = a.pe[x]
        if y not in orbits:
          continue
        # "x" and "y" are in the same orbit, only keep the one
        # with lower abs. value, and remove the other.
        if y > x:
          orbits[x].update(orbits[y])
          del orbits[y]
    return orbits

  def edge_pair_orbits(self):
    """Compute orbits of pairs `(edge1, edge2)` under the action
    of graph automorphism group, and a representative for each
    orbit.
    
    Returns a dictionary, whose keys are the representatives, and
    whose values are the orbits.  Orbits are represented as Python
    `set` objects.

    Examples::

      >>> Fatgraph([Vertex([0,1,2]), Vertex([0,1,2])]).edge_pair_orbits()
      {(0, 1): set([(0, 1), (1, 2), (2, 0)]),
       (0, 0): set([(0, 0), (1, 1), (2, 2)]),
       (0, 2): set([(1, 0), (0, 2), (2, 1)])}
      
    """
    edge_pairs = [ (x,y) 
             for x in range(self.num_edges)
             for y in range(self.num_edges) ]
    orbits = dict( (p, set([p])) for p in edge_pairs )
    for a in self.automorphisms():
      for p in edge_pairs:
        if p not in orbits:
          continue
        q = (a.pe[p[0]], a.pe[p[1]])
        if q not in orbits:
          continue
        # "p" and "q" are in the same orbit, only keep the one
        # with lower abs. value, and remove the other.
        if p < q:
          orbits[p].update(orbits[q])
          del orbits[q]
    return orbits


  def endpoints(self, edgeno):
    """Return the endpoints of `edge`, as a pair of `(v, pos)`
    where `v` is the endpoint vertex index, and `pos` is the
    attachment index of `edge` into the `Vertex` object
    `self.vertices[v]`.

    The pair `((v1, pos1), (v2, pos2))` is ordered such that `v1 < v2`.
    """
    return self.edges[edgeno].endpoints


  def is_loop(self, edge):
    """
    Return `True` if `edge` is a loop (i.e., the two endpoint coincide).
    """
    return self.edges[edge].is_loop()
\end{lstlisting}


\paragraph{Printed representation.}
On "Fatgraph" objects, both "__repr__" and "__str__" return the
same string, i.e., the constructor invocation with the vertex list,
which is guaranteed to produce an isomorphic "Fatgraph" instance.
\begin{lstlisting}
  def __repr__(self):
    return "Fatgraph(%s)" % repr(self.vertices)
  
  def __str__(self):
    return repr(self)

\end{lstlisting}



\section[Stage II]{Stage II: compute boundary operator matrices}
\label{sec:stage-ii}

\section[Stage III]{Stage III: compute Betti numbers of $\M_{g,n}$}
\label{sec:stage-iii}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 
