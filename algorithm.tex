
\chapter[An algorithm for graph homology]
  {An algorithm for computing graph homology}
\label{chap:algorithm}

This chapter presents an algorithm to compute homology of the fatgraph
complex $\R_{g,n}$.  By \csref{thm:fatgraph-homology}, this is
tantamount to the (co)homology with rational coefficients of the
moduli spaces $\M_{g,n}$. An effective computer implementation of the
algorithm is presented, which is capable of computing the Betti
numbers of $\M_{g,n}$ for $(2g+n) < 6$ on standard desktop-class
hardware.  The size of the fatgraph complex increases factorially with
$2g+n$, so a parallel algorithm is needed to compute the Betti numbers
of $\M_{g,n}$ for $(2g+n) \geq 6$; this will be the subject of a later
chapter.

Generators of the homology modules could be computed with a little
variant in the last step of the algorithm; however, this is not
interesting in connection with the homology of $\M_{g,n}$, since
expression of a fatgraph homology class in terms of algebro-geometric
classes has proved to be a difficult problem 
\cite{mondello:2004,
  igusa:combinatorial-miller-morita-mumford-classes-and-witten-cycles,
  igusa:graph-cohomology-and-kontsevich-cycles},
and to-date lacks a general solution.

The Python programming language is used in this chapter to articulate
the algorithm.  Python claims to be ``executable pseudo-code'',
combining a readable and ``natural'' syntax that makes it well suited
to teaching programming to novices \cite{georgatos:python}, with the
power of a general-purpose language that is presently in daily use for
several real-world applications (see, e.g., \cite{python:success}).
The advantage is clear: the code listed in this chapter can be copied
to a Python file and actually executed.  For the reader's convenience,
\csref{chap:python} recaps the Python syntax and briefly explains the
constructs and idioms used in programming this algorithm.


\section[Overview]{Overview of the algorithm}
\label{sec:overview}

\csref{thm:fatgraph-homology} provides an effective way to compute the
(co)homology of $\M_{g,n}$.  The Betti numbers of $\M_{g,n}$ can be
computed from the knowledge of the dimension of chain spaces $W_p$ and
the ranks of the boundary operators $D_p$; this can effectively be
accomplished in the following stages:
\begin{enumerate}[I.]
\item Compute the basis set of $W_*$; by definition, the basis set is
  the set of \emph{orientable} fatgraphs indexing
  the cells of $\Mcomb_{g,n}$.
\item Work out the differential $D: W_* \to W_*$ in an
  effectively computable way, i.e., as matrix operators $D_p$ mapping
  coordinates in the fatgraph basis of $W_p$ into coordinates
  w.r.t. the fatgraph basis of $W_{p-1}$.
\item Compute the ranks of the matrices $D_p$.
\end{enumerate}

Stage~I needs just the pair $g,n$ as input; its output is the set of
orientable numbered fatgraphs belonging in $\R_{g,n}$: the core of
Stage~I is an algorithm to enumerate the fatgraph of given genus and
number of boundary cycles. By definition, numbered fatgraphs are
decorated abstract fatgraphs, and the decoration is a simple
combinatorial datum: therefore, the problem can be reduced to
enumerating abstract fatgraphs.  With a recursive algorithm, one can
construct trivalent $\M_{g,n}$-fatgraphs from $\M_{g-1,n}$ and
$\M_{g',n'} \times \M_{g'',n''}$ with $g'+g''=g$ and $n'+n''=n$; all
other graphs are gotten by contraction of regular edges.

The differential $D$ has a simple geometrical definition: $D(G)$ is a
sum of graphs $G'$ gotten by contracting a non-loop edge of $G$. A
naive implementation of Stage~II would just compare each contraction
of a graph with $k$ edges with any graph with $k-1$ edges, and score a
$\pm 1$ in the corresponding entry of the matrix $D_k$.  However, this
algorithm has quadratic complexity, and the large number of graphs
involved make it very inefficient already for $\M_{0,5}$.  The simple
observation that contraction of edges is defined on the topological
fatgraph underlying a numbered fatgraph allows us to apply the naive
algorithm to topological fatgraphs ---which cuts complexity down by a
factor~$(n!)^2$---, and then extend the result by the action of graph
automorphism groups on the numberings of boundary cycles.  This
is the variant detailed in \csref{sec:stage-ii}.

Stage~III is the simplest: by elementary linear algebra, the Betti
numbers can be computed from the rank of matrices $D_k$ and the
dimension of their domain space.  The computational problem of
determining the rank of a matrix has been extensively studied, and
several implementations of popular algorithms are already available in
the form of function libraries, ready for use. It should be noted,
however, that this is the step that consumes more computer time
(except for the very simple cases $2g+n<5$).

\section[Stage I]{Stage I: generate the fatgraphs complex}
\label{sec:stage-i}

Exposition of the Stage~I code will proceed in a \emph{top-down}
fashion: we shall work our way from the topmost function, which
returns the collection of all fatgraphs in $\R_{g,n}$, down to the
computer representation of a fatgraph.  This way, requirements that
functions and objects must satisfy become evident during the analysis,
and implementation details are introduced only when needed.

\subsection{Generation of all Fatgraphs in $\R_{g,n}$}
\label{sec:stage1-all}

Computations in Stage~I output the set of orientable fatgraphs
$\R_{g,n}$ from the input pair $g, n$, with $2g +n - 2 > 0$.  The
numbering will be added in Stage~II of the algorithm, so just the set
of undecorated fatgraphs is output here.

Let "MgnGraphs" be the function which, given the two integers $g$,
$n$ as input, and returns the collection of $\R_{g,n}$ graphs.  Let us
further stipulate that the output result will be represented as a
Python "list": the $0$-th item in this list is the list of graphs
with the maximal number $m$ of edges; the $k$-th item in the list is
the list of graphs having $m - k$ edges.  There are algorithmic
advantages in this subdivision, which are explained below.

The Python implementation of the "MgnGraphs" function is as follows:
\begin{lstlisting}[name=MgnGraphs,firstnumber=1]
def MgnGraphs(g,n):
  """
  Return all connected fatgraphs having
  prescribed genus `g` and number of boundary cycles `n`.
  """
  # `graphs` is the function output -- start with an empty list
  graphs = []

  # maximum number of edges
  m = 4*g + 2*n - 5
\end{lstlisting}
Graphs with the maximal number of edges are trivalent graphs; they are
computed by a separate function "MgnTrivalentGraphs", described in
\csref{sec:stage1-trivalent}.
\begin{lstlisting}[name=MgnGraphs,firstnumber=11]
  # first item `graphs[0]` contains all 3-valent graphs
  graphs.append(list(MgnTrivalentGraphs(g,n)))
\end{lstlisting}
We can then proceed to generating all graphs in $\R_{g,n}$ by
sequential contraction of graphs edges: by contracting one edge in
trivalent graphs we get the list \l{graphs[1]} of all graphs with
$m-1$ edges; contracting one edge in $G \in \text{\l{graphs[1]}}$, we
get $F \in \text{\l{graphs[2]}}$ with $m-2$ edges; and so on:
\begin{lstlisting}[name=MgnGraphs,firstnumber=13]
  for k in range(1,m):
    graphs.append([]) # start with empty list
    for G in graphs[k-1]:
      for e in G.edge_orbits():
        if not e.is_loop():
          F = G.contract(e)
          if F not in graphs[k]:
            graphs[k].append(F)
\end{lstlisting}
A line-by-line explanation is in order.

At line 13, the "range(1,m)" function sequentially generates all
integers in the half-open range $[1, m)$; therefore, the "for"-loop
body in lines 14--20 is executed $m-1$ times, with $k$ taking the
values $1$, ..., $m-1$ in order.  Note that, by Python syntax, the
loop body is indented w.r.t the loop head line.

At line 14, \l{graph[k]} is initialized to an empty list: at the start
of the loop body, the "graphs" list only has items \l{graphs[0]}
through \l{graphs[k-1]}.

Line 15 introduces a new loop: code in lines 16--20 will be executed
once for each fatgraph "G" in \l{graphs[k-1]}.

Line 16 starts the core of the function: contract edges of the
fatgraph "G" to generate new fatgraphs with $m-k$ edges.  However,
we need not contract every edge of a fatgraph: if $a \in \Aut(G)$ is
an automorphism and $x \in E(G)$ is an edge, then the contracted
graphs $G' = G/x$ and $G'' = G/a(x)$ are isomorphic.  Hence, we can
restrict the computation to consider only one edge per orbit of the
action induced by $\Aut(G)$ on the set $E(G)$. This is what the method
call "G.edge_orbits()" provides: for each graph "G", it partitions
the set of edges of "G" into orbits and returns one representative
edge "e" for each one.

Line 17 skips non-regular edges: the following code is executed if and
only if "e" is not a loop.

Line 18 computes the fatgraph "F" obtained by contracting the
current edge "e" in "G": the "Fatgraph.contract(G,e)" invocation
returns a \emph{new} fatgraph instance obtained by applying
topological contraction.

Lines 19--20 add "F" to \l{graphs[k]} \emph{only if it is not
  already there}.  This is actually very concise syntax for the most
computationally expensive part of the "MgnGraphs" function: Python
performs a comparison between "F" and each element in \l{graphs[k]};
each comparison invokes the "Fatgraph.__eq__" method, which in turn
invokes "Fatgraph.isomorphism".

If $N_k = \text{\l{len(graph[k])}}$ is the number of elements in
\l{graph[k]} and $T_\text{iso}$ is the average time needed to
determine if two graphs are isomorphic, then evaluating the expression
``\l{F in graphs[k]}'' takes $O(N_k \cdot T_\text{iso})$ time: thus, the
subdivision of "graphs" into lists, each one holding graphs with a
specific number of edges, reduces the number of fatgraph comparisons
done in the innermost loop of "MgnGraphs".  (Although graphs with a
different number of edges are readily seen not to be isomorphic, the
isomorphism test is performed in the innermost loop, so it is executed
nonetheless a considerable number of times, and each saving, albeit
small, can result in a substantial shortening of the total running
time.)

Finally, function "MgnGraphs" exits and returns the list "graphs" to the
caller:
\begin{lstlisting}[name=MgnGraphs,firstnumber=21]
  # "graphs" is the final output of this function
  return graphs
\end{lstlisting}

Note that the top-level function "MgnGraphs" is quite independent of
the actual Python implementation of the "Fatgraph" type of objects:
all is needed here, is that a "Fatgraph" instance has methods for
enumerating edges, contracting an edge, and testing two graphs for
isomorphism.

\begin{lemma}
  If "MgnTrivalentGraphs(g,n)" returns the complete list of
  \emph{trivalent} fatgraphs in $\R_{g,n}$, then the function
  "MgnGraphs" defined above returns the complete set of fatgraphs
  $\R_{g,n}$.
\end{lemma}
\begin{proof}
  By the above dissection of the algorithm, all we need to prove is
  that any fatgraph in $\R_{g,n}$ can be obtained by a chain of edge
  contractions from a trivalent fatgraph.  This follows immediately
  from the fact that any fatgraph vertex $V$ of valence $v \geq 3$ can
  be expanded (in several ways) into vertices $V_1$, $V_2$ of valences
  $v_1$, $v_2$ such that $v = (v_1 -1) + (v_2 -1)$, plus a connecting
  edge.
\end{proof}


\subsection{Generation of Trivalent Fatgraphs}
\label{sec:stage1-trivalent}

The generation of trivalent graphs can be tackled by an inductive
procedure: given a trivalent graph, a new edge is added, which joins
the midpoints of two existing edges.  
In order to determine which graphs should be input to the ``edge
addition'' procedure, one can instead follow the reverse route, and
ascertain how a trivalent graph is transformed by \emph{deletion} of
an edge.

Throughout this section, $V$ and $E$ stand for the number of vertices
(resp.~edges) of a graph; which exact graph they are invariants of
will be clear from the context.

\subsubsection{Removal of edges}
\label{sec:removal}

Let $G \in \R_{g,n}$ be a \emph{connected} trivalent graph. Each edge
$x \in E(G)$ falls into one of the following categories:
\begin{enumerate}[\slshape A)]
\item $x$ is a loop: both endpoints of $x$ are
  attached to a single vertex $v$; another edge $x'$ joins $v$ with a
  distinct vertex $v'$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ and separates two distinct boundary cycles $\beta, \beta'
  \in B(G)$;
\item $x$ joins two distinct vertices $v, v'
  \in V(G)$ but belongs to only one boundary cycle $\beta \in B(G)$
  (in which it occurs twice, once for each orientation).
\end{enumerate}
Deletion of edge $x$ requires different adjustments in order to get a
trivalent graph again in each of the three cases above; it also yields
a different result in each case.
\begin{figure}
  \centering
  % rubber: make removal.eps from removal.fig
  % rubber: make removal.pdf from removal.fig
  \includegraphics{removal}
  \caption{Graphical illustration of fatgraph edge removal.  Top row: a regular edge is removed from an $\R_{0,4}$ graph; its endpoints are further removed; the remaining edges are joined and the resulting graph is a trivalent fatgraph in $\R_{0,3}$.  Bottom row: a loop is removed from a trivalent $\R_{0,4}$ graph; the stem together with its endpoints has to be removed as well; the remaining edges are joined, and we end up with a trivalent fatgraph in $\R_{0,3}$.}
  \label{fig:removal}
\end{figure}

Case {\slshape A)}: If $x$ is a loop attached to $v$, then, after deletion
of $x$, one needs to also delete the loose edge $x'$ and also the
vertex $v'$ (that is, join the two other edges attached to $v'$; see
\csref{fig:removal}, bottom row).  The resulting fatgraph $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$, $x'$ have been deleted and two other
  edges merged into one;
\item one boundary cycle less: the boundary cycle totally bounded by
  $x$ has been removed.
\end{itemize}
Therefore:
\begin{align*}
  2 - 2g' &= \chi(G') = V' - E' + n' 
  \\
  &= (V-2) -(E-3) + (n-1)
  \\
  &= V - E + n = \chi(G) = 2 - 2g,
\end{align*}
hence $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:A}\tag{A}
\end{equation}

In case {\slshape B)}, $x$ joins distinct vertices $v$,
$v'$ and separates distinct boundary cycles (see \csref{fig:removal},
top row).  Delete $x$ and merge the two edges attached to each of
the two vertices $v$ and $v'$; in the process, the two boundary cycles
$\beta, \beta'$ also merge into one. The resulting fatgraph $G'$ is
connected. Indeed, given any two vertices $u, u' \in V(G')$, there is
a path $(x_1, \ldots, x_k)$ connecting $u$ with $u'$ in $G$; if this
path passes through $x$, one can replace the occurrence of $x$ with
the perimeter ---excluding $x$--- of one of the two boundary cycles
$\beta, \beta'$ to get a path joining $v$ and $v'$ which avoids $x$,
and thus projects to a path in $G'$.  Again we see that $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle less: the boundary cycles $\beta$, $\beta'$
  have been merged into one.
\end{itemize}
Therefore $g=g'$, and 
\begin{equation}
G' \in \R_{g,n-1}.
\label{eq:B}\tag{B}
\end{equation}

In case {\slshape C)}, $x$ joins distinct vertices $v$,
$v'$ but belongs into \emph{one} boundary cycle $\beta \in B(G)$ only.
Delete edge $x$ and the two vertices $v$, $v'$, joining the attached
edges two by two as in case {\slshape B)}.
\begin{enumerate}
\item[\slshape C')] If the resulting fatgraph $G'$ is connected, then
  $\beta \in B(G)$ has been split into two distinct boundary cycles
  $\beta', \beta'' \in B(G')$.  Indeed, write the boundary cycle
  $\beta$ as an ordered sequence of oriented edges: $y_0 \to y_1 \to
  \ldots \to y_l \to y_0$; assume the $y_*$ appear in this sequence in the
  exact order they are encountered when walking along $\beta$ in the
  sense given by the fatgraph orientation. The oriented edges $y_j$
  are pairwise distinct: if $y_i$ and $y_k$ share the same supporting
  edge, then $y_i$ and $y_k$ have opposite orientations. By the
  initial assumption of case~{\slshape C)}, edge $x$
  must appear \emph{twice} in the list: if $\bar x$ and $\underline x$
  denote the two orientations of $x$, then $y_i = \bar x$ and $y_k =
  \underline x$.  Deleting $x$ from $\beta$ is (from a homotopy point
  of view) the same as replacing $y_i = \bar x$ with $\bar x \to
  \underline x$, and $y_k = \underline x$ with $\underline x \to \bar
  x$ when walking a boundary cycle. Then we see that $\beta$ splits
  into two disjoint cycles:
\begin{align*}
  \beta' &= y_0 \to y_1 \to \cdots \to y_{i-1} \to \bar{x} \to
  \underline{x} \to y_{k+1} \to \cdots \to y_l \to y_0,
  \\
  \beta'' &= y_{i+1} \to \cdots \to y_{k-1} \to \underline{x} \to
  \bar{x} \to y_{i+1}.
\end{align*}
In this case, $G'$ has:
\begin{itemize}
\item two vertices less than $G$: $v$ and $v'$ have been deleted;
\item three edges less: $x$ has been deleted and four other
  edges merged into two, pair by pair;
\item one boundary cycle \emph{more}: the boundary cycle $\beta$ has
  been split in the pair $\beta'$, $\beta''$.
\end{itemize}
Therefore $g'=g-1$ and $n'=n+1$, so:
\begin{equation}
G' \in \R_{g-1,n+1}.
\label{eq:C'}\tag{C'}
\end{equation}

\item[\slshape C'')] $G'$ is a disconnected union of fatgraphs $G'_1$ and
  $G'_2$; for this statement to hold unconditionally, we temporarily allow a
  single circle into the set of connected fatgraphs (as a fatgraph
  with one closed edge and no vertices) as the one and only element of
  $\R_{0,2}$.  As will be shown in \csref{lemma:no-c2}, this is
  irrelevant for the algorithm.  Now:
  \begin{equation*} V'_1 + V'_2 = V -2, 
    \qquad E'_1 + E'_2 = E - 3,
    \qquad n'_1 + n'_2 = n + 1,
  \end{equation*} hence:
\begin{align*} 
  (2- 2g'_1) + (2-2g'_2) &= (V-2) - (E-3) + (n+1) 
  \\ 
  &= (V-E+n) + 2 = 4 - 2g
\end{align*} 
So that $g'_1 + g'_2 = g + 2$, $n'_1 + n'_2 = n+1$ and
\begin{equation} 
  G'= G'_1 \otimes G'_2 \in \R_{g'_1, n'_1} \otimes \R_{g'_2, n'_2}.
  \label{eq:C''}\tag{C''}
\end{equation}
\end{enumerate}

\subsubsection{Inverse construction}
\label{sec:addition}

If $x \in E(G)$ is an edge of fatgraph $G$, denote $\bar{x}$ and
$\underline{x}$ the two opposite orientations of $x$.

In the following, let $\R'_{g,n}$ be the set of fatgraphs with a
selected oriented edge:
\begin{equation*}
  \R'_{g,n} := \{ (G,\bar x) : G \in \R_{g,n}, \bar{x} \in L(G)\}.
\end{equation*}
Similarly, let $\R''_{g,n}$ be the set of fatgraphs with two
chosen oriented edges:
\begin{equation*}
  \R''_{g,n} := \{ (G, \bar x, \bar y) : G \in \R_{g,n}, 
                   \bar{x}, \bar{y} \in L(G) \}.
\end{equation*}
The following abbreviations come in handy: let $\R = \cup \R_{g,n}$,
$\R' = \cup \R'_{g,n}$, and $\R'' = \cup \R''_{g,n}$.

Define the attachment of a new edge to a fatgraph in the following
way.  Given a fatgraph $G$ and an \emph{oriented} edge $\bar{x}$, we
can create a new trivalent vertex $v$ in the midpoint of $x$, and
attach a new edge to it, in such a way that the two halves of $x$
appear, in the cyclic order at $v$, in the same order induced by the
by the orientation of $\bar{x}$.  \csref{fig:adding} depicts the process.
\begin{figure}
  \centering
  % rubber: make adding.eps from adding.fig
  % rubber: make adding.pdf from adding.fig
  \includegraphics{adding}
  \caption{When adding a new vertex in the middle of an edge $x$, the cyclic order depends on the oriented edge: the two orientations $\bar{x}$ and $\underline{x}$ get two inequivalent cyclic orders.}
  \label{fig:adding}
\end{figure}

We can now define maps that invert the constructions {\slshape A)}, {\slshape B)},
{\slshape C')} and {\slshape C'')} defined in the previous section.
\begin{figure}
  \centering
  % rubber: make pqr.eps from pqr.fig
  % rubber: make pqr.pdf from pqr.fig
  \includegraphics{pqr}
  \caption{Graphical illustration of maps $p$, $q$, $r_{g,n}$.  Top left: $p(G,\bar{x})$ attaches a ``slipknot'' to edge $\bar{x}$.  Top right: $r_{2,5}(G_1, \bar{x}, G_2, \bar{y})$ joins fatgraphs $G_1$ and $G_2$ with a new edge. Bottom: $q(G,\bar{x}, \bar{y})$ (left) and $p(G, \underline{x}, \bar{y})$ (right); it is shown how changing the orientation of an edge can lead to different results.}
  \label{fig:pqr}
\end{figure}

Let $p_{g,n} : \R'_{g,n-1} \to \R_{g,n}$ be the map that creates
$p(G,\bar{x})$ from a pair $(G, \bar{x})$ by attaching a ``slip
knot''\footnote{A single 3-valent vertex with one loop attached and a
  regular edge with one loose end.} to the midpoint of $x$ by the
loose end.  The map $p: \R' \to \R$, $p|_{\R'_{g,n}} := p_{g,n}$ is
evidently the inverse to {\slshape A)}.

To invert {\slshape B)} and {\slshape C')}, define a map $q : \R'' \to \R$ that
operates as follows:
\begin{itemize}
\item Given $(G, \bar{x}, \bar{y})$ with $\bar{x} \not= \bar{y}$, $q$
  attaches a new edge to the midpoints of $x$ and $y$; again the
  cyclic order on the new midpoint vertices is chosen such that the
  two halves of $x$ and $y$ appear in the order induced by the
  orientations $\bar x$, $\bar y$.
\item When $\bar{x} = \bar{y}$, let us further stipulate that the
  construction of $q'(G, \bar{x}, \bar{x})$ happens in two steps:
  \begin{enumerate}
  \item a new trivalent vertex is created in the midpoint of $x \in
    E(G)$ and a new edge $\xi$ is attached to it,
  \item map $x$ to the one of the two halves which comes first in the
    ordering induced by the orientation $\bar{x}$: create a new
    trivalent vertex in the middle of it, and attach the loose end of
    the new edge $\xi$.
  \end{enumerate}
  It is clear that the above steps give an unambiguous definition of
  $q$ in all cases where $\bar{x}$ and $\bar{y}$ are orientations of
  the same edge of $G$, that is, $(G, \bar{x}, \bar{x})$, $(G,
  \bar{x}, \underline{x})$, $(G, \underline{x}, \bar{x})$, and $(G,
  \underline{x}, \underline{x})$.
\end{itemize}
Ostensibly, $q$ inverts the edge removal in cases {\slshape B)} and
{\slshape C')}: the former applies when a graph $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g,n+1}$, the latter when $G \in \R_{g,n}$ is
sent to $q(G) \in \R_{g+1,n-1}$.

Finally, to invert {\slshape C'')}, let us define
\begin{equation*}
r_{g,n}: \bigoplus_{\substack{g'_1+g'_2=g+2 \\ n'_1+n'_2=n}} 
\R'_{g'_1, n'_1} \times \R'_{g'_2, n'_2} \to \R.
\end{equation*}
From $(G', \bar{x}', G'',
\bar{x}'')$, construct a new fatgraph by bridging $G'$ and $G''$ with
a new edge, whose endpoints are in the midpoints of $x'$ and $x''$;
again, stipulate that the cyclic order on the new vertices is chosen
such that the two halves of $x'$, $x''$ appear in the order induced by
the orientations $\bar{x}'$, $\bar{x}''$.

Summing up, any fatgraph $G \in \R_{g,n}$ belongs to the image of one
of the above maps $p$, $q$, and $r$. There is considerable
overlap among the different image sets: indeed, one can prove that
$r$ is superfluous.
\begin{lemma}\label{lemma:no-c2}
  Any fatgraph obtained by inverting construction {\slshape C'')} lies in
  the image of maps $p$ and $q$.
\end{lemma}
\begin{proof}
  Assume, on the contrary, that $G$ lies in the image of $r$ only.
  Then, deletion of any edge $x$ from $G$ yields a disconnected graph
  $G' \otimes G''$.  Both subgraphs $G'$ and $G''$ enjoy the same
  property, namely, that deletion of any edge disconnects: otherwise,
  if the removal of $y \in E(G')$ does not disconnect $G'$, then
  neither does it disconnect $G = r_{g,n}(G', G'')$, contrary to the
  assumption. As long as $G'$ or $G''$ has more than 3 edges, we can
  delete another edge; by recursively repeating the process, we end up
  with a fatgraph $G^*$ with $\leq 3$ edges.  Since $G^*$ is
  trivalent, $3 \cdot E^* = 2 \cdot V^*$, therefore $G^*$ must have
  exactly 3 edges and 2 vertices. But all such fatgraphs belong in
  $\R_{0,3}$ or $\R_{1,1}$, and it is readily checked that there is no
  way to add an edge such that the required property holds, that any
  deletion disconnects.
\end{proof}

\subsubsection{The \protect\Verb`MgnTrivalentGraphs` algorithm}
\label{sec:MgnTrivalentGraphs}

The stage is now set for implementing the recursive generation of
trivalent graphs.
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=1]
def MgnTrivalentGraphs(g, n):
  """
  Return a list of all connected trivalent fatgraphs with
  prescribed genus `g` and number of boundary cycles `n`.
  """
\end{lstlisting}

A function call "MgnTrivalentGraphs(g,n)" recursively calls
"MgnTrivalentGraphs" to enumerate trivalent graphs of $\R_{g,n-1}$
and $\R_{g-1,n+1}$; it is cleaner to program the function as to call itself
unconditionally, and to catch the induction base cases at the very
start.  In particular, "MgnTrivalentGraphs" must:
\begin{itemize}
\item return the empty set when called with an invalid "(g,n)" pair;
\item provide the full set of fatgraphs $\R_{0,3}$ and $\R_{1,1}$ as
  induction base.
\end{itemize}
This is indeed realized in the following lines (the fatgraph
representation as a Python ``"Fatgraph"'' object is discussed in
\csref{sec:stage1-fatgraphs}):
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=6]
  # avoid infinite recursion in later statements
  if n==0 or (g,n)<(0,3):
    return [] # return empty list

  # $M_{0,3}$ --- induction base
  if (g,n) == (0,3):
    return [ 
        Fatgraph([Vertex([1, 2, 1]), Vertex([2, 0, 0])]),
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 0, 1])]) 
      ]

  # $M_{1,1}$ --- induction base
  elif (g,n) == (1,1):
    return [ 
        Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]) 
      ]
\end{lstlisting}

The general case is quite straightforward, if we assume to have
working implementations of the maps $p$ and $q$ defined in the
previous section (a description of the implementation of these maps
falls within the scope of \csref{sec:stage1-fatgraphs}).  The basic
idea is: apply maps $p$, $q$ to every fatgraph in $\R_{g,n-1}$, and
$q'$ to every fatgraph in $\R_{g-1,n+1}$; discard all graphs that do
not belong to $\R_{g,n}$ and take only one graph per isomorphism class
into the result set.

Implementation of the general case starts with creating an empty list
for accumulating the results.  An helper function
"add_if_admissible" is defined, to store only fatgraphs belonging in
$\R_{g,n}$ into "result", and only one fatgraph per isomorphism
class (the ``"G not in result"'' clause):
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=22]
  # general case
  else:
    result = [] # start with empty list

    def add_if_admissible(G):
      if (G.genus, G.num_boundary_cycles) == (g,n) \
          and (G not in result):
        result.append(G)
      
\end{lstlisting}

To invert construction {\slshape A)}, apply map $p$ to all fatgraphs $G \in
\R_{g,n-1}$; if $a \in \Aut(G)$, then $p(a(G), a(x)) = p(G, x)$,
therefore we may limit ourselves to one pair $(G,x)$ per orbit of the
automorphism group, saving a few computational cycles:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=30]
    # case A: hang a circle to all edges of graphs in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for x in G.edge_orbits():
        add_if_admissible (G.hangcircle(x,0))
        add_if_admissible (G.hangcircle(x,1))

\end{lstlisting}
The ``"Fatgraph.hangcircle"'' function implements the behavior of the
$p$ map: the expression ``"G.hangcircle(x,0)"'' returns a copy of
"G", with a ``slipknot'' attached to edge "x".  The additional
parameter ("0" or "1") determines which orientation of "x"
should be considered, therefore expressions like ``"x,0"'' and
``"x,1"'' should really be read as $\bar{x}$ or $\underline{x}$. A
complete explanation and implementation details are given in
\csref{sec:stage1-fatgraphs}.

Similarly, function ``"Fatgraph.bridge"'' implements $q$;
the algorithm used is independent of $g$ and $n$, thus a single
function can serve the whole fatgraph domain $\R = \cup
\R_{g,n}$. Since $q$ is a function of $(G, \bar{x}, \bar{y})$, which
is by construction invariant under $\Aut(G)$, we can again restrict
to considering only one $(G, \bar{x}, \bar{y})$ per $\Aut(G)$-orbit;
this is computed by the "G.edge_pair_orbit" function:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=35]
    # case B: bridge all edges of a single graph in $M_{g,n-1}$
    for G in MgnTrivalentGraphs(g,n-1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

    # case C': bridge all edges of a single graph in $M_{g-1,n+1}$
    for G in MgnTrivalentGraphs(g-1,n+1):
      for (x,y) in G.edge_pair_orbits():
        add_if_admissible (G.bridge(x,0, y,0))
        add_if_admissible (G.bridge(x,0, y,1))
        add_if_admissible (G.bridge(x,1, y,0))
        add_if_admissible (G.bridge(x,1, y,1))

\end{lstlisting}

Finally, the list of fatgraphs (one fatgraph per isomorphism class) is
returned to the caller:
\begin{lstlisting}[name=MgnTrivalentGraphs,firstnumber=50]
    return result
\end{lstlisting}
\FIXME{Serve qui un'analisi della complessit\`a dell'algoritmo?  In
  realt\`a non si pu\`o concludere molto, perch\'e dipende in modo
  essenziale dal numero totale dei grafi e dal numero dei duplicati:
  nessuno di questi \'e noto in anticipo.}


\subsection{Computer representation of Fatgraphs}
\label{sec:stage1-fatgraphs}

The core of the computation lies in the representation of a fatgraph
as an object in the programming language Python: according to the
analysis of the graph generation algorithms in
Sections~\ref{sec:stage1-all}--~\ref{sec:stage1-trivalent}, a
``"Fatgraph"'' class is needed, together with functions to contract an
edge ("Fatgraph.contract"), compute orbits of edges under the action
of fatgraph automorphisms ("Fatgraph.edge_orbits" and
"Fatgraph.edge_pair_orbits"), implement maps $p$ and $q$
("Fatgraph.hangcircle" and "Fatgraph.bridge"), and, last but not
least, check two graphs for isomorphism.\FIXME{Rimuovere i nomi delle
  funzioni da questo paragrafo introduttivo?}

Whereas the combinatorial definition of a fatgraph
(cf.~\csref{sec:fatgraphs}) might suggest a computer representation as
a triple of permutations ---as used, e.g., in \cite[Section
2.4]{arXiv:0902.1025}---, the functions that are needed by the above
generation algorithms are rather topological in nature and thus
suggest an approach more directly related to the concrete realization
of a fatgraph.

\subsubsection{Vertices}
\label{sec:vertices}

Let $G$ be a fatgraph; assuming $G$ has $l+1$ edges, arbitrarily
assign to each edge an integer in the range $[0, l]$, that is, pick a
bijective map $e: E(G) \to \{0, \dots, l\}$.  Each vertex $v \in V(G)$
is thus decorated with a cyclic sequence of edge labels; conversely,
given just the set of such decorations, one can reconstruct the
fatgraph $G$.  Indeed, if we are given cyclic sequences $v_0 = (e_0^0,
e^0_1, \ldots, e^0_{i_0})$, \ldots, $v_k = (e^k_0, \ldots,
e^k_{i_k})$, such that $\{e^0_0, \ldots, e^0_{i_0}, e^1_0, \ldots,
e^{k-1}_{i_{k-1}}, e^k_0, \ldots, e^k_{i_k}\} = \{0, \ldots, l\}$,
then we can set
\begin{equation*}
  X := \{ (e, v) : e \in v, v\in \{v_0, \ldots, v_k\} \},
\end{equation*}
and define maps $\sigma_0, \sigma_1, \sigma_2: X \to X$ as follows:
$\sigma_0$ sends $(e, v)$ to $(e', v)$ where $e'$ is the successor of
$e$ in the cyclic order at $v$; $\sigma_1$ maps $(e, v)$ to the unique
other pair $(e', v') \in X$ such that $e = e'$; finally, $\sigma_2$ is
determined by the constraint $\sigma_0\sigma_1\sigma_2 = \id_X$.  Then
$G = (X, \sigma_0, \sigma_1, \sigma_2)$ is a fatgraph; by applying the
procedure described at the beginning of this paragraph, we recover
$v_0$, \ldots, $v_k$ up to a permutation of the edge numbers.

Therefore, we chose to represent a fatgraph vertex by the cyclically
ordered list of its edge colorings.  
\begin{lstlisting}
class Vertex(CyclicList):
    """A (representation of a) vertex of a ribbon graph."""
    def __init__(self, seq):
        # initialize base class
        CyclicList.__init__(self, seq)
        # store number of loops (top. invariant) for later reference
        self.num_loops = len(self) - len(set(self))

\end{lstlisting}
The "CyclicList" base class provides all the functionality needed by
the "Vertex" class: if "v" is a "Vertex" instance, then the
Python expression \l{v[i]} returns the edge coloring stored at
position "i", furthermore, \l{v[i] == v[i+L]} when \l{L = len(v)}.
The length "len(v)" of a "Vertex" is the number of edges attached
to the vertex.  

During a "Vertex" object creation, the number of loops attached to
this vertex is computed and stored in the "num_loops" attribute: the
number of loops is a vertex invariant and will be used in the
computation of fatgraph isomorphisms.  The number of loops is computed
as the difference between "len(self)", the number of attached edges,
and "len(set(self))", the number of \emph{unique} attached edge
colorings. 

\begin{definition}
  A fatgraph vertex together with a choice of an attached edge is
  called a \emph{ciliated} vertex.  The chosen edge is called the
  \emph{cilium}.
\end{definition}
The "Vertex" objects actually represent a \emph{ciliated} vertex.
Since we need to implement the cyclic behavior of fatgraph vertices,
two "Vertex" instances must be declared equal if one is equal (as a
sequence) to the other rotated by a certain amount.  This behavior is
implemented in the "CyclicList" class: comparing two
"CyclicSequence" instances has linear complexity in the length of
the sequence, as all the rotations have to be tried out in the worst
case.\FIXME{Inserire qui il codice relativo e il commento?}

The following definition comes handy:
\begin{definition}
  If $v$ is a ciliated vertex and $e$ and edge attached to it, define
  the attachment index of $e$ at $v$ as the index of edge $e$ relative
  to the cilium at $v$: if $\alpha$ is the attachment index of $e$ at
  $v$, then $\sigma_1^\alpha$ takes the cilium at $v$ onto $e$.
\end{definition}


\subsubsection{Edges}
\label{sec:edges}

An edge is represented by its two endpoints; each endpoint has the
form "(v, a)", where "v" is the index of the endpoint vertex
(within the fatgraph), and "a" is the index at which this edge
appears within vertex "v" (the attachment index).
\begin{lstlisting}
class Edge(object):
    """An edge of a fatgraph."""

    def __init__(self, va1, va2):
        if va1[0] < va2[0]:
            self.endpoints = (va1, va2)
        else:
            self.endpoints = (va2, va1)

\end{lstlisting}
Note that the "Edge.__init__" constructor requires the two
endpoints, that is, it should be invoked like: 
\l{e = Edge((0,1),(1,3))}, passing the endpoints already as a tuple 
"(v,a)".  Also, "Edge" objects guarantee that endpoints are stored in
increasing vertex index order: therefore, if "e" is an "Edge"
object, then \l{e.endpoints[0] < e.endpoints[1]}.

"Edge" objects bear no reference to a particular "Fatgraph" instance,
to allow sharing the same edge instance among "Fatgraph" instances that are
created by contraction or other geometrical operations.

A few convenience methods are defined on "Edge" objects, to make for
clearer code.

The "Edge.is_loop" function returns "True" if applied to an
"Edge" object that represents a loop:
\begin{lstlisting}
    def is_loop(self):
        """
        Return `True` if this `Edge` instance 
        represents a looping edge.
        """
        return self.endpoints[0][0] == self.endpoints[1][0]
        
\end{lstlisting}

The "Edge.meets" function takes an "Edge" and a vertex index "v"
as input, and returns "True" if "v" is one of the endpoints:
\begin{lstlisting}
    def meets(self, v):
        """
        Return `True` if vertex `v` is one of the endpoints.
        """
        return (v == self.endpoints[0][0]) 
                or (v == self.endpoints[1][0])

\end{lstlisting}

The "Edge.other_end" method takes as input an "Edge" instance, a
vertex index "v", and an attachment index "a" --- together, they
form an endpoint "(v, a)"; the function returns the other endpoint
of the given "Edge".  For instance, if \l{e = Edge((0,1), (1,3))}
then "Edge.other_end(e, 0, 1)" returns "(1,3)" and
"Edge.other_end(e, 1, 3)" returns "(0,1)"
\begin{lstlisting}
    def other_end(self, v, a):
        """Return the endpoint opposed to `(v, a)`."""
        if self.endpoints[0] == (v, a):
            return self.endpoints[1]
        else:
            return self.endpoints[0]

\end{lstlisting}


\subsubsection{Boundary Cycles}
\label{sec:boundary-cycles}

Boundary cycles are represented as cyclic sequences of ``corners'': a
corner consists of a vertex "v" and (an unordered pair of) two
consecutive indices (in the cyclic order at "v", so, either
"j==i+1" or "i" and "j" are the starting and ending indices).

Two boundary cycles are equal if they comprise the same corners.
Thus, there is no reason to record the order in which the edges are
encountered when walking along a boundary cycles: the
"BoundaryCycle" objects can be derived from the Python built-in
"frozenset" class.\footnote{Class \protect\l`frozenset` is the
  immutable variant of a \protect\l`set`: \protect\l`frozenset`
  objects cannot be modified after creation, but they can be used as
  keys in \protect\l`dict` objects.  This is a feature that will be
  needed when defining a numbering on a fatgraph: the additional
  structure will be just a dictionary associating
  \protect\l`BoundaryCycles` with an integer.}
\begin{lstlisting}
class BoundaryCycle(frozenset):
    """A boundary cycle of a Fatgraph."""

    def __new__(cls, triples, graph):
        return frozenset.__new__(cls, triples)

    def __init__(self, triples, graph=None):
        """Construct a `BoundaryCycle` instance from a sequence of
        triples `(v, i, j)`, where `i` and `j` are consecutive (in
        the cyclic order sense) indices at a vertex `v`.
        """
        # initialize base class
        frozenset.__init__(self)
        # record the graph this cycle is boundary to
        self.graph = graph 

\end{lstlisting}
The above code only defines a "BoundaryCycle" object to the set of
the corners (given in the "triples" construction parameter) plus a
reference to the graph the boundary cycle is part of.

The code above looks a bit odd because of a Python quirk: built-in
objects are not initialized in the ``"__init__"'', rather in a
special ``"__new__"'' method. Thus, to store the corner triples in a
"BoundaryCycle" instance, we must create a "__new__" method that
passes the arguments back up to the super class.

\colorbox{yellow}{\bfseries XXX:} explain "contract()" here or make a
separate section on contractions?
\begin{lstlisting}
    def contract(self, vi1, vi2, graph):
        """
        Return a new `BoundaryCycle` instance, image of the
        topological map that contracts the edge with endpoints
        `(v1,i1)` and `(v2,i2)` that are passed as first and
        second argument.

        Optional third argument `graph` is passed unchanged to the
        `BoundaryCycle` constructor.
        """
        (v1, pos1) = vi1
        (v2, pos2) = vi2
        l1 = len(self.graph.vertices[v1])
        l2 = len(self.graph.vertices[v2])
        new_bcy = []
        for corner in self:
            if corner[0] == v1:
                if pos1 == corner[1]:
                    # skip this corner, keep only one of the
                    # corners limited by the contracted edge
                    continue
                else: 
                    i1 = (corner[1] - pos1 - 1) % l1
                    i2 = (corner[2] - pos1 - 1) % l1
                    new_bcy.append((v1, i1, i2))
            elif corner[0] == v2:
                if pos2 == corner[1]:
                    # skip this corner, keep only one of the
                    # corners limited by the contracted edge
                    continue
                if pos2 == corner[2]:
                    new_bcy.append((v1, l1+l2-3, 0))
                else:
                    i1 = l1-1 + ((corner[1] - pos2 - 1) % l2)
                    i2 = l1-1 + ((corner[2] - pos2 - 1) % l2)
                    new_bcy.append((v1, i1, i2))
            elif corner[0] > v2:
                # shift vertices after "v2" one position down
                new_bcy.append((corner[0]-1, corner[1], corner[2]))
            else:
                # pass corner unchanged
                new_bcy.append(corner)
        return BoundaryCycle(new_bcy, graph)

\end{lstlisting}


\subsubsection{Fatgraphs}
\label{sec:fatgraphs}

The stage is now set for the introduction of a computable
representation of fatgraphs.  The class "Fatgraph" constructor takes a
list of "Vertex" objects; a typical line of code creating a "Fatgraph"
instance would be:
\begin{codexmp}
  g1 = Fatgraph( [ Vertex([2,0,1]), Vertex([2,1,0]) ] )
\end{codexmp}
Figure~\ref{fig:ctor} shows how a fatgraph is constructed out of the
data above.
\begin{figure}
  \centering
  % rubber: make ctor.eps from ctor.fig
  % rubber: make ctor.pdf from ctor.fig
  \includegraphics{ctor}
  \caption{Construction of a fatgraph out of a set of {\l Vertex}
    instances: cilia tagged with the same (numeric) color are joined
    together to form an edge.}
  \label{fig:ctor}
\end{figure}
The "Fatgraph.__init__" constructor computes ...
\begin{lstlisting}
class Fatgraph(object):
    """A representation of a fatgraph."""

    def __init__(self, vertices, **kwargs):
        """Construct a `Fatgraph` instance, taking list of vertices."""
        # list of vertices
        self.vertices = vertices

        # Number of vertices  
        self.num_vertices = len(vertices)

        # Number of edge colors
        self.num_edges = kwargs.get('num_edges',
                                    sum(len(v) for v in self.vertices) / 2)

        if 'edges' in kwargs:
            self.edges = kwargs.get('edges')
        else:
            # Adjacency list of this graph.  For each edge, store a pair
            # "(v1, v2)" where "v1" and "v2" are (indices of)
            # endpoint vertices of an edge, and a corresponding pair
            # "(i1, i2)" where "i1" and "i2" are indices of the given
            # edge in vertices "v1" and "v2".
            # Each pair "(v, i)" represents a flag by the endpoint
            # vertex and the index of the edge in the vertex.  (The
            # vertex index alone is not enough for representing the
            # edge arrow for loops.)
            endpoints = [ [] for dummy in xrange(self.num_edges) ]
            for current_vertex_index in xrange(self.num_vertices):
                for (edge_index_in_vertex, edge) \
                        in enumerate(self.vertices[current_vertex_index]):
                    endpoints[edge].append( (current_vertex_index, edge_index_in_vertex) )
            # now wrap endpoints into "Edge" objects
            self.edges = [ Edge(*e) for e in endpoints ]

        # Orientation is given by an ordering of the edges,
        # which directly translates into an orientation of the
        # associated cell.  
        if 'orientation' in kwargs:
            self.edge_numbering = kwargs.get('orientation')
        else:
            self.edge_numbering = [ x for x in xrange(self.num_edges) ]

        self.boundary_cycles = self.compute_boundary_cycles()
        self.num_boundary_cycles = len(self.boundary_cycles)

        # by Euler, V-E+n=2-2*g
        self.genus = (self.num_edges - self.num_vertices
                      - self.num_boundary_cycles + 2) / 2

        # used for isomorphism testing
        self.invariants = (
                self.num_vertices,
                self.num_edges,
                self.num_boundary_cycles,
                )

\end{lstlisting}

\begin{lstlisting}

    def __repr__(self):
        if not hasattr(self, 'vertices'):
            return "Fatgraph(<Initializing...>)"
        else:
            return "Fatgraph(%s)" % repr(self.vertices)
    
    def __str__(self):
        return repr(self)


    # Instances of this class will compare equal if there is an
    # isomorphism mapping one to the other.
    def __eq__(self, other):
        """Return `True` if `self` and `other` are isomorphic."""

        # shortcuts
        if self is other:
            return True
        if self.invariants != other.invariants:
            return False

        # go the long way: try to find an explicit isomorphims
        # between "self" and "other"
        try:
            # if there is any morphism, then return "True"
            self.isomorphisms(other).next()
            return True
        except StopIteration:
            # list of morphisms is empty, objects are not equal.
            return False


    # both "__eq__" and "__ne__" are needed 
    # for testing equality of Python objects
    def __ne__(self, other):
        """The opposite of `__eq__` (which see)."""
        return not self.__eq__(other)


    def assimilate(self, other):
        """
        Copy-constructor: make `self` equal to `other`.

        The modified `Fatgraph` instance *shares* all attributes
        with the instance given as argument::

            >>> g2.vertices is g1.vertices
            True
            >>> g2.edge_numbering is g1.edge_numbering
            True
            >>> g2.edges is g1.edges
            True
        """
        self.boundary_cycles = other.boundary_cycles
        self.edges = other.edges
        self.edge_numbering = other.edge_numbering
        self.genus = other.genus
        self.num_boundary_cycles = other.num_boundary_cycles
        self.num_edges = other.num_edges
        self.num_vertices = other.num_vertices
        self.vertices = other.vertices
        self.invariants = (
                self.num_vertices,
                self.num_edges,
                self.num_boundary_cycles,
                )


    def automorphisms(self):
        """Enumerate automorphisms of this `Fatgraph` object.

        See `.isomorphisms()` for details of how a `Fatgraph`
        isomorphism is represented.
        """
        return self.isomorphisms(self)

    def compute_boundary_cycles(self):
        """Return a list of boundary cycles of this `Fatgraph` object.

        Boundary cycles are represented as a cyclic list of 'corners':
        a corner is a triple `(v, i, j)` consisting of a vertex and
        two consecutive indices (in the cyclic order, so, either `j ==
        i+1` or "i" and "j" are the starting and ending indices)::
        
          >>> Fatgraph([Vertex([2,1,0]),Vertex([2,0,1])]).compute_boundary_cycles()
          [BoundaryCycle([(1, 2, 0), (0, 0, 1)]),
           BoundaryCycle([(0, 1, 2), (1, 1, 2)]),
           BoundaryCycle([(0, 2, 0), (1, 0, 1)])]

        This verbose representation allows one to distinguish the
        boundary cycles made from the same set of edges::

          >>> Fatgraph([Vertex([0,1,2,0,1,2])]).compute_boundary_cycles()
          [BoundaryCycle([(0, 2, 3), (0, 4, 5), (0, 0, 1)]),
           BoundaryCycle([(0, 1, 2), (0, 3, 4), (0, 5, 0)])]
        """
        
        # Build the collection of `corners' of "graph",
        # structured just like the set of vertices.
        # By construction, `corners[v][i]` has the the
        # form "(v,i,j)" where "j" is the index following
        # "i" in the cyclic order.
        corners = [ [ (v, i, (i+1)%len(self.vertices[v]))
                      for i in xrange(len(self.vertices[v])) ]
                    for v in xrange(self.num_vertices) ]

        result = []
        while True:
            # fast-forward to the first unused corner
            for v in xrange(self.num_vertices):
                for i in xrange(len(self.vertices[v])):
                    if corners[v][i] is not None:
                        break
                if corners[v][i] is not None:
                    break
            # if all corners were browsed and all of them are "None":
            # we're done
            if corners[v][i] is None:
                break

            # build a list of corners comprising the same boundary
            # cycle: start with one corner, follow the edge starting
            # at the second delimiter of the corner to its other
            # endpoint, and repeat until we come back to the starting
            # point.  
            corner = None
            start = (v,i)
            triples = []
            while (v,i) != start or len(triples) == 0:
                corner = corners[v][i]
                corners[v][i] = None
                triples.append(corner)
                j = corner[2]
                edgeno = self.vertices[v][j]
                (v,i) = self.edges[edgeno].other_end(v, j)
            result.append(BoundaryCycle(triples, graph=self))

        return result
        

    def bridge(self, edge1, side1, edge2, side2):
        """Return a new `Fatgraph`, formed by inserting trivalent
        vertices in the middle of edges `edge1` and `edge2` and
        connecting them with a new edge.

          >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])])
          >>> g1 = g.bridge(0, 0, 1, 1)
          >>> g1 is g
          False
          >>> g1 == g
          False
          
        Arguments `side1` and `side2` control which side the new edge
        is attached to (valid values are 0 or 1), i.e., which of the
        two inequivalent cyclic orders the new trivalent vertices will
        be given::
        
          >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])])
          >>> g1 = g.bridge(0, 0, 1, 0)
          >>> g2 = g.bridge(0, 1, 1, 0)
          >>> g1 == g2
          False

        In more detail: let 0,1,2 be the indices of the edges attached
        to the new vertex in the middle of `edge1`, where 0,1 denote
        the two halves of `edge1`.  If `side1` is `0`, then the new
        trivalent vertex will have the cyclic order [0,1,2]; if
        `side1` is `1`, then 0,1 are swapped and the new trivalent
        vertex gets the cyclic order [1,0,2]::

          >>> g1 == Fatgraph([Vertex([0,1,2]), Vertex([4,2,5]), Vertex([0,4,3]), Vertex([1,5,3])])
          True
          >>> g2 == Fatgraph([Vertex([0,1,2]), Vertex([4,2,5]), Vertex([4,0,3]), Vertex([1,5,3])])
          True

        It is worth noting that this procedure involves 5 edges in
        total, 3 of which need new indices.

          >>> g.num_edges
          3
          >>> g1.num_edges
          6
          
        This function is obviously symmetric: the pairs `edge1, side1`
        and `edge2, side2` can be swapped and the result stays the
        same::

          >>> g3 = g.bridge(1, 0, 0, 0)
          >>> g1 == g3
          True

          >>> g4 = g.bridge(1, 0, 0, 1)
          >>> g2 == g4
          True

        Examples::
        
        1) Bridging different sides of the same edge may yield
        different results::
        
          >>> g.bridge(0, 0, 1, 0)  == Fatgraph([Vertex([0,1,2]), Vertex([4,2,5]), Vertex([0,4,3]), Vertex([1,5,3])])
          True
          
          >>> g.bridge(0, 1, 1, 0) == Fatgraph([Vertex([0,1,2]), Vertex([4,2,5]), Vertex([4,0,3]), Vertex([1,5,3])])
          True

        2) One can connect an edge to itself on different sides::
        
          >>> g.bridge(0, 0, 0, 1) == Fatgraph([Vertex([0,1,2]), Vertex([5,2,1]), Vertex([0,4,3]), Vertex([5,4,3])])
          True

        3) And also with both ends on the same side::
        
          >>> g.bridge(0, 0, 0, 0) == Fatgraph([Vertex([0,1,2]), Vertex([5,2,1]), Vertex([0,4,3]), Vertex([4,5,3])])
          True
          
        """
        opposite_side1 = 0 if side1==1 else 1
        opposite_side2 = 0 if side2==1 else 1

        # assign edge indices
        connecting_edge = self.num_edges
        # break "edge1" in two halves: if "v1a" and "v1b" are the
        # endpoints of "edge1", then the "one_half" edge extends from
        # the "v1a" endpoint of "edge1" to the new vertex
        # "midpoint1"; the "other_half" edge extends from the
        # "midpoint1" new vertex to "v1b".
        one_half1 = edge1
        other_half1 = self.num_edges + 1
        # break "edge2" in two halves; if "edge2" is the same edge as
        # "edge1", then we are breaking the second half of "edge1" in
        # two parts.  Otherwise, proceed as above.  In any case, the
        # "other half" of "edge2" needs a new edge index.
        if edge2 == edge1:
            one_half2 = other_half1
        else:
            one_half2 = edge2
        other_half2 = self.num_edges + 2

        # assign new vertex indices
        midpoint1_index = self.num_vertices
        midpoint2_index = self.num_vertices + 1

        if side1 == 1:
            midpoint1 = Vertex([other_half1, one_half1, connecting_edge])
        else: # side2 == 0
            midpoint1 = Vertex([one_half1, other_half1, connecting_edge])

        if side2 == 1:
            midpoint2 = Vertex([other_half2, one_half2, connecting_edge])
        else: # side2 == 0
            midpoint2 = Vertex([one_half2, other_half2, connecting_edge])

        # two new vertices are added: the mid-points of the connected edges.
        new_vertices = self.vertices + [midpoint1, midpoint2]

        # three new edges are added (constructed below)
        new_edges = self.edges + [
            None, # new edge: "connecting_edge"
            None, # new edge: "other_half1"
            None, # new edge: "other_half2"
            ]
        
        # the connecting edge has endpoints in the mid-points of
        # "edge1" and "edge2", and is *always* in third position.
        new_edges[connecting_edge] = Edge((midpoint1_index, 2), (midpoint2_index, 2))

        ((v1a, pos1a), (v1b, pos1b)) = self.edges[edge1].endpoints
        new_edges[one_half1] = Edge((v1a, pos1a), (midpoint1_index, side1))
        if edge1 != edge2:
            # replace "edge1" with new "other_half1" in the second endpoint
            new_vertices[v1b] = Vertex(new_vertices[v1b][:pos1b]
                                                 + [other_half1]
                                                 + new_vertices[v1b][pos1b+1:])
            new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), (v1b, pos1b))
        else:
            # same edge, the `other half' ends at the second endpoint
            new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), (midpoint2_index, side2))

        # replace "edge2" with new "other_half2" in the second
        # endpoint; again we need to distinguish the special case when
        # "edge1" and "edge2" are the same edge.
        ((v2a, pos2a), (v2b, pos2b)) = self.edges[edge2].endpoints
        if edge1 != edge2:
            new_edges[one_half2] = Edge((v2a, pos2a), (midpoint2_index, side2))
        else:
            # \verb`edge1 == edge2`, so "one_half2" == "other_half1"
            pass # that is: "new_edges[one_half2] = new_edges[other_half1]"
        # `other half' of second edge *always* ends at the previous
        # edge endpoint, so replace "edge2" in "v2b".
        new_vertices[v2b] = Vertex(new_vertices[v2b][:pos2b]
                                             + [other_half2]
                                             + new_vertices[v2b][pos2b+1:])
        new_edges[other_half2] = Edge((midpoint2_index, opposite_side2), (v2b, pos2b))

        # inherit orientation, and add the three new edges in the order they were created
        # FIXME: this is not the identity in the last segment!!
        new_edge_numbering = self.edge_numbering + \
                             [other_half1, other_half2, connecting_edge]

        # build new graph 
        return Fatgraph(new_vertices,
                        edges = new_edges,
                        num_edges = self.num_edges + 3,
                        orientation = new_edge_numbering,
                        )
    
    
    def bridge2(self, edge1, side1, other, edge2, side2):
        """Return a new `Fatgraph`, formed by connecting the midpoints
        of `edge1` on `self` and `edge2` on `other`.
        
          >>> g1 = Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])])
          >>> g2 = Fatgraph([Vertex([0,1,2,0,1,2])])
          >>> g = Fatgraph.bridge2(g1, 0, 0, g2, 1, 1)
          >>> g is g1
          False
          >>> g is g2
          False
          >>> g == Fatgraph([Vertex([0,1,2]), Vertex([6,2,1]), Vertex([3,4,5,3,7,5]), Vertex([0,6,8]), Vertex([4,7,8])])
          True
          
        New trivalent vertices are inserted in the middle of the
        connected edges.  Arguments `side1` and `side2` control which
        side the new edge is attached to (valid values are 0 or 1),
        i.e., which of the two inequivalent cyclic orders the new
        trivalent vertices will be given (see `Fatgraph.bridge()`).
        
        It is worth noting that this procedure adds 3 edges and 2
        vertices to the edge total of `self` and `other`::
        
          >>> g.num_edges == g1.num_edges + g2.num_edges + 3
          True
          >>> g.num_vertices == g1.num_vertices + g2.num_vertices + 2
          True
          
        This function is obviously symmetric: the triplets `self, edge1, side1`
        and `other, edge2, side2` can be swapped and the result stays the
        same (up to isomorphisms)::

          >>> g_ = Fatgraph.bridge2(g2, 1, 1, g1, 0, 0)
          >>> g == g_
          True

        *Caveat:* If `self == other` then the resulting graph is made
        up of *two copies* of `self` with a new edge connecting
        `edge1` on one copy and `edge2` on the other.
         
        """
        # First, build a (non-connected) graph from the disjoint
        # union of "self" and "other".

        # Edges of "other" are renumbered depending on whether
        # they are internal of external edges:
        #   - internal edges in "other" have numbers ranging from 0 to
        #     \verb"other.num_edges": they get new numbers starting from
        #     \verb"self.num_edges" and counting upwards
        renumber_other_edges = dict((x, x+self.num_edges)
                                    for x in xrange(other.num_edges))
        # Orientation needs the same numbering:
        new_edge_numbering = self.edge_numbering \
                             + list(itranslate(renumber_other_edges, other.edge_numbering))
        # Similarly, vertices of "self" retain indices `[0..v]`, while
        # vertices of "other" follow.
        new_vertices = self.vertices \
                       + [ Vertex(itranslate(renumber_other_edges, ov))
                           for ov in other.vertices ]
        renumber_other_vertices = dict((x, x+self.num_vertices)
                                       for x in xrange(other.num_vertices))
        # build new edges: vertex indices need to be shifted for
        # endpoints, but attachment indices are the same; three new
        # edges are added at the tail of the list
        new_edges = self.edges \
                    + [ Edge((renumber_other_vertices[x.endpoints[0][0]], x.endpoints[0][1]),
                             (renumber_other_vertices[x.endpoints[1][0]], x.endpoints[1][1]))
                        for x in other.edges ] \
                    + [None, # "connecting_edge"
                       None, # "other_half1"
                       None] # "other_half2"

        edge2 = renumber_other_edges[edge2] # index changed in "new_edges"
        
        opposite_side1 = 0 if side1 else 1
        opposite_side2 = 0 if side2 else 1

        # assign edge indices
        connecting_edge = self.num_edges + other.num_edges
        # break "edge1" in two halves: if "v1a" and "v1b" are the
        # endpoints of "edge1", then the "one_half" edge extends from
        # the "v1a" endpoint of "edge1" to the new vertex
        # "midpoint1"; the "other_half" edge extends from the
        # "midpoint1" new vertex to "v1b".
        one_half1 = edge1
        other_half1 = connecting_edge + 1
        # break "edge2" in two halves; same as above.
        one_half2 = edge2
        other_half2 = connecting_edge + 2

        # assign new vertex indices
        midpoint1_index = len(new_vertices)
        midpoint2_index = midpoint1_index + 1

        if side1:
            midpoint1 = Vertex([other_half1, one_half1, connecting_edge])
        else:
            midpoint1 = Vertex([one_half1, other_half1, connecting_edge])

        if side2:
            midpoint2 = Vertex([other_half2, one_half2, connecting_edge])
        else:
            midpoint2 = Vertex([one_half2, other_half2, connecting_edge])

        # two new vertices are added: the mid-points of the connected edges.
        new_vertices += [midpoint1, midpoint2]
        # the connecting edge has endpoints in the mid-points of
        # "edge1" and "edge2", and is *always* in third position.
        new_edges[connecting_edge] = Edge((midpoint1_index, 2), (midpoint2_index, 2))

        ((v1a, pos1a), (v1b, pos1b)) = new_edges[edge1].endpoints
        new_edges[one_half1] = Edge((v1a, pos1a), (midpoint1_index, side1))
        # replace "edge1" with new "other_half1" in the second endpoint
        new_vertices[v1b] = Vertex(new_vertices[v1b][:pos1b]
                                             + [other_half1]
                                             + new_vertices[v1b][pos1b+1:])
        new_edges[other_half1] = Edge((midpoint1_index, opposite_side1), (v1b, pos1b))

        # replace "edge2" with new "other_half2" in the second
        # endpoint; again we need to distinguish the special case when
        # "edge1" and "edge2" are the same edge.
        ((v2a, pos2a), (v2b, pos2b)) = new_edges[edge2].endpoints
        new_edges[one_half2] = Edge((v2a, pos2a), (midpoint2_index, side2))
        # `other half' of second edge *always* ends at the previous
        # edge endpoint, so replace "edge2" in "v2b".
        new_vertices[v2b] = Vertex(new_vertices[v2b][:pos2b]
                                             + [other_half2]
                                             + new_vertices[v2b][pos2b+1:])
        new_edges[other_half2] = Edge((midpoint2_index, opposite_side2), (v2b, pos2b))

        # inherit orientation, and add the three new edges in the order they were created
        # FIXME: this is not the identity in the last segment!!
        new_edge_numbering +=  [other_half1, other_half2, connecting_edge]

        # build new graph 
        return Fatgraph(new_vertices,
                        edges = new_edges,
                        num_edges = self.num_edges + other.num_edges + 3,
                        orientation = new_edge_numbering,
                        )

    def contract(self, edgeno):
        """Return new `Fatgraph` obtained by contracting the specified edge.

        Examples::

          >>> Fatgraph([Vertex([2,2,0]), Vertex([0,1,1])]).contract(0)
          Fatgraph([Vertex([1, 1, 0, 0])])
          >>> Fatgraph([Vertex([2,1,0]), Vertex([2,0,1])]).contract(1)
          Fatgraph([Vertex([0, 1, 1, 0])])

        The M_{1,1} trivalent graph yield the same result no matter
        what edge is contracted::

          >>> Fatgraph([Vertex([2,1,0]), Vertex([2,1,0])]).contract(0)
          Fatgraph([Vertex([1, 0, 1, 0])])
          >>> Fatgraph([Vertex([2,1,0]), Vertex([2,1,0])]).contract(1)
          Fatgraph([Vertex([0, 1, 0, 1])])
          >>> Fatgraph([Vertex([2,1,0]), Vertex([2,1,0])]).contract(2)
          Fatgraph([Vertex([1, 0, 1, 0])])
        """

        # Plug the higher-numbered vertex into the lower-numbered one.
        
        # store endpoints of the edge-to-be-contracted
        ((v1, pos1), (v2, pos2)) = self.edges[edgeno].endpoints

        # save highest-numbered index of vertices to be contracted
        l1 = len(self.vertices[v1]) - 1
        l2 = len(self.vertices[v2]) - 1

        # Build new list of vertices, removing the contracted edge and
        # shifting all indices above:
        #   - edges numbered 0..edgeno-1 are unchanged;
        #   - edges numbered "edgeno+1".. are renumbered, 
        #     shifting the number down one position;
        #   - edge "edgeno" is kept intact, will be removed by mating
        #     operation (see below).
        renumber_edges = dict((i+1,i)
                              for i in xrange(edgeno, self.num_edges))
        # See "itranslate" in utils.py for how this prescription is
        # encoded in the "renumber_edges" mapping.
        new_vertices = [ Vertex(itranslate(renumber_edges, V))
                         for V in self.vertices ]

        # Mate endpoints of contracted edge:
        # 1. Rotate endpoints "v1", "v2" so that the given edge would
        #    appear *last* in "v1" and *first* in "v2" (*Note:* since
        #    "v1", "v2" are *cyclic*, this means that we do the same
        #    operation on "v1" and "v2" alike).
        # 2. Join vertices by concatenating the list of incident
        #    edges;
        # 3. Set new "i1" vertex in place of old first endpoint:
        new_vertices[v1] = Vertex(
            new_vertices[v1][pos1+1:] + new_vertices[v1][:pos1]
            +
            new_vertices[v2][pos2+1:] + new_vertices[v2][:pos2]
            )
        # 4. Remove second endpoint from list of new vertices:
        del new_vertices[v2]

        # vertices with index below "v2" keep their numbering
        renumber_vertices = dict((x,x) for x in xrange(v2))
        # vertex "v2" is mapped to vertex "v1"
        renumber_vertices[v2] = v1
        # vertices with index above "v2" are now shifted down one place
        renumber_vertices.update(dict((x+1,x)
                                      for x in xrange(v2, self.num_vertices)))
        
        # renumber attachment indices, according to the mating of
        # vertices "v1" and "v2":
        # - on former vertex "v1":
        #   * indices (pos1+1)..l1 are mapped to 0..(l1-pos1-1)
        #     in the mated vertex;
        #   * index pos1 is deleted;
        #   * indices 0..pos1-1 are mapped to (l1-pos1)..l1-1;
        renumber_pos1 = dict((x, x-pos1-1)
                             for x in xrange(pos1+1, l1+1))
        renumber_pos1.update(dict((x, l1-pos1+x)
                                  for x in xrange(pos1)))
        # - on former vertex "v2":
        #   * indices (pos2+1)..l2 are mapped to l1..(l1+l2-pos2-1);
        #   * index pos2 is deleted;
        #   * indices 0..pos2-1 are mapped to (l1+l2-pos2)..l1+l2-1:
        renumber_pos2 = dict((x, l1-pos2-1+x)
                             for x in xrange(pos2+1, l2+1))
        renumber_pos2.update(dict((x, l1+l2-pos2+x)
                                  for x in xrange(pos2)))
        # build the new edges: except for edges insisting on vertices
        # "v1" and "v2", we just need to renumber the vertex indices,
        # and keep attachment indices untouched.
        def transform_endpoint(e):
            (v, a) = e
            if v == v1:
                return (v1, renumber_pos1[a])
            elif v == v2:
                return (v1, renumber_pos2[a])
            else:
                return (renumber_vertices[v], a)
        new_edges = []
        for (nr, edge) in enumerate(self.edges):
            if nr == edgeno:
                # skip contracted edge
                continue
            elif edge.meets(v1) or edge.meets(v2):
                new_edges.append(Edge(transform_endpoint(edge.endpoints[0]),
                                      transform_endpoint(edge.endpoints[1])))
            else:
                # XXX: re-use same "Edge" instances if vertex index does not change
                new_edges.append(Edge((renumber_vertices[edge.endpoints[0][0]], edge.endpoints[0][1]),
                                      (renumber_vertices[edge.endpoints[1][0]], edge.endpoints[1][1])))

        # Orientation of the contracted graph.
        cut = self.edge_numbering[edgeno]
        # edges with index below the contracted one are untouched
        renumber_edge_numbering = dict((x,x) for x in xrange(cut))
        # edges with index above the contracted one are shifted down
        # one position
        renumber_edge_numbering.update(dict((x+1,x)
                                      for x in xrange(cut, self.num_edges)))
        new_edge_numbering = [ renumber_edge_numbering[self.edge_numbering[x]]
                               for x in xrange(self.num_edges)
                               if x != edgeno ]
        
        # build new graph
        return Fatgraph(new_vertices,
                        edges = new_edges,
                        num_edges = self.num_edges-1,
                        orientation = new_edge_numbering,
                        )

    def edge_orbits(self):
        """Compute orbits of the edges under the action of graph
        automorphism group, and a representative for each orbit.
        
        Returns a dictionary, whose keys are the representatives, and
        whose values are the orbits.  Orbits are represented as Python
        `set` objects.

        Examples::

          >>> Fatgraph([Vertex([0,1,2]), Vertex([0,1,2])]).edge_orbits()
          {0: set([0, 1, 2])}

          >>> Fatgraph([Vertex([1, 0, 2]), Vertex([2, 1, 0])]).edge_orbits()
          {0: set([0, 1, 2])}
          
        """
        orbits = dict( (x, set([x])) for x in xrange(self.num_edges) )
        for a in self.automorphisms():
            for x in xrange(self.num_edges):
                if x not in orbits:
                    continue
                y = a.pe[x]
                if y not in orbits:
                    continue
                # "x" and "y" are in the same orbit, only keep the one
                # with lower abs. value, and remove the other.
                if y > x:
                    orbits[x].update(orbits[y])
                    del orbits[y]
        return orbits

    def edge_pair_orbits(self):
        """Compute orbits of pairs `(edge1, edge2)` under the action
        of graph automorphism group, and a representative for each
        orbit.
        
        Returns a dictionary, whose keys are the representatives, and
        whose values are the orbits.  Orbits are represented as Python
        `set` objects.

        Examples::

          >>> Fatgraph([Vertex([0,1,2]), Vertex([0,1,2])]).edge_pair_orbits()
          {(0, 1): set([(0, 1), (1, 2), (2, 0)]),
           (0, 0): set([(0, 0), (1, 1), (2, 2)]),
           (0, 2): set([(1, 0), (0, 2), (2, 1)])}
          
        """
        edge_pairs = [ (x,y) 
                       for x in xrange(self.num_edges)
                       for y in xrange(self.num_edges) ]
        orbits = dict( (p, set([p])) for p in edge_pairs )
        for a in self.automorphisms():
            for p in edge_pairs:
                if p not in orbits:
                    continue
                q = (a.pe[p[0]], a.pe[p[1]])
                if q not in orbits:
                    continue
                # "p" and "q" are in the same orbit, only keep the one
                # with lower abs. value, and remove the other.
                if p < q:
                    orbits[p].update(orbits[q])
                    del orbits[q]
        return orbits


    def endpoints(self, edgeno):
        """Return the endpoints of `edge`, as a pair of `(v, pos)`
        where `v` is the endpoint vertex index, and `pos` is the
        attachment index of `edge` into the `Vertex` object
        `self.vertices[v]`.

        The pair `((v1, pos1), (v2, pos2))` is ordered such that `v1 < v2`.
        """
        return self.edges[edgeno].endpoints


    def hangcircle(self, edge, side):
        """Return a new `Fatgraph`, formed by attaching a circle with
        a new edge to a new trivalent vertex in the middle of `edge`.

          >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])])
          >>> g1 = g.hangcircle(0, 0)
          >>> g1 is g
          False
          
        Argument `side` controls which side of `edge` the circle is
        hung to (valid values are 0 or 1), i.e., which of the two
        inequivalent cyclic orders the new trivalent vertices will be
        given::
        
          >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])])
          >>> g1 = g.hangcircle(0, 0)
          >>> g1 == Fatgraph([Vertex([0,1,2]), Vertex([3,2,1]), Vertex([0,3,4]), Vertex([5,5,4])])
          True
          >>> g2 = g.hangcircle(0, 1)
          >>> g2 == Fatgraph([Vertex([0,1,2]), Vertex([3,2,1]), Vertex([3,0,4]), Vertex([5,5,4])])
          True

        It is worth noting that the new graph will have 3 edges more
        than the original one::

          >>> g1.num_edges == g.num_edges + 3
          True
          
        """
        opposite_side = 0 if side else 1

        # assign edge indices
        
        # break "edge" in two halves: if "v1" and "v2" are the
        # endpoints of "edge", then the "one_half" edge extends from
        # the "v1" endpoint of "edge1" to the new vertex
        # "midpoint"; the "other_half" edge extends from the
        # "midpoint" new vertex to "v2".
        one_half = edge
        other_half = self.num_edges
        connecting_edge = self.num_edges + 1
        circling_edge = self.num_edges + 2
        
        # assign new indices to new vertices
        midpoint_index = self.num_vertices
        T_index = self.num_vertices + 1

        # two new vertices are added: the mid-point of "edge", and
        # the vertex "T" lying on the circle.
        if side == 1:
            midpoint = Vertex([other_half, one_half, connecting_edge])
        else: # side == 0
            midpoint = Vertex([one_half, other_half, connecting_edge])
        T = Vertex([circling_edge, circling_edge, connecting_edge])
        new_vertices = self.vertices + [midpoint, T]

        # new edges:
        # - inherit edges from parent, and add place for three new edges
        new_edges = self.edges + [
            None, # new edge: "other_half"
            None, # new edge: "connecting_edge"
            None, # new edge: "circling_edge"
            ]
        
        # - break "edge" into two edges "one_half" and "other_half":
        ((v1, pos1), (v2, pos2)) = self.edges[edge].endpoints
        new_edges[one_half] = Edge((v1, pos1), (midpoint_index, side))
        new_edges[other_half] = Edge((midpoint_index, opposite_side), (v2, pos2))
        new_vertices[v2] = Vertex(new_vertices[v2][:pos2]
                                             + [other_half]
                                             + new_vertices[v2][pos2+1:])

        # - the connecting edge has endpoints in the mid-point of
        # "edge" and in "T", and is *always* in third position:
        new_edges[connecting_edge] = Edge((midpoint_index, 2), (T_index, 2))

        # - the circling edge is a loop with vertex "T"
        new_edges[circling_edge] = Edge((T_index, 0), (T_index, 1))

        # Inherit edge numbering from parent and extend as identity
        # on the newly-added edges.
        new_edge_numbering = self.edge_numbering + \
                             [other_half, connecting_edge, circling_edge]

        # finally, build new graph 
        return Fatgraph(new_vertices,
                        edges = new_edges,
                        num_edges = self.num_edges + 3,
                        orientation = new_edge_numbering,
                        )
    

    def is_loop(self, edge):
        """Return `True` if `edge` is a loop (i.e., the two endpoint coincide).
        """
        return self.edges[edge].is_loop()
        

    def is_oriented(self):
        """Return `True` if `Fatgraph` is orientable.

        A `Fatgraph` is orientable iff it has no orientation-reversing
        automorphism.

        Enumerate all automorphisms, end exit with `False` result as
        soon as one orientation-reversing one is found.

        Examples::

          >>> Fatgraph([Vertex([1,0,1,0])]).is_oriented()
          False

          >>> Fatgraph([Vertex([2, 0, 1]), Vertex([2, 0, 1])]).is_oriented()
          True
          
          >>> Fatgraph([Vertex([2, 1, 0]), Vertex([2, 0, 1])]).is_oriented()
          False
          
          >>> Fatgraph([Vertex([2, 1, 1]), Vertex([2, 0, 0])]).is_oriented()
          False

          >>> Fatgraph([Vertex([3, 2, 2, 0, 1]), Vertex([3, 1, 0])], \
                    numbering=[(0, CyclicTuple((2,))),  \
                               (1, CyclicTuple((0, 1))),  \
                               (2, CyclicTuple((3, 1))),  \
                               (3, CyclicTuple((0, 3, 2))) ]) \
                               .is_oriented()
          True
          >>> Fatgraph([Vertex([2, 3, 1]), Vertex([2, 1, 3, 0, 0])], \
                       numbering=[(0, CyclicTuple((0,))),  \
                                  (2, CyclicTuple((1, 3))),  \
                                  (3, CyclicTuple((3, 0, 2))),  \
                                  (1, CyclicTuple((2, 1))) ]) \
                               .is_oriented()
          True
        """
        # Try to find an orientation-reversing automorphism the hard way
        for a in self.automorphisms():
            if a.is_orientation_reversing():
                return False
        # no orientation reversing automorphism found
        return True


    def isomorphisms(G1, G2):
        """Iterate over `Fatgraph` isomorphisms from `G1` to `G2`.

        An isomorphism is represented by a tuple `(pv, rot, pe)` where:

          - `pv` is a permutation of ther vertices: the `i`-th vertex
            of `G1` is sent to the `pv[i]`-th vertex of `G2`, rotated
            by `rot[i]` places leftwards;

          - `pe` is a permutation of the edges: edge `i` in `G1` is
            mapped to edge `pe[i]` in `G2`.

        This method can iterate over the automorphism group of a
        graph::

          >>> G1 = Fatgraph([Vertex([2, 1, 1]), Vertex([2, 0, 0])])
          >>> for f in G1.isomorphisms(G1): print f
          ({0: 0, 1: 1}, [0, 0], {0: 0, 1: 1, 2: 2})
          ({0: 1, 1: 0}, [0, 0], {0: 1, 1: 0, 2: 2})

        Or it can find the isomorphisms between two given graphs::

          >>> G2 = Fatgraph([Vertex([2, 2, 0]), Vertex([1, 1, 0])])
          >>> for f in G1.isomorphisms(G2): print f
          ({0: 0, 1: 1}, [2, 2], {0: 1, 1: 2, 2: 0})
          ({0: 1, 1: 0}, [2, 2], {0: 2, 1: 1, 2: 0})

        If there are no isomorphisms connecting the two graphs, then no
        item is returned by the iterator::

          >>> g3 = Fatgraph([Vertex([2, 1, 0]), Vertex([2, 0, 1])])
          >>> list(G1.isomorphisms(g3))
          []
        """
        
        # As this procedure is quite complex, we break it into a
        # number of auxiliary functions.
        
        def starting_vertices(graph):
            """
            Return the pair `(valence, vertices)`, which minimizes the
            product of valence with the number of vertices of that
            valence.

            Examples::

              >>> g = Fatgraph([Vertex([0,1,2]), Vertex([0,2,3]), Vertex([3,4,4,5,5])])
              >>> g.starting_vertices()
              (5, [Vertex([3, 4, 4, 5, 5])])
            """
            val = max(graph.vertex_valences())
            vs = None
            n = len(graph.vertices)+1
            for (val_, vs_) in graph.valence_spectrum().iteritems():
                n_ = len(vs_)
                if (n_*val_ < n*val) \
                       or (n_*val_ == n*val and val_<val):
                    val = val_
                    vs = vs_
                    n = n_
            return (val, vs)

        def compatible(v1, v2):
            """Return `True` if vertices `v1` and `v2` are compatible.
            (i.e., same valence and number of loops - one *could* be
            mapped onto the other.)
            """
            if len(v1) == len(v2) and v1.num_loops == v2.num_loops:
                return True
            else:
                return False
                
        def admissible_vertex_mappings(v, g, ixs):
            """Iterate over all (indices of) vertices in `g`, which
            `v` *could* be mapped to (that is, the destination vertex
            matches `v` in valence and number of loops.

            Third argument `ixs` restricts the search to the given
            subset of vertex indices in `g`.
            """
            for i in ixs:
                if compatible(v, g.vertices[i]):
                    yield i

        class CannotExtendMap(Exception):
            """Exception raised by `extend_map` on failure to extend a
            partial map.
            """
            pass

        def extend_map(pv, rots, pe, G1, i1, r, G2, i2):
            """Extend map `(pv, rots, pe)` by mapping the `i1`-th
            vertex in `G1` to the `i2`-th vertex in `G2` (and rotating
            the source vertex by `r` places leftwards).  Return the
            extended map `(pv, rot, pe)`.

            The partial map is a triple `(pv, rot, pe)` as in
            `Fatgraph.isomorphism` (which see), with the additional
            proviso that unassigned items in `rot` are represented by
            `None`.
            """
            v1 = G1.vertices[i1]
            v2 = G2.vertices[i2]
            if not compatible(v1, v2):
                raise CannotExtendMap

            # XXX: rotation has to be >=0 for the [r:r+..] shift below to work
            if r < 0:
                r += len(v2)

            if pv.has_key(i1):
                if pv[i1] != i2 or (rots[i1] - r) % len(v2) != 0:
                    raise CannotExtendMap
                else:
                    # this pair has already been added
                    return (pv, rots, pe)

            pv[i1] = i2
            rots[i1] = r

            # rotating "v1" leftwards is equivalent to rotating "v2" rightwards...
            v2 = v2[r:r+len(v2)]
            if not pe.extend(v1, v2):
                raise CannotExtendMap

            return (pv, rots, pe)

        def neighbors(pv, pe, G1, v1, G2, v2):
            """List of vertex-to-vertex mappings that extend map `pv`
            in the neighborhood of vertices `v1` (in the domain) and
            `v2` (in the codomain).

            Return a list of triplets `(src, dst, rot)`, where:
               * `src` is the index of a vertex in `G1`,
                 connected to `v1` by an edge `x`;
               * `dst` is the index of a vertex in `G2`,
                 connected to `v2` by the image (according to `pe`)
                 of edge `x`;
               * `rot` is the rotation to be applied to `G1[src]`
                 so that edge `x` and its image appear
                 at the same index position;
            """
            result = []
            for x in G1.vertices[v1]:
                if G1.edges[x].is_loop():
                    continue # with next edge `x`
                ((s1, a1), (s2, a2)) = G1.edges[x].endpoints
                src_v = s2 if (s1 == v1) else s1
                # ignore vertices that are already in the domain of `m`
                if src_v in pv:
                    continue # to next `x`
                src_i = a2 if (s1 == v1) else a1
                ((d1, b1), (d2, b2)) = G2.edges[pe[x]].endpoints
                dst_v, dst_i = (d2,b2) if (d1 == v2) else (d1,b1)
                # array of (source vertex index, dest vertex index, rotation)
                result.append((src_v, dst_v, dst_i-src_i))
            return result
            
        # if graphs differ in vertex valences, no isomorphisms
        vs1 = G1.valence_spectrum()
        vs2 = G2.valence_spectrum()
        if not set(vs1.keys()) == set(vs2.keys()):
            return # StopIteration
        # if graphs have unequal vertex distribution by valence, no isomorphisms
        for val in G1.vertex_valences():
            if len(vs1[val]) != len(vs2[val]):
                return # StopIteration

        (val, vs) = starting_vertices(G1)
        src0 = vs[0]
        V1 = G1.vertices[src0]
        for dst0 in admissible_vertex_mappings(V1, G2, vs2[val]):
            for rot0 in xrange(val):
                try:
                    # pass 0: init new (pv, rots, pe) triple
                    pv = Permutation()
                    rots = [ None for x in xrange(G1.num_vertices) ]
                    pe = Permutation()

                    # pass 1: map `V1` to "v2" and build map
                    # of neighboring vertices for next pass
                    pv[src0] = dst0
                    rots[src0] = rot0
                    if not pe.extend(V1, G2.vertices[dst0][rot0:rot0+val]):
                        continue # to next `rot0`

                    # pass 2: extend map to neighboring vertices
                    nexts = neighbors(pv, pe, G1, src0, G2, dst0)
                    while len(pv) < G1.num_vertices:
                        neighborhood = []
                        for (i1, i2, r) in nexts:
                            (pv, rots, pe) = extend_map(pv, rots, pe, G1, i1, r, G2, i2)
                            neighborhood += neighbors(pv, pe, G1, i1, G2, i2)
                        nexts = neighborhood

                # extension failed in the above block, continue with next candidate
                except CannotExtendMap:
                    continue # to next "rot0"

                # finally
                yield Isomorphism(G1, G2, pv, rots, pe)


    def num_automorphisms(self):
        """Return the cardinality of the automorphism group of this
        `Fatgraph` object.

        Examples::

          >>> Fatgraph([Vertex([0,1,2]), Vertex([0,2,1])]).num_automorphisms()
          6
          >>> Fatgraph([Vertex([0,1,1]), Vertex([0,2,2])]).num_automorphisms()
          2
        """
        return len(list(self.automorphisms()))
    

    def valence_spectrum(self):
        """Return a dictionary mapping valences into vertex indices.

        Examples::

           >>> Fatgraph([Vertex([1,1,0,0])]).valence_spectrum()
           {4: [0]}

           >>> Fatgraph([Vertex([1,1,0]), Vertex([2,2,0])]).valence_spectrum()
           {3: [0, 1]}

           >>> Fatgraph([Vertex([3, 1, 0, 1]), \
                      Vertex([4, 4, 0]), Vertex([3, 2, 2])]).valence_spectrum()
           {3: [1, 2], 4: [0]}
        """
        result = {}
        for (index, vertex) in enumerate(self.vertices):
            l = len(vertex)
            if l in result:
                result[l].append(index)
            else:
                result[l] = [index]
        return result

    def vertex_valences(self):
        return frozenset(len(v) for v in self.vertices)

    def vertex_valence_distribution(self):
        spec = self.valence_spectrum()
        return dict((v, len(spec[v]))
                    for v in spec.iterkeys())
\end{lstlisting}


\begin{lstlisting}
class Isomorphism(object):
    """An isomorphism of `Fatgraphs`.
    """

    def __init__(self, source, target, pv, rot, pe):
        self.source = source
        self.target = target
        self.pe = pe
        self.rot = rot
        self.pv = pv

    def __str__(self):
        return "(%s, %s, %s)" % (self.pv, self.rot, self.pe)

    def compare_orientations(self):
        """Return +1 or -1 depending on whether the orientations of
        the target Fatgraph pulls back to the orientation of the
        source Fatgraph via this `Isomorphism`.
        """
        image_edge_numbering = Permutation((self.source.edge_numbering[x],
                                            self.target.edge_numbering[self.pe[x]])
                                           for x in xrange(self.source.num_edges))
        return image_edge_numbering.sign()

    def is_orientation_reversing(self):
        """Return `True` if this `Isomorphism` reverses orientation on
        the source and target `Fatgraph` instances."""
        return (-1 == self.compare_orientations())

    def transform_boundary_cycle(self, bcy):
        """Return a new `BoundaryCycle` instance, obtained by
        transforming each corner according to a graph isomorphism.
        """
        triples = []
        for (v, i, j) in bcy:
            l = len(self.source.vertices[v])
            # create transformed triple 
            v_ = self.pv[v]
            i_ = (i + self.rot[v]) % l # XXX: is it `-` or `+`?
            j_ = (j + self.rot[v]) % l
            # ensure the contract is honored, that `j` is the
            # index following `i` in the cyclic order
            if i_ == 0 and j_ == l:
                i_, j_ = j_, i_
            triples.append((v_, i_, j_))
        return BoundaryCycle(triples, self.target)
\end{lstlisting}



\section[Stage II]{Stage II: compute boundary operator matrices}
\label{sec:stage-ii}

\section[Stage III]{Stage III: compute Betti numbers of $\M_{g,n}$}
\label{sec:stage-iii}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "index"
%%% End: 
